<!doctype html>

<html lang="fr">
<head>
  <meta charset="utf-8">

  <title>Modèle Génétique</title>
  <meta name="description" content="projet génétique doc">
  <meta name="author" content="Paul Schuhmacher">
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <link rel="stylesheet" href="./style.css">

</head>

<body>

    <h1 id="documentation--modèle-génétique--démographique" style="text-align: center;">Modèle génétique/démographique : Design général</h1>
    <p>22/02/2021<br>
    version 1</p>
    <h2 id="préambule">Introduction</h2>
    <h2 id="ce-quon-fabrique">Ce qu’on fabrique</h2>
    <p>Construire une bibliothèque que n’importe qui peut installer et utiliser dans ses propres projets informatiques. Cette bibliothèque est constituée d’un moteur (un ensemble de fonctions implémentant le modèle) ainsi que de données (avec un format bien défini) exportables et importables. Ainsi, les utilisateurs pourront partager leurs données entre eux (design du génome, des traits phénotypiques et des espèces) et une communauté <em>pourrait</em> se former construisant petit à petit des designs de plus en plus élaborés. L’idée c’est qu’on pourra construire à partir de ce qu’on a construit.</p>
    <p>Pour permettre cela tout en étant <em>user-friendly</em> des éditeurs avec interface graphique seront développés :</p>
    <ul>
    <li>Un éditeur de <a href="#support-g%C3%A9n%C3%A9tique">support génétique</a></li>
    <li>Un éditeur de <a href="#features">traits phénotypiques</a></li>
    <li>Un éditeur d’<a href="#esp%C3%A8ces">espèces</a></li>
    <li>Un bac à sable pour tester et explorer rapidement ses designs</li>
    <li>Un générateur de documentation des allèles et features de chaque espèce dans lequel il sera facile de chercher (nom, données retournées par une feature etc...)</li>
    </ul>
    <p>Les 3 éditeurs permettront d’éditer, importer, exporter, dupliquer, supprimer, ces 3 type de données facilement. Ces données seront ensuite importées dans le projet informatique de l’utilisateur et celui-ci, après import du moteur, pourra faire tourner le modèle dans le but qu’il s’est fixé.</p>
    <h2 id="objectifs">Objectifs</h2>
    <p>S’amuser. Fournir un moteur permettant de simuler des entités (biologiques ou non) possédant des caractéristiques (traits phénotypiques) <strong>interprétables par l’utilisateur</strong>. Ces caractéristiques sont le résultat de l’évaluation d’un support génétique (principalement). Les entités pourront se reproduire et transmettre à leur descendance une part de leur génome pour créer de l’hérédité, de la filiation (et de l’histoire). Ce génome pourra également être soumis à des mutations et évoluer. L’utilisateur pourra alors facilement simuler de la sélection et des populations au cours du temps dans son propre projet. Les espèces pourront muter, les populations évoluer etc. En somme un gros bac à sable. Ce modèle pourrait avoir des ambitions plus générales. Car s’il vise principalement à simuler <em>de la vie</em>, le moteur pourrait être appliqué à d’autres <em>objets</em>. On peut penser par exemple à faire une filiation de langues (en utilisant des méthodes de <a href="https://fr.wikipedia.org/wiki/Philologie">philologie comparée</a> comme a pu le faire (sérieusement) Tolkien : utiliser des règles spécifiques de mutation qui permette de passer d’un mot ancêtre à un mot descendant et vice versa). En fait tout ce qui est sujet à itérations successives, tout objet qui« produit du nouveau a partir de lui même » pourrait être simulé.</p>
    <h2 id="contraintes">Contraintes</h2>
    <p>La contrainte forte du modèle c’est qu’il faut définir à l’avance des traits phénotypiques auxquels l’utilisateur pourra donner <strong>du sens</strong>. J’insiste là dessus car le but est de pouvoir <strong>interpréter fonctionnellement le phénotype pour prendre des décisions.</strong> Ce que j’entends par là c’est que si une espèce possède un trait phénotypique qui renvoie la valeur ‘foo’ il faut que cette valeur <strong>puisse</strong> (pas nécessairement) avoir un sens pour l’utilisateur dans son programme. En ce sens, les traits phénotypiques doivent être définis dès le départ et le réservoir de phénotypes possibles doit pouvoir être contrôlé.</p>
    <h2 id="composants-à-développer">Composants à développer</h2>
    <p><img src="./img/composants.png" alt="Composants"><br>
    Le projet se compose des composants suivants à concevoir et développer :</p>
    <ul>
    <li>Les structures de données :
    <ul>
    <li>Support génétique</li>
    <li>Feature (traits phénotypiques)</li>
    <li>Espèce</li>
    </ul>
    </li>
    <li>Les éditeurs graphiques (web) pour les éditeurs de données:</li>
    <li>Un bac à sable pour aider à prototyper et tester ses designs</li>
    <li>Le moteur (toutes les fonctions, dépendances qui implémentent le modèle)</li>
    </ul>
    <p>Les structures de données seront complexes et un éditeur graphique pour les manipuler sera (quasi) indispensable. Ces éditeurs permettront d’importer et d’exporter les données facilement, de les éditer, dupliquer, supprimer. Le modèle est <em>piloté par les données</em>, ces structures sont capitales et doivent être manipulées et définies de manière rigoureuses.</p>
    <h2 id="aperçu-général-du-modèle-génétique--du-génome-au-phénotype">Aperçu général du modèle génétique : du génome au phénotype</h2>
    <p>L’utilisateur de la bibliothèque pourra faire évoluer des populations d’individus possédant un phénotype, ou un ensemble de traits observables et mesurables. L’utilisateur pourra évaluer les traits de chaque individu et leur appliquer le traitement qu’il souhaite. Ces traits seront l’expression d’un génome <strong>diploïde</strong> porté par chaque individu, transmissible par reproduction ou clonage de génération en génération.</p>
    <p>Le <em>support génétique</em> (encodé en binaire) lorsqu’il est évalué produit une valeur. Cette valeur est ensuite interprétée par une <em>feature</em> qui produit à son tour une valeur auquel l’utilisateur donne une unité de mesure. L’expression de la feature est alors remontée dans le phénotype, le résultat de l’évaluation de toutes les <em>features</em> de l’individu. La valeur en sortie d’une feature peut servir d’entrée à une autre <em>feature</em> et ainsi de suite. Ainsi, le phénotype forme une collection de couples clé:{valeur, unité} produite par l’évaluation d'un réseau de features (possiblement) interdépendantes, fondé sur un support génétique.  </p>


    <img id="general-model" class="modele-img" src="./img/modele-general" alt="Modèle général">


    <p>Lors de la reproduction ou du clonage, le support génétique est transmis à l’aide de mécanismes connus de la biologie (mais nécessairement simplifiés) : mitose, méiose.</p>
    <p>Le support génétique pourra être exposé à des mutations. Chaque individu disposera en plus de son support génétique d’un état interne modélisant les effets <em>épigénétiques</em>. Cet état supplémentaire, non encodé dans le génome, pourra modéliser la transmission de caractères acquis.</p>
    <h2 id="notations">Notations</h2>
    <ul>
        <li> \(a-B\) : allèles a et B sur le même locus d’une paire de chromosomes analogues. a est récessif et B est dominant</li>
        <li> \((a-B)(a-c)(B-B)\) : ensemble de couples d'allèles sur 3 gènes d’une paire de chromosomes analogues. L'ordre des couples n'a pas d'importance</li>
    </ul>
   
    <h2 id="les-modèles-de-données">Les modèles de données</h2>
    <h3 id="support-génétique">Support génétique</h3>
    <p>Un support génétique est une séquence en binaire (de 0 et de 1) qui peut être évalué pour <strong>produire des valeurs</strong> entières.</p>
    <table>
        <thead>
            <tr>
                <th colspan="4">Support génétique</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Paramètre</th>
                <th>Description</th>
                 <th>Type</th>
                  <th>Contraintes</th>
            </tr>
        <tr>
                <td>Nom</td>
                <td>Un nom donné au support</td>
                <td>String</td>
                 <td>Unique</td>
            </tr>
            <tr>
                <td>Nombre de gènes <code>N</code></td>
                <td>Nombre de gènes contribuant à la valeur du support</td>
                 <td>Integer</td>
                   <td>\( N \ge 1\)</td>
            </tr>
              <tr>
                <td>Nombre de bits <code>n</code></td>
                <td>Nombre de bits sur lequel est encodé chaque gène du support : l’utilisateur pourra choisir d’encoder des gènes sur des structures allant de 1 à 8 bits (limite arbitraire). Ce paramètre défini par défaut le nombre de variations d’un même gène (allèles) accessibles. Par exemple, sur un support à 2 bits on a 4 valeurs possibles : 00 (0), 01 (1), 10 (2) et 11 (3). On a donc, au maximum 4 allèles pour ce gène dans notre « réservoir ». Sur 8 bits on a 256 valeurs possibles, donc 256 allèles possibles pour un même gène. La structure binaire est suffisante pour créer assez de variations (pas besoin de 4 caractères AGCT). </td>
                 <td>Integer</td>
                  <td>\( 1 \le n \le 8 \)</td>
                </tr>
                <tr>
          <td>Rareté d'une allèle \(r\)</td>
          <td>Sur les allèles disponibles on peut définir une rareté, un nombre qui sert au moment de la génération de populations. Ce nombre permettra de définir chance qu'un individu généré (non issu d'une reproduction) porte cet allèle initialement. </td>
           <td>Float</td>
            <td>\( 0 \le r \le 1 \)</td>
      </tr>
            </tr>
                      <tr>
                <td>Allèles disponibles <code>n<sub>a</sub></code></td>
                <td>Le réservoir d'allèles disponibles est par définition définie par le nombre de bits sur lequel est encodé un gène. L’utilisateur pourra décider de n’utiliser qu'un sous-ensemble de ce réservoir s’il le souhaite. <strong>Une allèle est une valeur</strong> possible d'un gène. Elle peut donc muter dans l'espace défini par le gène vers une autre valeur. </td>
                 <td>(Integer...)</td>
                  <td>\( 1 \le n_a \le N^{2} \)</td>
            </tr>
             <tr>
                <td>Relations entre allèles <code>U</code></td>
                <td>Tableau de coefficients dont chaque valeur permet de calculer la contribution de chacune des 2 allèles du même gène à l’évaluation du support génétique. L’utilisateur pourra générer ces coefficients de manière aléatoire ou suivant des règles prédéfinies, ou les écrire manuellement (il y a toujours le contrôle total si on le souhaite).</td>
                 <td>[Float]</td>
                  <td>
                  \( n_a(n_a+1)/2\) coefficients nécessaires pour évaluer toutes les combinaisons possibles, voir <a href="#table-genetic-support-summary">ce tableau</a>
                  </td>
            </tr>
        </tbody>
    </table>
    <p>Pour résumer, l’évaluation d’un support génétique (et la production d’une valeur) se fait en évaluant pour chacun de ses gènes la paire d’<a href="https://fr.wikipedia.org/wiki/All%C3%A8le">allèles</a> (une allèle sur chaque <a href="https://fr.wikipedia.org/wiki/Chromosome_homologue">chromosome homologue</a>) correspondante. Les relations entre allèles permettent de calculer la <strong>valeur</strong> du support génétique.</p>


    <h4>Dominat/Récessif, dominance incomplète et codominance</h4>
<p>
    <a href="https://fr.wikipedia.org/wiki/All%C3%A8le#Relations_entre_all%C3%A8les">Plusieurs relations entre allèles</a> existent. Le modèle se propose de modéliser 3 d'entre elles :

</p>


   <ul>
       <li><strong>Dominant/récessif :</strong>  un allèle récessif demande l'homozygotie d'un gène pour pouvoir s'exprimer. Autrement dit, soit \(a-B\) deux allèles du même gène, a est récessif (et B est dominant) si  \(u(a,B)=0\). Ce gène est évalué à \(B\)</li>
       <li><strong> Dominance incomplète :</strong> aucun des allèles qui déterminent le caractère est dominant, les deux s'expriment et le caractère est un mélange des deux contributions. Autrement dit, soit \(a-b\) deux allèles du même gène, a et b ont une dominance incomplète si  \( u(a,b) \in  \left] 0 : 1\right[ \). Ce gène est évalué à {\(A: u(a,b), B: 1-u(a,b)\)}. En ce sens, le modèle Dominant/récessif n'est qu'un cas particulier de dominance incomplète.</li>
       <li><strong>Codominance :</strong>  les deux allèles s'expriment en même temps, et le trait est l'expression conjointe des deux allèles.Autrement dit, soit \(A-B\) deux allèles du même gène, il faut donner au coefficient une valeur distincte pour prendre en compte ce cas. On pose par définition la valeur \(u(A,B)=-1\) pour symboliser ce cas. L'évaluation du gène retourne la valeur \(AB\). Dans ce cas, deux allèles peuvent produire 3 valeurs distinctes : A , B et AB  </li>

       <li><strong>Allèle inerte :</strong>on verra à la section sur <a href="#mutations">les mutations</a> qu'une allèle peut devenir inerte, c'est à dire qu'elle n'exprime plus rien. Une allèle inerte est toujours récessive, si deux allèles inertes sont sur le même gène le gène ne renvoie aucune évaluation.</li>
       <li><strong>Allèle léthale :</strong>: si cette allèle s'exprime l'individu meurt</li>
   </ul>

   
<p>
    Voici un tableau résumant les valeurs prises par les coefficients pour chaque type de relation entre allèles, ainsi que le résultat de l'évalution d'un gène \(A-B\). L'évaluation produit un ensemble clé:valeur noté \( \{ A: w_A , B: w_B \} \) où \(A\) est l'identifiant de l'allèle A et \(w_A\) son poids dans l'expression du gène. Si le poids est nul l'allèle n'est pas exprimé, s'il est égal à 1 on écrira \( \{ A: 1 \}  \equiv \{ A\} \equiv A \). S'il n'y qu'un gène on pourra écrire  \( \{ A\} \equiv A \)
</p>
   <table id="table-genetic-support-summary">
    <thead>
        <tr>
            <th colspan="5">Supports génétiques</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Relation</td>
            <td>Valeurs du coefficient</td>
            <td>Evaluation</td>
        </tr>
        <tr>
            <td>Dominant/Récessif</td>
            <td>\(u(A,B) \in \{0 , 1\}\)</td>
            <td>\( A \) ou \( B \) </td> 
        </tr>
        <tr>
            <td>Dominance incomplète</td>
            <td>\(u(A,B) \in \left]0:1\right[\)</td> 
            <td>\( \{ A: u(A,B) , B: 1-u(A,B) \} \)</td>  
        </tr>
        <tr>
            <td>Codominance</td>
            <td>\(u(A,B) = -1\)</td> 
            <td>\( \{ AB: 1 \}\)</td>  
        </tr>
        <tr>
            <td>Allèle inerte \(A\)</td>
            <td>\(u(A,B) = 0, \forall B\)</td> 
            <td>\( \{ B: 1 \}\)</td>  
        </tr>
        <tr>
            <td>Allèles inertes \(A\) et \(B\) </td>
            <td>\(u(A,B) = u(B,A) = 0\)</td> 
            <td>\( \{ \}\)</td>  
        </tr>
    </tbody>
</table>

<p>
    Pour le moment aucune valeur n'est assignée à chaque allèle, sa valeur est son code binaire (ou son nom qui est un alias pour ce code). La valeur et le sens seront défini au niveau d'une <a href="#features">feature</a>.
</p>


    <h4 id="exemple--support-génétique-continu">Exemple 1 :</h4>
    <p>Prenons un support génétique :</p>
    <ul>
    <li>codé sur 3 gènes</li>
    <li>chaque gène est codé sur 2 bits</li>
    <li>Allèles disponibles : toutes, soit
    <ul>
    <li>00 ( A )</li>
    <li>01 ( B )</li>
    <li>10 ( C )</li>
    <li>11 ( D )</li>
    </ul>
    </li>
    </ul>
    <p>Initialisons le tableau des relations entre allèles :</p>
    <div class="center-container">
    <table>
        <tbody>
            <tr>
                <td></td>
                <td>A</td>
                 <td>B</td>
                <td>C</td>
                 <td>D</td>
            </tr>
            <tr>
                <td>A</td>
                <td>1</td>
                 <td>0.3</td>
                <td>0.7</td>
                 <td>1</td>
            </tr>
              <tr>
                <td>B</td>
                <td>-</td>
                 <td>1</td>
                <td>0.2</td>
                 <td>0.4</td>
            </tr>
            <tr>
                <td>C</td>
                <td>-</td>
                 <td>-</td>
                <td>1</td>
                 <td>0.5</td>
            </tr>
             <tr>
                <td>D</td>
                <td>-</td>
                 <td>-</td>
                <td>-</td>
                 <td>1</td>
            </tr>
        </tbody>
    </table>
</div>

<p>On a par définition</p>
    $$u(A,B) = 1 - u(B,A) $$ 
    <p>si A et B ne sont pas codominants. Pour le cas de codominance on a défini une valeur arbitraire</p>
    $$u(A,B) = u(B,A) = -1 $$ 

<p>On peut noter que l'allèle D est récessif vis à vis de A qui est dominant. Dans tous les autres rapports d'allèles nous sommes dans un cas de dominance incomplète. Évaluons à présent un individu qui posséderait un support génétique initialisé comme suit :</p>
$$(a-b)(c-b)(a-d)$$

<p>L’individu est <a href="https://fr.wikipeda.org/wiki/H%C3%A9t%C3%A9rozygote">hétérozygote</a> pour chacun des 3 gènes. L'évaluation du support génétique donne </p>

    $$ v = \{ A:1.3, B:0.9, C:0.8 \}$$
   
<p>On peut voir que si le support génétique est constitué de plusieurs gènes il suffit d'ajouter les contributions de chaque gène.</p>

    <h4>Exemple 2</h4>

    <p>Reprenons le même support génétique :</p>
    <ul>
    <li>codé sur 3 gènes</li>
    <li>chaque gène est codé sur 2 bits</li>
    <li>Allèles disponibles : 3 sur les 4 disponibles, soit
    <ul>
    <li>00 ( A )</li>
    <li>01 ( B )</li>
    <li>10 ( C )</li>
    </ul>
    </li>
    </ul>
    <p>Construisons un autre tableau de relations entre allèles :</p>
    <div class="center-container">
    <table>
        <tbody>
            <tr>
                <td></td>
                <td>A</td>
                 <td>B</td>
                <td>C</td>
            </tr>
            <tr>
                <td>A</td>
                <td>1</td>
                 <td>-1</td>
                <td>1</td>
            </tr>
              <tr>
                <td>B</td>
                <td>-</td>
                 <td>1</td>
                <td>0.5</td>
            </tr>
            <tr>
                <td>C</td>
                <td>-</td>
                 <td>-</td>
                <td>1</td>
            </tr>
        </tbody>
    </table>
</div>

<p> Évaluons à présent un individu qui posséderait un support génétique initialisé comme suit :</p>
$$ (C-B)(A-C)(A-B) $$


<p>L’individu est <a href="https://fr.wikipeda.org/wiki/H%C3%A9t%C3%A9rozygote">hétérozygote</a> pour chacun des 3 gènes. L'évaluation du support génétique donne </p>
$$ v = \{ AB: 1, A:1, B:0.5, C:0.5 \}$$

<p>Les allèles A et B sont codominantes, elles s'expriment donc toutes les deux mais leurs effets ne se combinent pas, elles produisent une nouvelle valeur \(AB\), un nouveau phénotype.</p>

<h3>Sur les allèles</h3>
Un allèle est un code binaire, une variation d'un gène. Son code binaire est son identifiant, qu'on pourra surharger avec un nom. Un allèle peut être déclaré :
<ul>
    <li>Disponible : l'allèle pourra être présent à l'initatialisation d'une population d'individus</li>
    <li>Mutant : non accesible par défaut, seulement par mutation de son code génétique</li>
</ul>
Un allèle pourra muter 
<ul>
    <li>vers un allèle existant (Disponible), équivalent à du brassage génétique</li>
    <li>vers un allèle mutant (Mutant), introduction d'un nouvel allèle dans la population</li>
</ul>
Au niveau de la feature, la valeur de cet allèle (ainsi que son rapport aux autres) peut être
<ul>
    <li>défini à l'avance par l'utilisateur. Ainsi il garde le contrôle complet sur les entrées/sorties au niveau des features </li>
    <li>défini aléatoirement (par une fonction), l'utilisateur perd alors le contrôle sur l'évaluation du génome qui va évoluer de lui même (selon des règles définies à l'avance) </li>
</ul>
Dans le deuxième cas de figure, de l'évolution incontrôlée pourra apparaître car même l'utilisateur ne saura pas à l'avance la valeur que va produire le support génétique. Les deux cas sont intéressants, le contrôle doit être libre pour l'utilisateur. Dans le cas où les valeurs ne seront pas définies à l'avance (et pourront être n'importe quoi), il faudra prévenir l'utilisateur que la valeur que prend en entrée la feature est inconnue ou imprévisible, afin d'être sûr de ne pas casser son code. A charge de l'utilisateur de faire le nécessaire pour l'interpréter (la solution la plus simple consistant à retourner la valeur telle quelle.)
    <h3 id="features">Feature (ou trait, phénotype local)</h3>

    <h4>Définition</h4>

    <p>Une fois définis des supports génétiques on peut commencer à designer le composant à l'étage du dessus : la feature. Une feature est un trait (un phénotype) observable au niveau de l'individu. Jusqu’ici on a seulement parlé de support génétique dont l'évaluation produit des valeurs.  C’est donc à ce niveau qu’on va  <em>donner un sens aux valeurs générées par le support génétique</em>. La feature produit une   <strong>observable</strong> que l'utilisateur va définir. </p>

    <p>L’intérêt de découpler la production de valeur par un support génétique de son interprétation c’est qu'ont peut réutiliser un même support pour plusieurs features (dans différents projets) et redéfinir l'interprétation que l'on fait de sa valeur.</p>
    <p>
        La feature est une fonction qui va prendre en entrée la valeur d'un support génétique, <a href="#features-coupling">ou d'une autre feature</a>, et retourner un phénotype, c'est à dire, une valeur et (possiblement) une grandeur et une unité de mesure. C'est une fonction au sens mathématique du terme : à chaque valeur de l'ensemble de départ (valeurs du support génétique) elle produira une valeur (ici un couple {valeur, unité}) dans un ensemble d'arrivée (valeurs du phénotype).
    </p>

    <p>
        Le point important c'est qu'une feature <strong>ne possède pas d'état interne</strong>. Elle prend des valeurs en entrée et renvoie des valeurs en sortie. Les même valeurs en entrée produisent les mêmes valeurs en sortie. Elle n'a aucun effet de bord, c'est à dire que lorsqu'elle est évaluée elle ne <em> modifie pas l'état du monde</em> (exception faite des <a href="#epigenetique"> features attachées à l'état épigénétique</a>). En d'autres termes ce sont des <a href="https://fr.wikipedia.org/wiki/Fonction_pure">fonctions pures</a>. L'état d'un individu est complètement encodé dans ses supports génétiques et son épigénetique. L'ensemble des features vient agir comme une fonction qui prend cet état et renvoie un phénotype macroscopique. 
    </p>

    <img src="./img/feature-function.png" alt="">

   <p>Pour définir l'évaluation d'une feature, lui donner sens, nous allons avoir besoin d' </p>

    <ul>
        <li>une valeur : nombre décimal, une chaîne de caractères, un ensemble de clé:valeur, voir même une fonction</li>
        <li>une grandeur: (ex: temps, longueur, grandeur personalisée...) [OPTIONNEL]</li>
        <li>une unité de measure: ‘m/s’, des ‘mols’, des ‘kg’, des ‘grade’, des ‘milipilpoils’ etc.. [OPTIONNEL]</li>
    </ul>
    
    <p>
       L'unité de mesure servira à faire de l'analyse dimensionnelle et valider la cohérence de certaines expressions. Elle pourra servir à faire des conversions automatiques. Par exemple si un phénotype représente une taille, on pourra demander à évaluer cette valeur en 'cm', en 'm' sans avoir besoin de faire la conversion nous même.
    </p>

    <p class="note">
        A noter : l'utilisateur s'il souhaite avoir directement accès à la valeur du support génétique peut le faire, il peut demander à la feature de retourner directement la valeur du support. L'utilisateur pourrait lui donner une valeur (et une dimension, et unité de mesure) dynamiquement durant l'execution de son programme. Par exemple, regardons ce pseudo code d'un utilisateur qui utilise notre bibliothèque dans son projet
    </p>


    <h4>Paramètres</h4>

    <table>
        <thead>
            <tr>
                <th colspan="4">Feature</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Paramètre</th>
                <th>Description</th>
                 <th>Type</th>
                  <th>Contraintes</th>
            </tr>
        <tr>
                <td>Nom</td>
                <td>Un nom donné à la feature</td>
                <td>String</td>
                 <td>Unique</td>
            </tr>
            <tr>
                <td>Source</td>
                <td>D'où proviennent les entrées de la feature</td>
                <td>Support Génétique ou (Features...)</td>
                 <td>Unique si support, MAX(à définir) si features</td>
            </tr>
            <tr>
                <td>Output</td>
                <td>Données en sortie de la feature</td>
                <td>Ensemble {clé:valeurs},<code>Object</code></td>
                 <td>
                     Doit respecter le schéma <code>{valeur: Object, dimension: String, unit: String}</code>. Ajouter peut être une contrainte sur le schéma de <code>value</code>
                   </td>
            </tr>
            <tr>
                <td>Input</td>
                <td>Données en entrée de la feature. <ul>
                    <li>Si support génétique : évaluation du support [entrées possibles définies]</li>
                    <li>Si une ou plusieurs features : concaténation des évaluations des features</li>
                </ul></td>
                <td>Ensemble {clé:valeurs},<code>Object</code></td>
                 <td>

                    <ul>
                        <li> Si source est support : structure passée en entrée doit contenir les clefs appartenant à l'ensemble des allèles définis sur le support</li>

                        <li>Si sources est features : voir contraintes à mettre. Chaque input doit respecter le schéma de données Output de la source. Chaque input doit respecter le schéma <code>{valeur: Object, dimension: String, unit: String}</code>  </li>
                    </ul>
                     
                    
                   </td>
            </tr>
            <tr>
                <td>Log</td>
                <td>Historique de toutes les valeurs générées par la feature. A chaque évaluation, si l'évaluation est différente de la précédente valeur on la log.</td>
                <td>Stack (Last in First Out) { t: {valeur, dimension, unit}}, tableau d'Object</td>
                 <td>
                   Aucune
                   </td>

            </tr>
        </tbody>
    </table>


    <h4>Ecrire une feature</h4>

    Pour qu'une feature fonctionne il faut définir :

    <ul>
        <li>ce qu'elle prend en entrée: quelles données arrivent du support génétique</li>
        <li>ce qu'elle retourne en sortie: quelle transformation j'opère pour produire une valeur "phénotype"</li>
    </ul>

    <p class="comment">Quand j'écris une valeur phénotype c'est assez général, on n'impose rien sur le type de retour d'une feature [a voir en fonction du design général], mais en général on peut faire retourner à une feature ce qu'on veut. Ce sont là plutot des questions techniques, savoir s'il faut fabriquer des types de données à respecter pour assurer une architecture robuste. Ces restrictions viendront au fil de l'eau, par défaut, une feature peut renvoyer n'importe quelle valeur.</p>

    <h4>Mapper les valeurs des allèles</h4>

    <p>La première étape est donc de <em>maper</em> (d'associer) à chaque allèle exprimée du support génétique une valeur. Comme les allèles sont définies au niveau du support génétique on peut facilement proposer une liste de valeurs à maper à l'utilisateur. On peut associer à la valeur de l'allèle n'importe quelle valeur de notre choix</p>
<p>Prenons un exemple de valeur produite par le support génétique encodé sur 3 gènes</p>
$$(c-B)A(A-B) $$
<p>qui est évalué à</p>
    $$ S =\{ AB: 1, A:1, B:0.5, C:0.5 \} $$
    On doit proposer à l'utilisateur d'associer à chaque allèle une valeur. Prenons \(A\), voici les possibilités :

    <ul>
        <li>Associer un entier : \(A \mapsto 1 \)</li>
        <li>Associer un nombre décimal : \(A \mapsto 0.1 \)</li>
        <li>Associer une chaine de caractères : \(A \mapsto \text{'foo'}\)</li>
        <li>Associer un tableau : \(A \mapsto \left[1, \text{'foo'}, 0.5, \left[1, \text{'foo'}, 0.5,  \right]\  \right]\)</li>
        <li>Associer une association clé:valeur : \(A \mapsto \{a: 1, b: \text{'foo'}\}\)</li>
        <li> <a href="#fonctionnal-feature">Associer une fonction</a> : \(A \mapsto f(S)\)</li>
    </ul>

    <p>On pourra évidemment proposer ici de mapper des valeurs de manière automatique (pattern, aléatoire etc..)</p>

    <p>On pourrait imaginer ne pas contraindre l'utilisateur à définir la valeur de chaque allèle. Ainsi, une valeur non mappée aurait une valeur assignée par le système, par exemple <code>unknown</code>.</p>

    <code class="pseudo-code">
        <pre>
x = evaluate(individu, feature) // acceder au phénotype retourné par la feature
//Allèle inconnue (mutation, non définie par l'utilisateur)
if(unknown(x)){
    //Do stuff
    valeur = ....
    // retrouve l'allèle unknown et lui assigne valeur,dimension, unité
    setValue(feature, 'valeur', dimension, unité) 
}
        </pre>
    </code>

    <p>Nous reviendrons sur la possibilité de tomber sur des allèles dont l'évaluation est inconnue dans la section <a href="mutations">mutations</a> </p>

    <h4>Cas d'un support codé sur un gène</h4>

    <p>
        Dans le cas d'un support encodé sur un seul gène, la question ne se pose pas, on retourne la valeur mappé à la valeur qui s'est exprimée.
    </p>

    <h4>Cas d'un support codé sur plusieurs gènes</h4>
    <p>
       Comme dans notre exemple, dans ce cas plusieurs stratégies d'interprétation peuvent être définies par l'utilisateur.
       On peut :
       <ul>
           <li>Renvoyer toutes les valeurs avec leurs poids (information transparente, l'utilisateur en fera quelque chose soit dans une feature à l'étage supérieur, soit directement dans son projet)</li>
           <li>Filtrer : ne renvoyer qu'une valeur, envoyer des valeurs dont le poids normalisé respecte une condition</li>
       </ul>
    </p>

    <p>On peut proposer des stratégies de map au lieu de map indivduellement chaque allèle.</p>
   
    <h5>Map Combinaison linéaire</h5>

    <p> <strong>Si et seulement si l'utilisateur map chacune des allèles à un nombre (entier ou décimal) </strong>on peut proposer à l'utilisateur d'en faire un combinaison linéaire se servant du poids caractérisant la contribution de chaque allèle. Par exemple ici, définissons cette association : </p>
    <ul>
        <li>\(AB \mapsto 1 \)</li>
        <li>\(A \mapsto 0 \)</li>
        <li>\(B \mapsto 5 \)</li>
        <li>\(C \mapsto -1 \)</li>
    </ul>
    <p>On peut facilement fabriquer de la variation continue en faisant la combinaison linéaire de l'expression de chaque allèle</p>

    $$ \frac{1}{3} (v_{AB} + v_A + 0.5v_B + 0.5v_C)  $$
    <p>en utilisant le poids de l'expression de chaque allèle. La feature sera évaluée ici à \(1\)</p>

    L'évaluation en combinaison linéaire d'un support génétique encodé sur \(N\) gènes est donné par 

    $$ V = \frac{1}{N}\sum_{i=1}^{N} u(i_a,i_b)v_a + (1-u(i_a,i_b))v_b $$ 

    Soit
    $$ V = \frac{1}{N}\sum_{i=1}^{N}  u(i_a,i_b)\left[v_a -v_b\right] + v_b $$ 

    <p>avec \(i_a\) et \(i_b\) les allèles a et b du gène \(i\).</p>

    <p>
        L'utilisateur peut ensuite <strong>metre à l'échelle (rescale)</strong> les valeurs obtenues vers un nouvel intervalle. En effet, en fonction des valeurs qu'il a associé à chaque allèle, il a accès à l'intervalle du domaine de départ (les bornes min et max), ici \( \left[ -1 : 5 \right]\). Il peut interpoler chaque valeur de cet intervalle vers un autre intervalle. Pour cela il a juste à définir un min, un max et une fonction d'interpolation. Par exemple, il définit l'intervalle d'arrivée à \( \left[ 10 : 300 \right]\) et une fonction d'interpolation linéaire.
    </p>
    <p>
        On peut faire une interpolation linéaire ou avec n’importe quel polynôme. Le choix de l'interpolation est un paramètre intéressant car ainsi, une variation infime du génome (brassage, mutation) peut conduire à des variations phénotypiques plus fortes (et non directement proportionnelle ou graduelle)
    </p>

    <img src="img/interpolation.png" alt="" style="width:80%">



    <h5>Stratégies par défaut</h5>

    <p>On peut proposer des stratégies par défaut (sans avoir à écrire du code) pour définir la valeur renvoyée par la feature</p>

    <ul>
        <li>Faire remonter l'allèle qui s'exprime le plus. Cela revient à donner plus de poids à certains gènes d'un support. </li>
        <li>... ?</li>
    </ul>
 

    <p class="question">Comment ça se passe pour un trait phénotypique encodé sur plusieurs gènes ? Quelles stratégies on peut mettre en place pour fabriquer une interprétation d'un support génétique s'exprimant sur plusieurs gènes ? Quel rôle donner aux <em>poids d'expression</em> ?</p>


    <h5>Ultime possibilité (et la plus forte) : écrire soi même sa fonction !</h5>


    <p>
        L'idéal est de pouvoir écrire soi même une fonction qui renverra le phénotype. Cette fonction permet de couvrir toutes les autres stratégies définies précédemment (celles-ci ne sont que des aides pour l'utilisateur, lui proposer des stratégies clés en main sur des patterns courants). Ainsi on peut imaginer ouvrir une fenêtre d'édition à l'utilisateur pour qu'il écrive soi même sa fonction
    </p>
    <code class="pseudo-code">
        <pre>
function evaluate(args){
    //Write your own function that returns a phenotype (data)
    //...
    return {}
}
        </pre>
    </code>
    <p>où <code>args</code> est une variable d'entrée de la fonction que l'utilisateur peut utiliser. Elle aurait toutes les infos nécessaires pour écrire la fonction : les valeurs de départ du support, les poids et les valeurs mappés. Par exemple ici :</p>
<pre>
    <code>args = {
        genetic: { 
          AB: {
            // poids expression de la valeur retournée par le support
            weight: 1, 
            // la valeur assignée par l'utilisateur
            map: 1 
          },
          A: {
            weight: 1,
            map: 0  
          },
          B: {
            weight: 0.5,
            map: 5  
          },
          C: {
            weight: 0.5,
            map: -1  
          },
         }
        featureB: {}
        ...
    }
    </code>
</pre>

<p> Le code sera à écrire en JavaScript. Il permettra de faire tout ce qu'on veut. Justement, tout ce qu'on veut peut amener à des gros poblèmes de sécurité. Il faudra songer à ce point : accès au DOM, Web API du navigateur? Emettre des requetes? Il faudra proposer un environnement où on peut contrôler les autorisations qu'on donne à ce code.</p>
<p class="note">Peut-être faudra-t-il demander en plus à l'utilisateur de donner un schéma de réponse (la structure de la collection clé/valeurs et les types de données) dans le cas où une autre feature vient prendre en entrée ce résultat. Comme ça on pourrait lui garantir un certain format de données à utiliser pour composer sa prochaine stratégie et éviter bien des bugs.</p>

<h5>Contrainte sur la valeur retournée?</h5>

<p>Si l'utilisateur écrit sa propre fonction (dans les autres cas ça sera fait automatiquement) il devra fournir un schéma de données pour la valeur retournée par la feature. Par exemple </p>
<pre>
    <code>phenotype = [
        {
            value: String,
            dimension: String,
            unit: String,
        },
        {
            value: Integer,
            dimension: String,
            unit: String,
        },
        ...
       ]
    }
    </code>
</pre>
<p>Ainsi il sera beaucoup plus simple dans l'étape de design de coupler les features, car on saura exactement quelles données on recevra en entrée. Il est peut être même possible qu'on puisse récupérer les valeurs possibles retournées (on peut imaginer créer un bouton dans l'éditeur <code>Test</code> qui testerait la fonction (vérification entrées, vérification du retour conforme au schmé) et qui évalue la fonction sur toutes les entrées possibles pour produire tous les outputs possibles. On aurait alors la liste de toutes les sorties qui pourra être accessible à la feature qui veut la prendre en entrée. </p>
    <p>Ici j'ai mis un tableau de structure phénotype {value, dimension, unit}, on pourrait restreindre encore davantage à une seule structure phénotype. On peut contraindre pas mal je pense car si on met trop de libertés ça va compliquer le design. Si une feature peut renvoyer deux phénotypes différents c'est qu'elle peut probablement être découpée en deux features qui retourne chacune un seul. Ces questions seront tranchées par la pratique.</p>
    

<p>Prenons un exemple simple ici j'écris ma fonction, je veux, par exemple, retourner la valeur de \(AB\) si elle existe, sinon je renvoie 'toto'</p>
<code class="pseudo-code">
    <pre>
function evaluate(args, phenotype = { value: undefined, dimension = undefined, 
    units = undefined}){
    if( 'AB' in args.data){
        // valeur du phénotype retourné
        phenotype.value =  args.data['AB'].map
        phenotype.dimension = 'Length'
        phenotype.units = 'm'
        return phenotype
    }
    //Si AB n'est pas présent
    phenotype.value = 'toto'
    return phenotype
}
    </pre>
</code>

<p>Ici on contraint la réponse à respecter le schéma suivant : la valeur retourné doit contenir 3 clés: value, dimension et units. Si une clé manque (ou si une autre clé est ajoutée) une erreur est émise. Un <em>template</em> de phénotype est imposé. </p>
    <p> Ici j'ai deux phénotypes possibles (valeurs, grandeur et unité de mesure différentes). On pourrait imaginer contraindre encore plus le retour en demandant le type de données attendue pour la value, la valeur de la dimension et de l'unité de mesure etc.. Ce sont des points techniques mais intéressants.</p>

    <p class="note">On peut imaginer encore beaucoup de choses dans les contraintes à imposer ici. Plus on met de contraintes plus c'est long d'éditer mais plus on peut proposer des tests automatiques pour avertir l'utilisateur en cas de bug. Autant de temps à débugger en moins dans son projet</p>


 

    <h4 id="fonctionnal-feature">Features <em>fonctionnelles</em></h4>

    <p>
        Jusqu’ici on a parlé d’associer aux valeurs remontées par le support génétique d'autres valeurs qui <em>font sens</em>. On fait correspondre des valeurs à des valeurs, on map. Une feature est une simple <em>fonction</em> au sens mathématique qui, à chaque valeur fait correspondre une autre valeur. Pourquoi s’arrêter là ? Pourquoi ne pas donner la possibilité d’associer à chaque valeur d’un support génétique directement une fonction ? En effet, une fonction est <em>une valeur comme les autres</em> (dans une approche <a href="https://en.wikipedia.org/wiki/First-class_function">first-class function</a>), au même titre que 1 ou ‘toto’.
    </p>

    <p>
        Cette possibilité est <strong>extrêmement intéressante</strong> car elle permet de produire des phénotypes qui sont non plus juste des états (une valeur interprétée du support génétique) mais des <strong>comportements</strong>. 
    </p>

    <p>Reprenons un exemple où notre support génétique est codé sur un gène avec deux allèles A et B, avec \(u(A,B)=1\), soit A dominant et B récessif. On a donc deux valeurs possibles , A ou B, pour ce support. Associons une fonction(une valeur) à chaque allèle dans notre feature que nous appelerons <code>'FeatureA'</code> :</p>
    <ul>
        <li>\(A \mapsto f_A(x,y) \{ \text{return x + y} \} \)</li>
        <li>\(B \mapsto f_B(x,y) \{ \text{return x - y} \} \)</li>
    </ul>

    <p>où \(x\) peut être n'importe quoi (y compris une fonction !) C'est à l'utilisateur de le définir. Attention ici on est pas dans le cas où on va appliquer \(f_A\) quand A s'exprime et renvoyer le résultat. Ici, on <strong>retourne</strong>\(f_A(x)\)</p>

    <p>Par exemple, un extrait de pseudo-code de l'utilisateur dans son projet</p>

    <code class="pseudo-code">
        <pre>
value = evaluate(individu,'FeatureA')
x = value(1,2) // = 3 si A s'exprime, -1 si B s'exprime
        </pre>
    </code>

   <p>Le fait de pouvoir retourner directement des fonctions est une propriété très intéressante et utile au modèle pour créer des phénotypes riches, faits d'états mais aussi de comportements. Cela ouvre énormément de possibilités.</p>

   <h4>Sur les dimensions et unités de mesure</h4>
   <p>
       La bibliothèque embarquera avec elle les dimensions et unités de mesure répandues (sûrement en utilisant une library tierce). L'utilisateur pourra également définir lui même ses propres grandeurs et unités associées.
   </p>

   <h4>Sur le temps</h4>
   <p>
       Pour le moment nous n'avons pas parlé du temps, les features produisent des phénotypes statiques pour un matériel génétique donné. <strong>Le temps sera accessible par défaut à chaque feature en argument</strong> pour permettre à l'utilisateur de produire des évaluations dynamiques du phénotype. En effet, pour faire évoluer un système (un individu par exemple) il faut une notion de temps d'une manière ou d'une autre. L'horloge interne d'un invidu (à sa naissance) \(t_0\) sera accessible à chaque individu.
   </p>

   <p>
       Il faudra définir un temps bien caractérisé (unité) qui sera utilisable par toutes les features et défini/initialisé à l'échelle du projet comme une variable globale. A refléchir...
   </p>





    <h4 id="features-coupling">Créer des features à partir de features, à partir de features, à...</h4>

    <p>Une feature peut prendre en entrée (en argument)</p>
    <ul>
        <li> <strong> un et un seul support génétique</strong></li>
        <li>un support génétique, une ou plusieurs features, voir <a href="#general-model">ce schéma</a></li>
    </ul>

    <p>
        Voici une notion un peu plus avancée du modèle mais qui permet, je crois, de lui donner beaucoup d’intérêt et de puissance.
    </p>
    <p>
        Pour le moment, on peut définir des features, chacune interprétant l'expression d'un support génétique. C’est cool déjà, mais c’est embêtant car toutes ces features sont sagement <em>les unes à coté des autres, à s’ignorer mutuellement et à vivre leur vie</em> . En soi on peut laisser au soin de l’utilisateur de combiner les effets des features pour fabriquer de nouveaux mécanismes lui-même. Mais on peut aussi intégrer nativement cette possibilité dans notre bibliothèque, et créer de manière récursive et <em>infinie</em> des features à partir d’autres features.
    </p>
    <p>
        Créer un réseau de features pour fabriquer des nouvelles features, pour fabriquer des nouvelles features. Ainsi on peut créer du couplage entre supports génétiques et produire des phénotypes beaucoup plus intéressants. Voyons cela plus en détails, à partir d’un exemple concret.
    </p>

    <img src="./img/features-coupling-time" alt="" style="width: 100%;">

    <p>
        Sur le schéma ci dessus on a un cas de couplage qui fait intervenir le temps. On a une feature qui nous renvoie la taille de l'individu. Cette taille est fonction du temps, cette donnée est accessible en lecture et donnée par le système à toutes les features. Pour évaluer la taille d'un individu il faut évaluer cette feature. Cette feature est couplée à trois autres features : taille min qui donne une taille min encodée sur son support génétique, taille max idem, et taux de croissance.
    </p>

    <p>
        On a donc une feature taille qui pour être évaluée doit avant évaluer tout ses dépendances (on pourra optimiser cette étape, avec un cache et n'évaluer que si l'évaluation de cette feature a changé, notamment grâce à la gestion des mutations). Avec cette définition, quand j'évaluerai taille j'aurai toujours la bonne valeur, même si taux de croissance mute entre deux évaluations.
    </p>

    <p>
        Voici comment on peut coupler les features entre elles pour produire des nouvelles features, et créer autant de complexité qu'on le souhaite. On peut imaginer ici reproduire des features à la manière de composants informatiques, qui viennent éteindre et allumer l'expression d'autres features.
    </p>

    <p>
        Comme on peut le voir on se sert des valeurs générées précedemment par la feature pour retourner la taille. On accède à LOG, l'historique, et on récupère la dernière entrée avec <code>popValue()</code>  et <code>popTime()</code>. Le LOG est une <a href="https://fr.wikipedia.org/wiki/Pile_(informatique)">pile</a>, c'est une structure de données "Last In First Out".  Il est temps d'aborder un point important sur l'évaluation et les états d'un individu.
    </p>

    <h4 id="immutability">Les états et l'évaluation</h4>

    <p>C'est sans doute l'un des points les plus importants dans le design de ce modèle. Le phénotype d'un individu, le global (l'aggrégation de tous les phénotypes produits par les features) et le local (produit par une feature) <strong>est un état immutable</strong>. Le phénotype est lui aussi <strong>une valeur</strong>. </p>
        <p>
            Quand on veut connaître la taille d'un invidivu par exemple, on ne vient pas écraser ou mettre à jour la taille qu'il avait avant. On évalue la feature et elle nous renvoie une valeur. Cette valeur ne change pas dans le temps, la taille d'un individu ne change pas dans le temps : quand on la mesure on obtient des valeurs différentes à chaque instant. Quand on mesurait notre taille enfant en mettant une petite marque sur le mur, on n'effacait pas la marque d'avant pour mettre la suivante, plus haute. On faisait une nouvelle marque ! Il sera toujours vrai, qu'à un moment donné vous étiez plus petit qu'aujourd'hui. En ce sens, votre taille n'est pas un état mutable. Vous avez plutot effectué une mesure, et au cours du temps, cette mesure a renvoyé des valeurs différentes.
        </p>

        <p>
            C'est la même chose pour notre phénotype. Le phénotype n'a pas à être un état mutable, qu'on viendrait mettre à jour à chaque pas de temps. Non ! Le phénotype est <strong>un instantanné de l'évaluation de toutes les features d'un individu</strong>. Si je veux connaitre la taille d'un individu, j'évalue sa feature taille et elle me renvoie une valeur. Cette valeur dépend du temps (mesurer deux fois la taille au même instant produit la même valeur). 
        </p>
        <p>
            Chaque feature, comme dans l'exemple ci-dessus, conserve un journal, un historique (un log) de toutes les valeurs qu'elle a produite quand on l'a évaluée. Ainsi, j'accède naturellement à l'histoire complète de mon individu. Je ne remplace pas la valeur taille, j'en créee un nouvelle à chaque fois que je fais la mesure. Ce log permet de calculer le présent en fonction du passé. Le présent (ou le futur) ne vient pas écraser le passé. 
        </p>

        <p>
            Il est hors de question pour notre feature d'avoir un état pour ces raisons. Une feature est une fonction qui produit des valeurs (en appelant d'autres features au besoin).
        </p>
        <p>
            Dans ce modèle, l'état mutable est justement le support génétique, sujet à des <em>mutations</em>. Dans toute cette biliothèque le seul état mutable est le génome (exception faite de l'épigénétique, qui est d'ailleurs peut-être une mauvaise idée, ça peut être utile mais déconseillée à n'utiliser que dans des cas où c'est nécessaire)
        </p>

        <p>
            Pour résumer, <strong>le phénotype d'un individu est une valeur</strong> produite par les features à un instant donné. Les features n'ont pas d'état mutable (elles ne maintiennent pas un état, elle ne font pas d'assignement). Elles peuvent produire une valeur à partir d'une valeur produite dans le passé, c'est bien normal. Mais <strong>elles ne peuvent pas modifier le passé</strong>, elles peuvent juste y accéder en lecture, <strong>ce sont des faits</strong>. Chaque nouvelle entrée s'ajoute aux précédentes sans les modifier, aucune entrée ne peut pas être modifiée ou supprimée par la feature.  
        </p>
      

    <h5>Quelques exemples</h5>

    <h5>Feature présente mais cachée</h5>
   

    <p>Prenons l'exemple d'un d'un serpent. Il possède des gènes pour coder un pied, et d'autres gènes pour lui donner forme (nombre de doigts, pied palmé etc...). Dans la plupart du temps (phénotype dominant à l'état sauvage) il ne s'exprime pas. Dans son phénotype on ne trouve aucune expression du pied, et des traits propres au pied.  </p>
    <img src="./img/coupling-feature-on-off-ex2" style="width: 100%;" alt="">
    <p> Si une feature renvoie une valeur vide \(\{\}\) (ou une valeur définie par le système du genre 'required') toutes les features qui en dépendent ne peuvent plus s'exprimer et renvoient une valeur vide à leur tour. Le résultat est que le génome concerné ne s'exprime pas et que le phénotype n'est pas observé </p>
<p>Ces gènes ne s'activent que si l'allèle A s'exprime, comme ci-dessous. Si c'est le cas l'intégralité du génome du pied s'exprime et on trouve un phénotype</p>
    <img src="./img/coupling-feature-on-off-ex1" style="width: 100%;" alt="">
    <p>L'activation en cascade de toutes les features dépendantes est alors automatique dans le modèle.</p>


    <h5>Les features sont des API</h5>

<p>Les features sont des fonctions pures qui prennent en entrée une valeur et retourne une valeur. En ce sens tout leur comportement est défini par les arguments en entrée. Aussi on pourra fournir pour chacune d'entre elle, en fonction des contraintes qu'on imposera, une documentation des arguments acceptés et des sorties produites. Elles seront alors facilement testables de manière unitaire (isolées). Elles ont donc une <a href="https://fr.wikipedia.org/wiki/Interface_de_programmation">API</a> et il n'est pas utile de regarder dans le détail de leur code source pour s'en servir. La documentation pourra nous dire ce que chaque feature fait, de quelle feature elle dépend etc.. Et une fois définie (ou récupérée) on pourra l'utiliser comme une boîte noire dans notre projet, sans avoir à soulever le capot. </p>

    <h5>Une feature "Groupe de features"</h5>

    <p>
        Comme on l’a vu, on peut coupler des features pour faire des nouvelles features. Cela crée des dépendances entres features. Pour simplifier la vie de l’utilisateur on pourrait rajouter quelque chose de simple : faire des paquets de features. Au lieu d’évaluer chacune d’entre elles on en évalue qu’une qui renverra l ‘évaluation de toutes les features dont elle dépend. C’est juste une fonctionnalité pour faciliter la vie de l’utilisateur et simplifier l’usage de la bibliothèque.
    </p>
    <p>
        Par exemple, je crée tout un ensemble de features relatives à la possibilité de voler d’un animal : absence/présence d’ailes, taille des ailes, types ailes (a plume, mammifère), forme des ailes, couleurs des plumes, bruit que fond les ailes, vitesse en vol, vitesse de pointe etc... Toutes ces features sont reliées les unes aux autres. Par exemple s’il n’y a pas de plumes, il n'y a pas de couleur des plumes. Au lieu d’avoir à interroger manuellement chacune de ces features je pourrais créer une « méta-feature » qui s’appelle « vol » par exemple. Elle les comprendrait toutes. Cela donnerait une paquet prêt à l’emploi ds n’importe quel projet où je veux voir ce trait phénotypique exister. Ainsi dans le code au lieu d’avoir un truc du genre :
    </p>

    <code class="pseudo-code">
        <pre>
hasPlumage = evaluate(individu, ‘hasPlumage’)
plumageColors = evaluate(individu, ‘plumageColors’)
wingsSize = evaluate(individu, ‘wingsSize’)
etc.
//Then do logic
...
//A la place on aurait
vol = evaluate(individu, ‘vol’)
//vol contiendrait toutes les données :
//par ex : vol = {
    hasWings : true,
    hasPlumage : false,
    plumageColor : undefined,
    wingSize : {
        value : 52,
        dimension: 'length'
        unit : ‘cm’
    },
    speed : {
        value : 60 ,
        dimension: 'speed'
        unit : ‘km/h’
    }
    //Etc...
} 
        </pre>
</code>

<p>
    En ce sens, le phénotype global d'un individu (l'ensemble de ses traits), est la méta feature la plus globale
</p>
<code class="pseudo-code">
    <pre>
//evalue toutes les features d'un coup
phenotype = evaluate(individu)
    </pre>
</code>
 

<h4>Pour résumer :</h4>

<p>Pour créer une feature l'utilisateur doit</p>
<ul>
    <li>Lui donner un nom</li>
    <li>Lui donner ses sources (un support génétique, une ou plusieurs features). Ca définit ce qu'elle prend en entrée</li>
    <li>Si une source est un support génétique il doit associer une valeur à chaque allèle retournée par le support. Si la source est une feature il n'a rien à faire (l'entrée est définie par la valeur retournée par cette feature)</li>
    <li>Définir ce que la feature retourne (soit une stratégie, soit il implémente sa propre fonction)</li>
    <li>Si la valeur retournée est définie par une fonction écrite par l'utilisateur il doit en plus renseigner le schéma de la réponse(la structure des données renvoyée)</li>
</ul>

    <h3 id="espèces">Espèce</h3>


    <p>
        Une espèce est définie par un ensemble de features designées préalablement. Une feature peut être utilisée pour plusieurs espèces. A cela s’ajouteront des paramètres (à définir), des caractères irréductibles (non codés par du support génétique). Ces « méta paramètres »seront utiles pour le modèle (pour simplifier des choses).
    </p>




    <p class="question">
        Tout ce modèle est très «génétique centré», est ce qu’on pourrait imaginer des caractères non réductibles à l’expression du génome, à définir directement sur l’espece (des méta caractères, épigénétique...)?
    </p>


    <h4>Paramètres</h4>

    <table>
        <thead>
            <tr>
                <th colspan="4">Feature</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Paramètre</th>
                <th>Description</th>
                 <th>Type</th>
                  <th>Contraintes</th>
            </tr>
        <tr>
                <td>Nom</td>
                <td>Un nom donné à l'espece</td>
                <td>String</td>
                 <td>Unique</td>
            </tr>
            <tr>
                <td>Features (nombre \(n_f\))</td>
                <td>Liste de features caractérisant l'espece. Chaque feature sélectionnée embarque avec elle son suppport génétique et ses dépendances</td>
                <td>Liste Features</td>
                 <td>Aucune</td>
            </tr>
            <tr>
                <td>Nombre de paires de chromosomes \(n_p\)</td>
                <td>Toutes les especes sont diploides mais le nombre de paires de chromosomes peut être défini pour chaque espece (brassage)</td>
                <td>Integer</td>
                 <td>Au moins un gène par chromosome, \(n_p \leq \sum_{i=1}^{n_f} N_i\)</td>
            </tr>
            <tr>
                <td>Placement des gènes sur les chromosomes</td>
                <td>Quel gène va sur quel chromosome. Editeur permet de placer automatiquement, possibilité de le faire à la main, avec un éditeur Drag&Drop graphique.</td>
                <td>-</td>
                 <td>-</td>
            </tr>
            <tr>
                <td>Gènes non codant</td>
                <td>En plus des gènes codants, générer des séquences génétiques non codantes aléatoires (%, disposition etc..)</td>
                <td>-</td>
                 <td>-</td>
            </tr>
            <tr>
                <td>Type de reproduction</td>
                <td>Autofertilisation, clonage, reproduction sexuée</td>
                <td>String</td>
                 <td>Appartenir aux types de reproduction définie par le système</td>
            </tr>
            <tr>
                <td>Peut se reproduire avec d'autres especes?</td>
                <td class="question">
                    Sous quelles conditions, comment ça marcherait ? Je ne souhaite pas que la notion d’espèce soit trop « cloisonnante », mais plutôt comme c’est en vrai, un concept aux contours évoluant avec le temps, « un flux ». C’est pratique pour programmer. En soi le modèle est piloté par des données donc tout est imaginable. On voudrait bien que des individus d’espèces différentes se croisent ! Sous quelles conditions (proximité génétique : valeur seuil de % génome commun ?) ? Quel génome résultant (chaque individu apporte tout ou une partie de ses features) ? Là ton regard pour être très précieux sur ces aspects pour imaginer des mécanismes.
                </td>
                <td>{booléan, proximité : Float}</td>
                 <td>??</td>
            </tr>
            <tr>
                <td>Autoriser Mutations</td>
                <td>
                    Choisir si le génome de l'espece peut muter
                </td>
                <td>Boolean</td>
                 <td>Aucune</td>
            </tr>

            
        </tbody>
    </table>

    <h3 id="espèces">Population</h3>
    
    <p>
        On pourra définir des choses à l'échelle d'une population quand on utilisera la méthode <code>generatePopulation</code> pour créer une population initiale d'individus appartenant à une espece.
    </p>
    <p class="question">
        Quoi donc imaginer/de quoi aurait on besoin à l'échelle d'une population?
    </p>

    <h2 id="mutations">Mutations</h2>

    <h3>Définition d'une mutation dans le modèle</h3>

    <p>
        Une mutation est une modification rare, accidentelle ou provoquée de l'information génétique dans le génome. Dans le modèle une mutation pourrait être
    </p>
    <ul>
        <li>code génétique d'une allèle : transition vers une autre allèle, vers une allèle mutante ou vers une allèle inerte (code inconnu)</li>
        <li class="question">relation entre deux allèles. Est ce raisonnable ? Dans la vraie vie il peut y avoir une mutation qui rend une allèle jusque la récessive tout d'un coup dominante?</li>
        <li>Apparation d'un nouveau gène codant pour une feature</li>
        <li>Disparition d'un nouveau gène codant pour une feature</li>
        <li>Disparition d'une allèle à la prochaine reproduction (remplacé par une allèle inerte</li>
        <li class="question">Autre idée?</li>
    </ul>
  

    <p>
        Le support génétique peut muter : par exemple un bit pourrait se décaler vers la gauche. Prenons un gène codé sur 8bits qui vaut initialement <code>00000001</code> (correspond à une allèle). Une mutation est déclenchée et un bit se décale) à <code>00000010</code> :

        <ul>
            <li>soit j'ai défini une allèle mutante en amont, pris en compte dans ma feature</li>
            <li>soit je n'ai pas associé de valeur. L'allèle sera évualée à <code>'unknown'</code> ou sera inerte.</li>
        </ul>
    </p>


    <h3>Rôle des gènes non codants</h3>

    <p>
        On peut imaginer introduire des gènes non codants sur les chromosomes. Par exemple :
        $$...\color{grey}0000000\color{red}10000100\color{blue}11011110\color{grey}11001100... $$ 

    <ul>
        <li><span style="color:red;">Gène codant 1 allèle A </span></li>
        <li><span style="color:blue;">Gène codant 2 allèle B </span></li>
        <li><span style="color:grey;">Gène non codant </span></li>
    </ul>



</p>

<p>
    Maintenant on peut imaginer une forme de mutation où chaque bit se décale de 1 pas sur la gauche. Le résultat serait cette séquence (me suis peut être trompé c’est chiant à faire)
</p>

$$...\color{grey}0000001\color{red}00010011\color{blue}01111011\color{grey}10011001... $$ 
<ul>
    <li><span style="color:red;">Gène codant 1 allèle C (par exemple) </span></li>
    <li><span style="color:blue;">Gène codant 2 allèle inconnu (par exemple) </span></li>
    <li><span style="color:grey;">Gène non codant </span></li>
</ul>
On pourrait ainsi donner naturellement un rôle sympa aux séquences non codantes. Après je te laisse imaginer toutes les opérations cools de mutation qu’on peut faire par des opérations très simples sur les bits.
    </p>


    <p>
        Si l'on souhaite faire une simulation plus bas niveau seulement de brassage génétique et de mutations, en analysant le génome d'un individu sans lui donner du sens, on pourrait remplir leur génome que du matériel non codant. Et appliquer des mutations dessus à chaque génération.
    </p>

    <h3>Paramètres (à compléter/modifier)</h3>

    <p>
        Les mutations seront designées comme les supports génétiques, features et especes.
    </p>

    <table>
        <thead>
            <tr>
                <th colspan="4">Feature</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Paramètre</th>
                <th>Description</th>
                 <th>Type</th>
                  <th>Contraintes</th>
            </tr>
        <tr>
                <td>Nom</td>
                <td>Un nom donné à la mutation</td>
                <td>String</td>
                 <td>Unique</td>
            </tr>      
            <tr>
                <td>Cible</td>
                <td>Qui vise-t-elle, Liste de support génétique, Chromosome entier</td>
                <td>Support génétique (Liste de gènes) ou Gène</td>
                 <td>Au moins 1 gène visé</td>
            </tr>   
            <tr>
                <td>Action</td>
                <td>Que fait elle sur sa cible</td>
                <td>Proposer des actions : décalage, substitution(nombre de bits concernés), aléatoire, éteindre/allumer (en faisant muter vers une allèle du système défini comme 'unknown')  etc..</td>
                <td></td>
            </tr> 
            <tr>
                <td>Déclenchement</td>
                <td>Proposer des déclenchements automatiques</td>
                <td>Chaque reproduction, aléatoire, fréquence etc...</td>
                <td></td>
            </tr> 
            <tr>
                <td>Agressivité</td>
                <td>Permettre à la cible de résister ou non à la mutation. On définit un nombre de 0 à 100. On jette un dé, si le résultat est en dessus de ce nombre la mutation n'a pas lieu.</td>
                <td>Integer</td>
                <td>Entre 0 et 100 (arbitraire)</td>
            </tr>

        </tbody>
    </table>

    <p>
        Chaque mutation définit pourra être déclenchée automatiquement si elle a été configurée ainsi. Sinon l'utilisateur pourra toujours la déclencher manuellement quand il veut, en fonction des conditions de sa propre simulation(s'il simule un environnement par exemple), du genre
    </p>

    <code class="pseudo-code">
        <pre>
    //Déclenche manuellement une mutation
    mutation = triggerMutation('nomMutation')
    //Tous les individus concernés verront leur génome muter
        </pre>
    </code>
     
    <p>
        Chaque mutation sera loguée par le système.
    </p>

    <h3 id="epigenetique">Épigénétique</h3>

    <p>
        On pourrait introduire ici une notion  "épigénétique", avec des caractères héréditaires non encodés dans le génome sous la forme très simple d’un état transmissible (un ensemble de clé/valeurs) de génération en génération. Cet état mutable viendrait s'ajouter à l'état "génome" d'un individu.
    </p>
    <p>
        Cet état est accessible en écriture/lecture à des features spécifiques. Comme montré sur le schéma, une feature qui utiliserait cet état interne devrait le déclarer. En effet, on fait ici une exception à la règle d'or de notre design, que <a href="#immutability">les features sont des fonctions pures</a>. Une feature qui utiliserait l'état "épigénétique" cesserait d'être pure, elle produirait un effet de bord et changerait l'état du monde. Ce qui provoque des couplages indésirés entre features.
    </p>
    <p class="question">
        L'état épigénetique serait simplement une collection de clé:valeur mutables, et transmissible à la descendance. Quelles contraintes à mettre dessus ? Dans le cas d'une reproduction sexuée comment l'épigénétique de 2 parents se combinent pour être transmis ? Concaténation des clefs:valeurs? Est-ce vraiment une bonne idée (j'ai des doutes) ?s
    </p>


    <h2 id="analyse">Analyse</h2>

    <p>
        Si l'on souhaite utiliser le modèle pour faire des simulations et s'amuser à faire de la démographie, on aura naturellement accès à toute l'histoire de notre simulation
    </p>
    <ul>
        <li>Chaque feature log toutes les valeurs qu'elle a produit</li>
        <li>A partir de ces logs on peut reconstruire l'histoire du phénotype au cours du temps</li>
        <li>Chaque support génétique log les mutations qu'il a subi et chaque mutation est logué par le système quand elle est déclenchée</li>
        <li>Chaque individu généré disposera de ces logs et la simulation gardera en mémoire sa date de naissance et de mort</li>
    </ul>

    <h2 id="engine">Moteur : reproduction et transmission du génome</h2>

    <h3>Autofertilisation</h3>
    <h3>Clonage</h3>
    <h3>Reproduction Sexuée</h3>
    <h3>Reproduction entre espèces</h3>

    <h2>Modèle reproduction</h2>
    <h3>Meiose</h3>
    <h3>Cross-over</h3>
    <h3>Mitose</h3>


    <h2>Génération d'une documentation interactive automatique</h2>

    <p>Générer une documentation automatiquement décrivant l'API de chaque Feature dans un projet donné. Cette documentation aidera grandement l'utilisateur a desiger ses modèles de données et aussi à les utiliser dans son propre programme.</p>


    <h2>Usage de la bibliothèque (dans les grandes lignes)</h2>
    <p>La bibliothèque sera open-source (évidemment). Le code sera accessible depuis un dépot public. Le code source sera découpé en au moins deux composants:</p>
    <ul>
        <li>code source moteur de la lib (tout ce qui fera tourner le modèle)</li>
        <li>code source des éditeurs, generateur doc, bac à sable</li>
    </ul>
    <p>On pourra imaginer à terme de faire des éditeurs et du bac à sable une web app: éditeur en ligne, création d'une store où les gens peuvent partager leur design et les télécharger (création d'une communauté). Chaque design aura sa doc.</p>

    <p>En tant qu'utilisateur je veux intégrer cette library pour mon projet :</p>
    <ul>
        <li>Je l'installe (avec ses dépendances) dans mon projet (surement via npm ou yarn). J'importe seulement le moteur dans mon projet</li>
        <li>Soit:
            <ul>
                <li>j'ai envie de créer mes propres design ou éditer design existants, je lance les éditeurs et je travaille dessus. Quand je suis satisfait, que j'ai testé dans le bac à sable j'exporte les données (sous format d'un fichier). Les données comprenent: les supports génétiques, les features, les especes, les mutations etc...</li>
                <li>j'ai pas envie d'en faire moi même, d'autres gens en ont peut etre fait des mieux qui me correspondent ou pourraient me servir de base. Je récupère un design de quelqu'un (un fichier) (téléchargable en ligne sur le store), je l'importe, je l'édide et je l'exporte.</li>
            </ul>
        </li>
        <li>J'importe mes fichiers de design dans mon projet</li>
        <li>Je fabrique surement un fichier de configuration global demandé par la bibliothèque pour initialiser des choses (sécurité, gestion du temps, gestion des erreurs, generation pop, blabblabla...)</li>
        <li>J'utilise le tout pour fabriquer mon programme !</li>
    </ul>

    <p>Voici un pseudo code de l'utilisation de la bibliothèque (juste pour donner une idée)</p>


<code class="pseudo-code">
        <pre>
 import * as glib from "moteur"

 //Je crée une population initiale  de 50 individus, 
 //de l'espece 'espece#1' que j'ai designé
 const population = glib.generatePopulation('espece#1', 50)
 ...
 //Mon programme arrive à un point
 //où je veux déclencher une mutation designée
 const result = glib.triggerMutation('nomMutation') 
 ...
 //Deux individus se reproduisent et donnent une descendance de 10 individus:
 const offspings = glib.reproduce(individu1,individu2, 10)
 ...
 //Une fleur s'autoféconde pour fabriquer un nombre aléatoire de descendants
 const flowers = glib.reproduce(flower, random(10,100))
 ...
 //Deux individus se reproduisent, le nombre de descendant 
 //est borné par une feature 'capaciteGestation'
 const offspings = glib.reproduce(individu1,individu2, 
 random(1, get_phenotype(individu2,'capaciteGestation')))
 ...
 const killed = glib.kill(population)
 ...
//j'ai déjà ma propre structure de données/objet
//Fish avec son comportement
const fish = new Fish('toto')
console.log(fish) // = {toto:'foo'}
//je veux qu'il puisse se reproduire, le rendre
//genetique
fish = glib.setSpecie(fish, 'espece#1')
//fish dispose maintenant de toutes les features
//de l'espce#1 et peut se reproduire
const babyFish = glib.reproduce({fish, args: {bar}},fish2)
//babyFish a conservé tout ce dont il hérite
//de sa structure originelle
console.log(babyFish) // = {toto:'bar', phenotype: {....}} 

        </pre>
    </code>

    <h2>Exemples : reproduction de cas connus</h2>

    <h3>Lapins</h3>
    <h3>Snapdragons (dominance incomplète)</h3>
    <h3>Groupe sanguin chez l'Homme (codominance)</h3>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>