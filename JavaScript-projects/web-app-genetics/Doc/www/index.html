<!doctype html>

<html lang="fr">
<head>
  <meta charset="utf-8">

  <title>The HTML5 Herald</title>
  <meta name="description" content="projet génétique doc">
  <meta name="author" content="Paul Schuhmacher">

  <link rel="stylesheet" href="./style.css">

</head>

<body>

    <h1 id="documentation--modèle-génétique--démographique" style="text-align: center;">Modèle génétique/démographique : Design général</h1>
    <p>22/02/2021<br>
    version 1</p>
    <h2 id="préambule">Introduction</h2>
    <h2 id="ce-quon-fabrique">Ce qu’on fabrique</h2>
    <p>Construire une bibliothèque que n’importe qui peut installer et utiliser dans ses propres projets informatiques. Cette bibliothèque est constituée d’un moteur (un ensemble de fonctions implémentant le modèle) ainsi que de données (avec un format bien défini) exportables et importables. Ainsi, les utilisateurs pourront partager leurs données entre eux (design du génome, des traits phénotypiques et des espèces) et une communauté <em>pourrait</em> se former construisant petit à petit des designs de plus en plus élaborés. L’idée c’est qu’on pourra construire à partir de ce qu’on a construit.</p>
    <p>Pour permettre cela tout en étant <em>user-friendly</em> des éditeurs avec interface graphique seront développés :</p>
    <ul>
    <li>Un éditeur de <a href="#support-g%C3%A9n%C3%A9tique">support génétique</a></li>
    <li>Un éditeur de <a href="#features">traits phénotypiques</a></li>
    <li>Un éditeur d’<a href="#esp%C3%A8ces">espèces</a></li>
    <li>Un bac à sable pour tester et explorer rapidement ses designs</li>
    <li>Un générateur de documentation des allèles et features de chaque espèce dans lequel il sera facile de chercher (nom, données retournées par une feature etc...)</li>
    </ul>
    <p>Les 3 éditeurs permettront d’éditer, importer, exporter, dupliquer, supprimer, ces 3 type de données facilement. Ces données seront ensuite importées dans le projet informatique de l’utilisateur et celui-ci, après import du moteur, pourra faire tourner le modèle dans le but qu’il s’est fixé.</p>
    <h2 id="objectifs">Objectifs</h2>
    <p>S’amuser. Fournir un moteur permettant de simuler des entités (biologiques ou non) possédant des caractéristiques (traits phénotypiques) <strong>interprétables par l’utilisateur</strong>. Ces caractéristiques sont le résultat de l’évaluation d’un support génétique (principalement). Les entités pourront se reproduire et transmettre à leur descendance une part de leur génome pour créer de l’hérédité, de la filiation (et de l’histoire). Ce génome pourra également être soumis à des mutations et évoluer. L’utilisateur pourra alors facilement simuler de la sélection et des populations au cours du temps dans son propre projet. Les espèces pourront muter, les populations évoluer etc. En somme un gros bac à sable. Ce modèle pourrait avoir des ambitions plus générales. Car s’il vise principalement à simuler <em>de la vie</em>, le moteur pourrait être appliqué à d’autres <em>objets</em>. On peut penser par exemple à faire une filiation de langues (en utilisant des méthodes de <a href="https://fr.wikipedia.org/wiki/Philologie">philologie comparée</a> comme a pu le faire (sérieusement) Tolkien : utiliser des règles spécifiques de mutation qui permette de passer d’un mot ancêtre à un mot descendant et vice versa). En fait tout ce qui est sujet à itérations successives, tout objet qui« produit du nouveau a partir de lui même » pourrait être simulé.</p>
    <h2 id="contraintes">Contraintes</h2>
    <p>La contrainte forte du modèle c’est qu’il faut définir à l’avance des traits phénotypiques auxquels l’utilisateur pourra donner <strong>du sens</strong>. J’insiste là dessus car le but est de pouvoir <strong>interpréter fonctionnellement le phénotype pour prendre des décisions.</strong> Ce que j’entends par là c’est que si une espèce possède un trait phénotypique qui renvoie la valeur ‘foo’ il faut que cette valeur <strong>puisse</strong> (pas nécessairement) avoir un sens pour l’utilisateur dans son programme. En ce sens, les traits phénotypiques doivent être définis dès le départ et le réservoir de phénotypes possibles doit pouvoir être contrôlé.</p>
    <h2 id="composants-à-développer">Composants à développer</h2>
    <p><img src="./img/composants.png" alt="Composants"><br>
    Le projet se compose des composants suivants à concevoir et développer :</p>
    <ul>
    <li>Les structures de données :
    <ul>
    <li>Support génétique</li>
    <li>Feature (traits phénotypiques)</li>
    <li>Espèce</li>
    </ul>
    </li>
    <li>Les éditeurs graphiques (web) pour les éditeurs de données:</li>
    <li>Un bac à sable pour aider à prototyper et tester ses designs</li>
    <li>Le moteur (toutes les fonctions, dépendances qui implémentent le modèle)</li>
    </ul>
    <p>Les structures de données seront complexes et un éditeur graphique pour les manipuler sera (quasi) indispensable. Ces éditeurs permettront d’importer et d’exporter les données facilement, de les éditer, dupliquer, supprimer. Le modèle est <em>piloté par les données</em>, ces structures sont capitales et doivent être manipulées et définies de manière rigoureuses.</p>
    <h2 id="aperçu-général-du-modèle-génétique--du-génome-au-phénotype">Aperçu général du modèle génétique : du génome au phénotype</h2>
    <p>L’utilisateur de la bibliothèque pourra faire évoluer des populations d’individus possédant un phénotype, ou un ensemble de traits observables et mesurables. L’utilisateur pourra évaluer les traits de chaque individu et leur appliquer le traitement qu’il souhaite. Ces traits seront l’expression d’un génome <strong>diploïde</strong> porté par chaque individu, transmissible par reproduction ou clonage de génération en génération.</p>
    <p>Le <em>support génétique</em> (encodé en binaire) lorsqu’il est évalué produit une valeur. Cette valeur est ensuite interprétée par une <em>feature</em> qui produit à son tour une valeur auquel l’utilisateur donne une unité de mesure. L’expression de la feature est alors remontée dans le phénotype, le résultat de l’évaluation de toutes les <em>features</em> de l’individu. La valeur en sortie d’une feature peut servir d’entrée à une autre <em>feature</em> et ainsi de suite. Ainsi, le phénotype forme une collection de couples clé:{valeur, unité} produite par l’évaluation d'un réseau de features (possiblement) interdépendantes, fondé sur un support génétique.  </p>


    <img id="general-model" class="modele-img" src="./img/modele-general" alt="Modèle général">


    <p>Lors de la reproduction ou du clonage, le support génétique est transmis à l’aide de mécanismes connus de la biologie (mais nécessairement simplifiés) : mitose, méiose.</p>
    <p>Le support génétique pourra être exposé à des mutations. Chaque individu disposera en plus de son support génétique d’un état interne modélisant les effets <em>épigénétiques</em>. Cet état supplémentaire, non encodé dans le génome, pourra modéliser la transmission de caractères acquis.</p>
    <h2 id="notations">Notations</h2>
    <ul>
        <li> \(a-B\) : allèles a et B sur le même locus d’une paire de chromosomes analogues. a est récessif et B est dominant</li>
        <li> \((a-B)(a-c)(B-B)\) : ensemble de couples d'allèles sur 3 gènes d’une paire de chromosomes analogues. L'ordre des couples n'a pas d'importance</li>
    </ul>
   
    <h2 id="les-modèles-de-données">Les modèles de données</h2>
    <h3 id="support-génétique">Support génétique</h3>
    <p>Un support génétique est une séquence en binaire (de 0 et de 1) qui peut être évalué pour <strong>produire des valeurs</strong> entières.</p>
    <table>
        <thead>
            <tr>
                <th colspan="4">Support génétique</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Paramètre</th>
                <th>Description</th>
                 <th>Type</th>
                  <th>Contraintes</th>
            </tr>
        <tr>
                <td>Nom</td>
                <td>Un nom donné au support</td>
                <td>String</td>
                 <td>Unique</td>
            </tr>
            <tr>
                <td>Nombre de gènes <code>N</code></td>
                <td>Nombre de gènes contribuant à la valeur du support</td>
                 <td>Integer</td>
                   <td>\( N \ge 1\)</td>
            </tr>
              <tr>
                <td>Nombre de bits <code>n</code></td>
                <td>Nombre de bits sur lequel est encodé chaque gène du support : l’utilisateur pourra choisir d’encoder des gènes sur des structures allant de 1 à 8 bits (limite arbitraire). Ce paramètre défini par défaut le nombre de variations d’un même gène (allèles) accessibles. Par exemple, sur un support à 2 bits on a 4 valeurs possibles : 00 (0), 01 (1), 10 (2) et 11 (3). On a donc, au maximum 4 allèles pour ce gène dans notre « réservoir ». Sur 8 bits on a 256 valeurs possibles, donc 256 allèles possibles pour un même gène. La structure binaire est suffisante pour créer assez de variations (pas besoin de 4 caractères AGCT). </td>
                 <td>Integer</td>
                  <td>\( 1 \le n \le 8 \)</td>
            </tr>
                      <tr>
                <td>Allèles disponibles <code>n<sub>a</sub></code></td>
                <td>Le réservoir d'allèles disponibles est par définition définie par le nombre de bits sur lequel est encodé un gène. L’utilisateur pourra décider de n’utiliser qu'un sous-ensemble de ce réservoir s’il le souhaite. <strong>Une allèle est une valeur</strong> possible d'un gène. Elle peut donc muter dans l'espace défini par le gène vers une autre valeur. </td>
                 <td>(Integer...)</td>
                  <td>\( 1 \le n_a \le N^{2} \)</td>
            </tr>
             <tr>
                <td>Relations entre allèles <code>U</code></td>
                <td>Tableau de coefficients dont chaque valeur permet de calculer la contribution de chacune des 2 allèles du même gène à l’évaluation du support génétique. L’utilisateur pourra générer ces coefficients de manière aléatoire ou suivant des règles prédéfinies, ou les écrire manuellement (il y a toujours le contrôle total si on le souhaite).</td>
                 <td>[Float]</td>
                  <td>
                  \( n_a(n_a+1)/2\) coefficients nécessaires pour évaluer toutes les combinaisons possibles, voir <a href="#table-genetic-support-summary">ce tableau</a>
                  </td>
            </tr>
        </tbody>
    </table>
    <p>Pour résumer, l’évaluation d’un support génétique (et la production d’une valeur) se fait en évaluant pour chacun de ses gènes la paire d’<a href="https://fr.wikipedia.org/wiki/All%C3%A8le">allèles</a> (une allèle sur chaque <a href="https://fr.wikipedia.org/wiki/Chromosome_homologue">chromosome homologue</a>) correspondante. Les relations entre allèles permettent de calculer la <strong>valeur</strong> du support génétique.</p>


    <h4>Dominat/Récessif, dominance incomplète et codominance</h4>
<p>
    <a href="https://fr.wikipedia.org/wiki/All%C3%A8le#Relations_entre_all%C3%A8les">Plusieurs relations entre allèles</a> existent. Le modèle se propose de modéliser 3 d'entre elles :

</p>


   <ul>
       <li><strong>Dominant/récessif :</strong>  un allèle récessif demande l'homozygotie d'un gène pour pouvoir s'exprimer. Autrement dit, soit \(a-B\) deux allèles du même gène, a est récessif (et B est dominant) si  \(u(a,B)=0\). Ce gène est évalué à \(B\)</li>
       <li><strong> Dominance incomplète :</strong> aucun des allèles qui déterminent le caractère est dominant, les deux s'expriment et le caractère est un mélange des deux contributions. Autrement dit, soit \(a-b\) deux allèles du même gène, a et b ont une dominance incomplète si  \( u(a,b) \in  \left] 0 : 1\right[ \). Ce gène est évalué à {\(A: u(a,b), B: 1-u(a,b)\)}. En ce sens, le modèle Dominant/récessif n'est qu'un cas particulier de dominance incomplète.</li>
       <li><strong>Codominance :</strong>  les deux allèles s'expriment en même temps, et le trait est l'expression conjointe des deux allèles.Autrement dit, soit \(A-B\) deux allèles du même gène, il faut donner au coefficient une valeur distincte pour prendre en compte ce cas. On pose par définition la valeur \(u(A,B)=-1\) pour symboliser ce cas. L'évaluation du gène retourne la valeur \(AB\). Dans ce cas, deux allèles peuvent produire 3 valeurs distinctes : A , B et AB}  </li>
   </ul>

   
<p>
    Voici un tableau résumant les valeurs prises par les coefficients pour chaque type de relation entre allèles, ainsi que le résultat de l'évalution d'un gène \(A-B\). L'évaluation produit un ensemble clé:valeur noté \( \{ A: w_A , B: w_B \} \) où \(A\) est l'identifiant de l'allèle A et \(w_A\) son poids dans l'expression du gène. Si le poids est nul l'allèle n'est pas exprimé, s'il est égal à 1 on écrira \( \{ A: 1 \}  \equiv \{ A\} \equiv A \). S'il n'y qu'un gène on pourra écrire  \( \{ A\} \equiv A \)
</p>
   <table id="table-genetic-support-summary">
    <thead>
        <tr>
            <th colspan="5">Supports génétiques</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Relation</td>
            <td>Valeurs du coefficient</td>
            <td>Evaluation</td>
        </tr>
        <tr>
            <td>Dominant/Récessif</td>
            <td>\(u(A,B) \in \{0 , 1\}\)</td>
            <td>\( A \) ou \( B \) </td> 
        </tr>
        <tr>
            <td>Dominance incomplète</td>
            <td>\(u(A,B) \in \left]0:1\right[\)</td> 
            <td>\( \{ A: u(A,B) , B: 1-u(A,B) \} \)</td>  
        </tr>
        <tr>
            <td>Codominance</td>
            <td>\(u(A,B) = -1\)</td> 
            <td>\( \{ AB: 1 \}\)</td>  
        </tr>
    </tbody>
</table>

<p>
    Pour le moment aucune valeur n'est assignée à chaque allèle, sa valeur est son code binaire (ou son nom qui est un alias pour ce code). La valeur et le sens seront défini au niveau d'une feature.
</p>


    <h4 id="exemple--support-génétique-continu">Exemple 1 :</h4>
    <p>Prenons un support génétique :</p>
    <ul>
    <li>codé sur 3 gènes</li>
    <li>chaque gène est codé sur 2 bits</li>
    <li>Allèles disponibles : toutes, soit
    <ul>
    <li>00 ( A )</li>
    <li>01 ( B )</li>
    <li>10 ( C )</li>
    <li>11 ( D )</li>
    </ul>
    </li>
    </ul>
    <p>Initialisons le tableau des relations entre allèles :</p>
    <div class="center-container">
    <table>
        <tbody>
            <tr>
                <td></td>
                <td>A</td>
                 <td>B</td>
                <td>C</td>
                 <td>D</td>
            </tr>
            <tr>
                <td>A</td>
                <td>1</td>
                 <td>0.3</td>
                <td>0.7</td>
                 <td>1</td>
            </tr>
              <tr>
                <td>B</td>
                <td>-</td>
                 <td>1</td>
                <td>0.2</td>
                 <td>0.4</td>
            </tr>
            <tr>
                <td>C</td>
                <td>-</td>
                 <td>-</td>
                <td>1</td>
                 <td>0.5</td>
            </tr>
             <tr>
                <td>D</td>
                <td>-</td>
                 <td>-</td>
                <td>-</td>
                 <td>1</td>
            </tr>
        </tbody>
    </table>
</div>

<p>On a par définition</p>
    $$u(A,B) = 1 - u(B,A) $$ 
    <p>si A et B ne sont pas codominants. Pour le cas de codominance on a défini une valeur arbitraire</p>
    $$u(A,B) = u(B,A) = -1 $$ 

<p>On peut noter que l'allèle D est récessif vis à vis de A qui est dominant. Dans tous les autres rapports d'allèles nous sommes dans un cas de dominance incomplète. Évaluons à présent un individu qui posséderait un support génétique initialisé comme suit :</p>
$$(a-b)(c-b)(a-d)$$

<p>L’individu est <a href="https://fr.wikipeda.org/wiki/H%C3%A9t%C3%A9rozygote">hétérozygote</a> pour chacun des 3 gènes. L'évaluation du support génétique donne </p>

    $$ v = \{ A:1.3, B:0.9, C:0.8 \}$$
   
<p>On peut voir que si le support génétique est constitué de plusieurs gènes il suffit d'ajouter les contributions de chaque gène.</p>

    <h4>Exemple 2</h4>

    <p>Reprenons le même support génétique :</p>
    <ul>
    <li>codé sur 3 gènes</li>
    <li>chaque gène est codé sur 2 bits</li>
    <li>Allèles disponibles : 3 sur les 4 disponibles, soit
    <ul>
    <li>00 ( A )</li>
    <li>01 ( B )</li>
    <li>10 ( C )</li>
    </ul>
    </li>
    </ul>
    <p>Construisons un autre tableau de relations entre allèles :</p>
    <div class="center-container">
    <table>
        <tbody>
            <tr>
                <td></td>
                <td>A</td>
                 <td>B</td>
                <td>C</td>
            </tr>
            <tr>
                <td>A</td>
                <td>1</td>
                 <td>-1</td>
                <td>1</td>
            </tr>
              <tr>
                <td>B</td>
                <td>-</td>
                 <td>1</td>
                <td>0.5</td>
            </tr>
            <tr>
                <td>C</td>
                <td>-</td>
                 <td>-</td>
                <td>1</td>
            </tr>
        </tbody>
    </table>
</div>

<p> Évaluons à présent un individu qui posséderait un support génétique initialisé comme suit :</p>
$$ (C-B)(A-C)(A-B) $$


<p>L’individu est <a href="https://fr.wikipeda.org/wiki/H%C3%A9t%C3%A9rozygote">hétérozygote</a> pour chacun des 3 gènes. L'évaluation du support génétique donne </p>
$$ v = \{ AB: 1, A:1, B:0.5, C:0.5 \}$$

<p>Les allèles A et B sont codominantes, elles s'expriment donc toutes les deux mais leurs effets ne se combinent pas, elles produisent une nouvelle valeur \(AB\), un nouveau phénotype.</p>

<h3>Sur les allèles</h3>
Un allèle est un code binaire, une variation d'un gène. Son code binaire est son identifiant, qu'on pourra surharger avec un nom. Un allèle peut être déclaré :
<ul>
    <li>Disponible : l'allèle pourra être présent à l'initatialisation d'une population d'individus</li>
    <li>Mutant : non accesible par défaut, seulement par mutation de son code génétique</li>
</ul>
Un allèle pourra muter 
<ul>
    <li>vers un allèle existant (Disponible), équivalent à du brassage génétique</li>
    <li>vers un allèle mutant (Mutant), introduction d'un nouvel allèle dans la population</li>
</ul>
Au niveau de la feature, la valeur de cet allèle (ainsi que son rapport aux autres) peut être
<ul>
    <li>défini à l'avance par l'utilisateur. Ainsi il garde le contrôle complet sur les entrées/sorties au niveau des features </li>
    <li>défini aléatoirement (par une fonction), l'utilisateur perd alors le contrôle sur l'évaluation du génome qui va évoluer de lui même (selon des règles définies à l'avance) </li>
</ul>
Dans le deuxième cas de figure, de l'évolution incontrôlée pourra apparaître car même l'utilisateur ne saura pas à l'avance la valeur que va produire le support génétique. Les deux cas sont intéressants, le contrôle doit être libre pour l'utilisateur. Dans le cas où les valeurs ne seront pas définies à l'avance (et pourront être n'importe quoi), il faudra prévenir l'utilisateur que la valeur que prend en entrée la feature est inconnue ou imprévisible, afin d'être sûr de ne pas casser son code. A charge de l'utilisateur de faire le nécessaire pour l'interpréter (la solution la plus simple consistant à retourner la valeur telle quelle.)
    <h3 id="features">Feature (ou trait, phénotype local)</h3>

    <h4>Définition</h4>

    <p>Une fois définis des supports génétiques on peut commencer à designer le composant à l'étage du dessus : la feature. Une feature est un trait (un phénotype) observable au niveau de l'individu. Jusqu’ici on a seulement parlé de support génétique dont l'évaluation produit des valeurs.  C’est donc à ce niveau qu’on va  <em>donner un sens aux valeurs générées par le support génétique</em>. La feature produit une   <strong>observable</strong> que l'utilisateur va définir. </p>

    <p>L’intérêt de découpler la production de valeur par un support génétique de son interprétation c’est qu'ont peut réutiliser un même support pour plusieurs features (dans différents projets) et redéfinir l'interprétation que l'on fait de sa valeur.</p>
    <p>
        La feature est une fonction qui va prendre en entrée la valeur d'un support génétique, <a href="#eatures-coupling">ou d'une autre features</a>, et retourner un phénotype, c'est à dire, une valeur et (possiblement) une grandeur et une unité de mesure. C'est une fonction au sens mathématique du terme : à chaque valeur de l'ensemble de départ (valeurs du support génétique) elle produira une valeur (ici un couple {valeur, unité}) dans un ensemble d'arrivée (valeurs du phénotype).
    </p>

    <p>
        Le point important c'est qu'une feature <strong>ne possède pas d'état interne</strong>. Elle prend des valeurs en entrée et renvoie des valeurs en sortie. Les même valeurs en entrée produisent les mêmes valeurs en sortie. Elle n'a aucun effet de bord, c'est à dire que lorsqu'elle est évaluée elle ne <em> modifie pas l'état du monde</em> (exception faite des <a href="#epigenetique"> features attachées à l'état épigénétique</a>). En d'autres termes ce sont des <a href="https://fr.wikipedia.org/wiki/Fonction_pure">fonctions pures</a>. L'état d'un individu est complètement encodé dans ses supports génétiques et son épigénetique. L'ensemble des features vient agir comme une fonction qui prend cet état et renvoie un phénotype macroscopique. 
    </p>

    <img src="./img/feature-function.png" alt="">

   <p>Pour définir l'évaluation d'une feature, lui donner sens, nous allons avoir besoin d' </p>

    <ul>
        <li>une valeur : nombre décimal, une chaîne de caractères, un ensemble de clé:valeur, voir même une fonction</li>
        <li>une grandeur: (ex: temps, longueur, grandeur personalisée...) [OPTIONNEL]</li>
        <li>une unité de measure: ‘m/s’, des ‘mols’, des ‘kg’, des ‘grade’, des ‘milipilpoils’ etc.. [OPTIONNEL]</li>
    </ul>
    
    <p>
       L'unité de mesure servira à faire de l'analyse dimensionnelle et valider la cohérence de certaines expressions. Elle pourra servir à faire des conversions automatiques. Par exemple si un phénotype représente une taille, on pourra demander à évaluer cette valeur en 'cm', en 'm' sans avoir besoin de faire la conversion nous même.
    </p>

    <p class="note">
        A noter : l'utilisateur s'il souhaite avoir directement accès à la valeur du support génétique peut le faire, il peut demander à la feature de retourner directement la valeur du support. L'utilisateur pourrait lui donner une valeur (et une dimension, et unité de mesure) dynamiquement durant l'execution de son programme. Par exemple, regardons ce pseudo code d'un utilisateur qui utilise notre bibliothèque dans son projet
    </p>


    <h4>Paramètres</h4>

    <table>
        <thead>
            <tr>
                <th colspan="4">Feature</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Paramètre</th>
                <th>Description</th>
                 <th>Type</th>
                  <th>Contraintes</th>
            </tr>
        <tr>
                <td>Nom</td>
                <td>Un nom donné à la feature</td>
                <td>String</td>
                 <td>Unique</td>
            </tr>
            <tr>
                <td>Source</td>
                <td>D'où proviennent les entrées de la feature</td>
                <td>Support Génétique ou (Features...)</td>
                 <td>Unique si support, MAX(à définir) si features</td>
            </tr>
            <tr>
                <td>Output</td>
                <td>Données en sortie de la feature</td>
                <td>Ensemble {clé:valeurs},<code>Object</code></td>
                 <td>
                     Doit respecter le schéma <code>{valeur: Object, dimension: String, unit: String}</code>. Ajouter peut être une contrainte sur le schéma de <code>value</code>
                   </td>
            </tr>
            <tr>
                <td>Input</td>
                <td>Données en entrée de la feature. <ul>
                    <li>Si support génétique : évaluation du support [entrées possibles définies]</li>
                    <li>Si une ou plusieurs features : concaténation des évaluations des features</li>
                </ul></td>
                <td>Ensemble {clé:valeurs},<code>Object</code></td>
                 <td>

                    <ul>
                        <li> Si source est support : structure passée en entrée doit contenir les clefs appartenant à l'ensemble des allèles définis sur le support</li>

                        <li>Si sources est features : voir contraintes à mettre. Chaque input doit respecter le schéma de données Output de la source. Chaque input doit respecter le schéma <code>{valeur: Object, dimension: String, unit: String}</code>  </li>
                    </ul>
                     
                    
                   </td>
            </tr>
            <tr>
                <td>Log</td>
                <td>Historique de toutes les valeurs générées par la feature. A chaque évaluation, si l'évaluation est différente de la précédente valeur on la log.</td>
                <td>Stack (Last in First Out) { t: {valeur, dimension, unit}}, tableau d'Object</td>
                 <td>
                   Aucune
                   </td>

            </tr>
        </tbody>
    </table>


    <h4>Ecrire une feature</h4>

    Pour qu'une feature fonctionne il faut définir :

    <ul>
        <li>ce qu'elle prend en entrée: quelles données arrivent du support génétique</li>
        <li>ce qu'elle retourne en sortie: quelle transformation j'opère pour produire une valeur "phénotype"</li>
    </ul>

    <p class="comment">Quand j'écris une valeur phénotype c'est assez général, on n'impose rien sur le type de retour d'une feature [a voir en fonction du design général], mais en général on peut faire retourner à une feature ce qu'on veut. Ce sont là plutot des questions techniques, savoir s'il faut fabriquer des types de données à respecter pour assurer une architecture robuste. Ces restrictions viendront au fil de l'eau, par défaut, une feature peut renvoyer n'importe quelle valeur.</p>

    <h4>Mapper les valeurs des allèles</h4>

    <p>La première étape est donc de <em>maper</em> (d'associer) à chaque allèle exprimée du support génétique une valeur. Comme les allèles sont définies au niveau du support génétique on peut facilement proposer une liste de valeurs à maper à l'utilisateur. On peut associer à la valeur de l'allèle n'importe quelle valeur de notre choix</p>
<p>Prenons un exemple de valeur produite par le support génétique encodé sur 3 gènes</p>
$$(c-B)A(A-B) $$
<p>qui est évalué à</p>
    $$ S =\{ AB: 1, A:1, B:0.5, C:0.5 \} $$
    On doit proposer à l'utilisateur d'associer à chaque allèle une valeur. Prenons \(A\), voici les possibilités :

    <ul>
        <li>Associer un entier : \(A \mapsto 1 \)</li>
        <li>Associer un nombre décimal : \(A \mapsto 0.1 \)</li>
        <li>Associer une chaine de caractères : \(A \mapsto \text{'foo'}\)</li>
        <li>Associer un tableau : \(A \mapsto \left[1, \text{'foo'}, 0.5, \left[1, \text{'foo'}, 0.5,  \right]\  \right]\)</li>
        <li>Associer une association clé:valeur : \(A \mapsto \{a: 1, b: \text{'foo'}\}\)</li>
        <li> <a href="#fonctionnal-feature">Associer une fonction</a> : \(A \mapsto f(S)\)</li>
    </ul>

    <p>On pourra évidemment proposer ici de mapper des valeurs de manière automatique (pattern, aléatoire etc..)</p>

    <p>On pourrait imaginer ne pas contraindre l'utilisateur à définir la valeur de chaque allèle. Ainsi, une valeur non mappée aurait une valeur assignée par le système, par exemple <code>unknown</code>.</p>

    <code class="pseudo-code">
        <pre>
x = evaluate(individu, feature) // acceder au phénotype retourné par la feature
//Allèle inconnue (mutation, non définie par l'utilisateur)
if(unknown(x)){
    //Do stuff
    valeur = ....
    // retrouve l'allèle unknown et lui assigne valeur,dimension, unité
    setValue(feature, 'valeur', dimension, unité) 
}
        </pre>
    </code>

    <p>Nous reviendrons sur la possibilité de tomber sur des allèles dont l'évaluation est inconnue dans la section <a href="mutations">mutations</a> </p>

    <h4>Cas d'un support codé sur un gène</h4>

    <p>
        Dans le cas d'un support encodé sur un seul gène, la question ne se pose pas, on retourne la valeur mappé à la valeur qui s'est exprimée.
    </p>

    <h4>Cas d'un support codé sur plusieurs gènes</h4>
    <p>
       Comme dans notre exemple, dans ce cas plusieurs stratégies d'interprétation peuvent être définies par l'utilisateur.
       On peut :
       <ul>
           <li>Renvoyer toutes les valeurs avec leurs poids (information transparente, l'utilisateur en fera quelque chose soit dans une feature à l'étage supérieur, soit directement dans son projet)</li>
           <li>Filtrer : ne renvoyer qu'une valeur, envoyer des valeurs dont le poids normalisé respecte une condition</li>
       </ul>
    </p>

    <p>On peut proposer des stratégies de map au lieu de map indivduellement chaque allèle.</p>
   
    <h5>Map Combinaison linéaire</h5>

    <p> <strong>Si et seulement si l'utilisateur map chacune des allèles à un nombre (entier ou décimal) </strong>on peut proposer à l'utilisateur d'en faire un combinaison linéaire se servant du poids caractérisant la contribution de chaque allèle. Par exemple ici, définissons cette association : </p>
    <ul>
        <li>\(AB \mapsto 1 \)</li>
        <li>\(A \mapsto 0 \)</li>
        <li>\(B \mapsto 5 \)</li>
        <li>\(C \mapsto -1 \)</li>
    </ul>
    <p>On peut facilement fabriquer de la variation continue en faisant la combinaison linéaire de l'expression de chaque allèle</p>

    $$ \frac{1}{3} (v_{AB} + v_A + 0.5v_B + 0.5v_C)  $$
    <p>en utilisant le poids de l'expression de chaque allèle. La feature sera évaluée ici à \(1\)</p>

    L'évaluation en combinaison linéaire d'un support génétique encodé sur \(N\) gènes est donné par 

    $$ V = \frac{1}{N}\sum_{i=1}^{N} u(i_a,i_b)v_a + (1-u(i_a,i_b))v_b $$ 

    Soit
    $$ V = \frac{1}{N}\sum_{i=1}^{N}  u(i_a,i_b)\left[v_a -v_b\right] + v_b $$ 

    <p>avec \(i_a\) et \(i_b\) les allèles a et b du gène \(i\).</p>

    <p>
        L'utilisateur peut ensuite <strong>metre à l'échelle (rescale)</strong> les valeurs obtenues vers un nouvel intervalle. En effet, en fonction des valeurs qu'il a associé à chaque allèle, il a accès à l'intervalle du domaine de départ (les bornes min et max), ici \( \left[ -1 : 5 \right]\). Il peut interpoler chaque valeur de cet intervalle vers un autre intervalle. Pour cela il a juste à définir un min, un max et une fonction d'interpolation. Par exemple, il définit l'intervalle d'arrivée à \( \left[ 10 : 300 \right]\) et une fonction d'interpolation linéaire.
    </p>
    <p>
        On peut faire une interpolation linéaire ou avec n’importe quel polynôme. Le choix de l'interpolation est un paramètre intéressant car ainsi, une variation infime du génome (brassage, mutation) peut conduire à des variations phénotypiques plus fortes (et non directement proportionnelle ou graduelle)
    </p>

    <img src="img/interpolation.png" alt="" style="width:80%">



    <h5>Stratégies par défaut</h5>

    <p>On peut proposer des stratégies par défaut (sans avoir à écrire du code) pour définir la valeur renvoyée par la feature</p>

    <ul>
        <li>Faire remonter l'allèle qui s'exprime le plus. Cela revient à donner plus de poids à certains gènes d'un support. </li>
        <li>... ?</li>
    </ul>
 

    <p class="question">Comment ça se passe pour un trait phénotypique encodé sur plusieurs gènes ? Quelles stratégies on peut mettre en place pour fabriquer une interprétation d'un support génétique s'exprimant sur plusieurs gènes ? Quel rôle donner aux <em>poids d'expression</em> ?</p>


    <h5>Ultime possibilité (et la plus forte) : écrire soi même sa fonction !</h5>


    <p>
        L'idéal est de pouvoir écrire soi même une fonction qui renverra le phénotype. Cette fonction permet de couvrir toutes les autres stratégies définies précédemment (celles-ci ne sont que des aides pour l'utilisateur, lui proposer des stratégies clés en main sur des patterns courants). Ainsi on peut imaginer ouvrir une fenêtre d'édition à l'utilisateur pour qu'il écrive soi même sa fonction
    </p>
    <code class="pseudo-code">
        <pre>
function evaluate(args){
    //Write your own function that returns a phenotype (data)
    //...
    return {}
}
        </pre>
    </code>
    <p>où <code>args</code> est une variable d'entrée de la fonction que l'utilisateur peut utiliser. Elle aurait toutes les infos nécessaires pour écrire la fonction : les valeurs de départ du support, les poids et les valeurs mappés. Par exemple ici :</p>
<pre>
    <code>args = {
        data: { 
          AB: {
            // poids expression de la valeur retournée par le support
            weight: 1, 
            // la valeur assignée par l'utilisateur
            map: 1 
          },
          A: {
            weight: 1,
            map: 0  
          },
          B: {
            weight: 0.5,
            map: 5  
          },
          C: {
            weight: 0.5,
            map: -1  
          },
         }
        otherData: ???
    }
    </code>
</pre>

<p> Le code sera à écrire en JavaScript. Il permettra de faire tout ce qu'on veut. Justement, tout ce qu'on veut peut amener à des gros poblèmes de sécurité. Il faudra songer à ce point : accès au DOM, Web API du navigateur? Emettre des requetes? Il faudra proposer un environnement où on peut contrôler les autorisations qu'on donne à ce code.</p>
<p class="note">Peut-être faudra-t-il demander en plus à l'utilisateur de donner un schéma de réponse (la structure de la collection clé/valeurs et les types de données) dans le cas où une autre feature vient prendre en entrée ce résultat. Comme ça on pourrait lui garantir un certain format de données à utiliser pour composer sa prochaine stratégie et éviter bien des bugs.</p>

<p>Prenons un exemple simple ici j'écris ma fonction, je veux, par exemple, retourner la valeur de \(AB\) si elle existe, sinon je renvoie 'toto'</p>
<code class="pseudo-code">
    <pre>
function evaluate(args, phenotype = { value: undefined, dimension = undefined, 
    units = undefined}){
    if( 'AB' in args.data){
        // valeur du phénotype retourné
        phenotype.value =  args.data['AB'].map
        phenotype.dimension = 'Length'
        phenotype.units = 'm'
        return phenotype
    }
    //Si AB n'est pas présent
    phenotype.value = 'toto'
    return phenotype
}
    </pre>
</code>

<p>Ici on contraint la réponse à respecter le schéma suivant : la valeur retourné doit contenir 3 clés: value, dimension et units. Si une clé manque (ou si une autre clé est ajoutée) une erreur est émise. Un <em>template</em> de phénotype est imposé. </p>
    <p> Ici j'ai deux phénotypes possibles (valeurs, grandeur et unité de mesure différentes) Si une autre feature prend en entrée ce phénotype On pourrait imagnier contraindre encore plus le retour en demandant le type de données attendue pour la value, la valeur de la dimension et de l'unité de mesure etc.. Ce sont des points techniques mais intéressants.</p>

    <p class="note">On peut imaginer encore beaucoup de choses dans les contraintes à imposer ici. Plus on met de contraintes plus c'est long d'éditer mais plus on peut proposer des tests automatiques pour avertir l'utilisateur en cas de bug. Autant de temps à débugger en moins dans son projet</p>


    <h4 id="fonctionnal-feature">Features <em>fonctionnelles</em></h4>

    <p>
        Jusqu’ici on a parlé d’associer aux valeurs remontées par le support génétique d'autres valeurs qui <em>font sens</em>. On fait correspondre des valeurs à des valeurs, on map. Une feature est une simple <em>fonction</em> au sens mathématique qui, à chaque valeur fait correspondre une autre valeur. Pourquoi s’arrêter là ? Pourquoi ne pas donner la possibilité d’associer à chaque valeur d’un support génétique directement une fonction ? En effet, une fonction est <em>une valeur comme les autres</em> (dans une approche <a href="https://en.wikipedia.org/wiki/First-class_function">first-class function</a>), au même titre que 1 ou ‘toto’.
    </p>

    <p>
        Cette possibilité est <strong>extrêmement intéressante</strong> car elle permet de produire des phénotypes qui sont non plus juste des états (une valeur interprétée du support génétique) mais des <strong>comportements</strong>. 
    </p>

    <p>Reprenons un exemple où notre support génétique est codé sur un gène avec deux allèles A et B, avec \(u(A,B)=1\), soit A dominant et B récessif. On a donc deux valeurs possibles , A ou B, pour ce support. Associons une fonction(une valeur) à chaque allèle dans notre feature que nous appelerons <code>'FeatureA'</code> :</p>
    <ul>
        <li>\(A \mapsto f_A(x,y) \{ \text{return x + y} \} \)</li>
        <li>\(B \mapsto f_B(x,y) \{ \text{return x - y} \} \)</li>
    </ul>

    <p>où \(x\) peut être n'importe quoi (y compris une fonction !) C'est à l'utilisateur de le définir. Attention ici on est pas dans le cas où on va appliquer \(f_A\) quand A s'exprime et renvoyer le résultat. Ici, on <strong>retourne</strong>\(f_A(x)\)</p>

    <p>Par exemple, un extrait de pseudo-code de l'utilisateur dans son projet</p>

    <code class="pseudo-code">
        <pre>
value = evaluate(individu,'FeatureA')
x = value(1,2) // = 3 si A s'exprime, -1 si B s'exprime
        </pre>
    </code>

    <p>Les features fonctionnnelles ne sont qu'une généralisation des autres features. En effet, quand on associe une valeur à un allèle</p>
    $$ A \mapsto \text{'foo'} $$
   <p>c'est équivalent à lui associer une fonction sans argument qui retourne 'foo' </p>
   $$ A \mapsto \text{'foo'} \equiv A \mapsto f_A() \{ \text{return 'foo'} \} $$

   <p>Le fait de pouvoir retourner directement des fonctions est une propriété très intéressante et utile au modèle pour créer des phénotypes riches, faits d'états mais aussi de comportements. Cela ouvre énormément de possibilités.</p>




   <h4>Sur les dimensions et unités de mesure</h4>
   <p>
       La bibliothèque embarquera avec elle les dimensions et unités de mesure répandues (sûrement en utilisant une library tierce). L'utilisateur pourra également définir lui même ses propres grandeurs et unités associées.
   </p>

   <h4>Sur le temps</h4>
   <p>
       Pour le moment nous n'avons pas parlé du temps, les features produisent des phénotypes statiques pour un matériel génétique donné. <strong>Le temps sera accessible par défaut à chaque feature en argument</strong> pour permettre à l'utilisateur de produire des évaluations dynamiques du phénotype. En effet, pour faire évoluer un système (un individu par exemple) il faut une notion de temps d'une manière ou d'une autre. L'horloge interne d'un invidu (à sa naissance) \(t_0\) sera accessible à chaque individu.
   </p>

   <p>
       Il faudra définir un temps bien caractérisé (unité) qui sera utilisable par toutes les features et défini/initialisé à l'échelle du projet comme une variable globale. A refléchir...
   </p>





    <h4 id="features-coupling">Créer des features à partir de features, à partir de features, à...</h4>

    <p>Une feature peut prendre son entrée, être branchée soit</p>
    <ul>
        <li> <strong>a un et un seul support génétique</strong>. Dans la vraie vie c'est l'expression des gènes qui produit des phénotypes, avoir plusieurs traits pour le même support génétique semble absurde. Mais est-ce absurde? Est ce que ça pourrait pas être utile ? A voir.</li>
        <li>à une ou plusieurs features, voir <a href="#general-model">ce schéma</a></li>
    </ul>

    <p>
        Voici une notion un peu plus avancée du modèle mais qui permet, je crois, de lui donner beaucoup d’intérêt et de puissance.
    </p>
    <p>
        Pour le moment, on peut définir des features, chacune interprétant l'expression d'un support génétique. C’est cool déjà, mais c’est embêtant car toutes ces features sont sagement <em>les unes à coté des autres, à s’ignorer mutuellement et à vivre leur vie</em> . En soi on peut laisser au soin de l’utilisateur de combiner les effets des features pour fabriquer de nouveaux mécanismes lui-même. Mais on peut aussi intégrer nativement cette possibilité dans notre bibliothèque, et créer de manière récursive et <em>infinie</em> des features à partir d’autres features.
    </p>
    <p>
        Créer un réseau de features pour fabriquer des nouvelles features, pour fabriquer des nouvelles features. Ainsi on peut créer du couplage entre supports génétiques et produire des phénotypes beaucoup plus intéressants. Voyons cela plus en détails, à partir d’un exemple concret.
    </p>

    <img src="./img/features-coupling-time" alt="" style="width: 100%;">

    <p>
        Sur le schéma ci dessus on a un cas de couplage qui fait intervenir le temps. On a une feature qui nous renvoie la taille de l'individu. Cette taille est fonction du temps, cette donnée est accessible en lecture et donnée par le système à toutes les features. Pour évaluer la taille d'un individu il faut évaluer cette feature. Cette feature est couplée à trois autres features : taille min qui donne une taille min encodée sur son support génétique, taille max idem, et taux de croissance.
    </p>

    <p>
        On a donc une feature taille qui pour être évaluée doit avant évaluer tout ses dépendances (on pourra optimiser cette étape, avec un cache et n'évaluer que si l'évaluation de cette feature a changé, notamment grâce à la gestion des mutations). Avec cette définition, quand j'évaluerai taille j'aurai toujours la bonne valeur, même si taux de croissance mute entre deux évaluations.
    </p>

    <p>
        Voici comment on peut coupler les features entre elles pour produire des nouvelles features, et créer autant de complexité qu'on le souhaite. On peut imaginer ici reproduire des features à la manière de composants informatiques, qui viennent éteindre et allumer l'expression d'autres features.
    </p>

    <p>
        Comme on peut le voir on se sert des valeurs générées précedemment par la feature pour arriver à ce résultat. Il est temps d'aborder un point important sur l'évaluation et les états d'un individu.
    </p>

    <h4>Les états et l'évaluation</h4>

    <p>C'est sans doute l'un des points les plus importants dans le design de ce modèle. Le phénotype d'un individu, le global (l'aggrégation de tous les phénotypes produits par les features) et le local (produit par une feature) <strong>est un état immutable</strong>. Le phénotype est lui aussi <strong>une valeur</strong>. </p>
        <p>
            Quand on veut connaître la taille d'un invidivu par exemple, on ne vient pas écraser ou mettre à jour la taille qu'il avait avant. On évalue la feature et elle nous renvoie une valeur. Cette valeur ne change pas dans le temps, la taille d'un individu ne change pas dans le temps : quand on la mesure on obtient des valeurs différentes à chaque instant. Quand on mesurait notre taille enfant en mettant une petite marque sur le mur, on n'effacait pas la marque d'avant pour mettre la suivante, plus haute. On faisait une nouvelle marque ! Il sera toujours vrai, qu'à un moment donné vous étiez plus petit qu'aujourd'hui. En ce sens, votre taille n'est pas un état mutable. Vous avez plutot effectué une mesure, et au cours du temps, cette mesure a renvoyé des valeurs différentes.
        </p>

        <p>
            C'est la même chose pour notre phénotype. Le phénotype n'a pas à être un état mutable, qu'on viendrait mettre à jour à chaque pas de temps. Non ! Le phénotype est <strong>un instantanné de l'évaluation de toutes les features d'un individu</strong>. Si je veux connaitre la taille d'un individu, j'évalue sa feature taille et elle me renvoie une valeur. Cette valeur dépend du temps (mesurer deux fois la taille au même instant produit la même valeur). 
        </p>
        <p>
            Chaque feature, comme dans l'exemple ci-dessus, conserve un journal, un historique (un log) de toutes les valeurs qu'elle a produite quand on l'a évaluée. Ainsi, j'accède naturellement à l'histoire complète de mon individu. Je ne remplace pas la valeur taille, j'en créee un nouvelle à chaque fois que je fais la mesure. Ce log permet de calculer le présent en fonction du passé. Le présent (ou le futur) ne vient pas écraser le passé. 
        </p>

        <p>
            Il est hors de question pour notre feature d'avoir un état pour ces raisons. Une feature est une fonction qui produit des valeurs (en appelant d'autres features au besoin). Quand j'ai besoin de l'évaluer je l'évalue et je produis une nouvelle valeur pour mon phénotype.
        </p>
        <p>
            Dans ce modèle, l'état mutable est justement le support génétique, sujet à des <em>mutations</em>. Dans toute cette biliothèque le seul état mutable est le génome (exception faite de l'épigénétique, qui est d'ailleurs peut-être une mauvaise idée, ça peut être utile mais déconseillée à n'utiliser que dans des cas où c'est nécessaire)
        </p>

        <p>
            Pour résumer, <strong>le phénotype d'un individu est une valeur</strong> produite par les features à un instant donné. Les features n'ont pas d'état mutable (elles ne maintiennent pas un état, elle ne font pas d'assignement). Elles peuvent produire une valeur à partir d'une valeur produite dans le passé, c'est bien normal. Mais <strong>elles ne peuvent pas modifier le passé</strong>, elles peuvent juste y accéder en lecture, <strong>ce sont des faits</strong>. En ce sens le log est un état mais un état immutable. Chaque nouvelle entrée s'ajoute aux précédentes sans les modifier, aucune entrée ne peut pas être modifiée ou supprimer par la feature.  
        </p>
      
   

    <h5>Les features comme des API</h5>



    <h5>Une feature "Groupe de features"</h5>

    <p>
        Un nom juste pour dire « une feature qui est un paquet de features ». Comme on l’a vu, on pourra combiner des features pour faire des nouvelles features, utiliser l’expression d’une pour conditionner l’expression de l’autre. Cela crée naturellement des dépendances entres features. Pour simplifier la vie de l’utilisateur on pourrait rajouter quelque chose de simple : faire des paquets de features. Au lieu d’évaluer chacune d’entre elles on en évalue qu’une qui renverra l ‘évaluation de toutes les features qu’elle contient. C’est juste une fonctionnalité pour faciliter la vie de l’utilisateur et simplifier l’usage de la bibliothèque.
    </p>
    <p>
        Par exemple, je crée tout un ensemble de features relatives à la possibilité de voler d’un animal : absence/présence d’ailes, taille des ailes, types ailes (a plume, mammifère), forme des ailes, couleurs des plumes, bruit que fond les ailes, vitesse en vol, vitesse de pointe etc... Toutes ces features sont reliées les unes aux autres. Par exemple s’il n’y a pas de plumes, il n'y a pas de couleur des plumes. Au lieu d’avoir à interroger manuellement chacune de ces features je pourrais créer une « méta-feature » qui s’appelle « vol » par exemple. Elle les comprendrait toutes. Cela donnerait une paquet prêt à l’emploi ds n’importe quel projet où je veux voir ce trait phénotypique exister. Ainsi dans le code au lieu d’avoir un truc du genre :
    </p>

    <code class="pseudo-code">
        <pre>
hasPlumage = evaluate(individu, ‘hasPlumage’)
plumageColors = evaluate(individu, ‘plumageColors’)
wingsSize = evaluate(individu, ‘wingsSize’)
etc.
//Then do logic
...
//A la place on aurait
vol = evaluate(individu, ‘vol’)
//vol contiendrait toutes les données :
//par ex : vol = {
    hasWings : true,
    hasPlumage : false,
    plumageColor : undefined,
    wingSize : {
        value : 52,
        unit : ‘cm’
    },
    speed : {
        value : 60 ,
        unit : ‘km/h’
    }
    //Etc...
} 
        </pre>
</code>

<p>
    En ce sens, le phénotype global d'un individu (l'ensemble de ses traits), est la méta feature la plus globale
</p>
<code class="pseudo-code">
    <pre>
//evalue toutes les features d'un coup
phenotype = evaluate(individu)
    </pre>
</code>
 

    <h3 id="espèces">Espèce</h3>

    <h3 id="espèces">Population</h3>
    

    <h2 id="mutations">Mutations</h2>


    <h3 id="epigenetique">Épigénétique</h3>


    <h2 id="mutations">Moteur : reproduction et transmission du génome</h2>

    <h3>Autofertilisation</h3>
    <h3>Clonage</h3>
    <h3>Reproduction Sexuée</h3>
    <h3>Reproduction entre espèces</h3>

    <h2>Modèle reproduction</h2>
    <h3>Meiose</h3>
    <h3>Cross-over</h3>
    <h3>Mitose</h3>


    <h2>Génération d'une documentation interactive automatique</h2>

    <p>Générer une documentation automatiquement décrivant l'API de chaque Feature dans un projet donné. Cette documentation aidera grandement l'utilisateur a desiger ses modèles de données et aussi à les utiliser dans son propre programme.</p>


    <h2>Usage de la bibliothèque (dans les grandes lignes)</h2>
    <p>La bibliothèque sera open-source (évidemment). Le code sera accessible depuis un dépot public. Le code source sera découpé en au moins deux composants:</p>
    <ul>
        <li>code source moteur de la lib (tout ce qui fera tourner le modèle)</li>
        <li>code source des éditeurs, generateur doc, bac à sable</li>
    </ul>
    <p>On pourra imaginer à terme de faire des éditeurs et du bac à sable une web app: éditeur en ligne, création d'une store où les gens peuvent partager leur design et les télécharger (création d'une communauté). Chaque design aura sa doc.</p>

    <p>En tant qu'utilisateur je veux intégrer cette library pour mon projet :</p>
    <ul>
        <li>Je l'installe (avec ses dépendances) dans mon projet (surement via npm ou yarn). J'importe seulement le moteur dans mon projet</li>
        <li>Soit:
            <ul>
                <li>j'ai envie de créer mes propres design ou éditer design existants, je lance les éditeurs et je travaille dessus. Quand je suis satisfait, que j'ai testé dans le bac à sable j'exporte les données (sous format d'un fichier). Les données comprenent: les supports génétiques, les features, les especes, les mutations etc...</li>
                <li>j'ai pas envie d'en faire moi même, d'autres gens en ont peut etre fait des mieux qui me correspondent ou pourraient me servir de base. Je récupère un design de quelqu'un (un fichier) (téléchargable en ligne sur le store), je l'importe, je l'édide et je l'exporte.</li>
            </ul>
        </li>
        <li>J'importe mes fichiers de design dans mon projet</li>
        <li>Je fabrique surement un fichier de configuration global demandé par la bibliothèque pour initialiser des choses (sécurité, gestion du temps, gestion des erreurs, generation pop, blabblabla...)</li>
        <li>J'utilise le tout pour fabriquer mon programme !</li>
    </ul>

    <p>Voici un pseudo code de l'utilisation de la bibliothèque (juste pour donner une idée)</p>


<code class="pseudo-code">
        <pre>
 import * as glib from "moteur"

 //Je crée une population initiale  de 50 individus, 
 //de l'espece 'espece#1' que j'ai designé
 const population = glib.generatePopulation('espece#1', 50)
 ...
 //Mon programme arrive à un point
 //où je veux déclencher une mutation designée
 const result = glib.triggerMutation('nomMutation') 
 ...
 //Deux individus se reproduisent et donnent une descendance de 10 individus:
 const offspings = glib.reproduce(individu1,individu2, 10)
 ...
 //Une fleur s'autoféconde pour fabriquer un nombre aléatoire de descendants
 const flowers = glib.reproduce(flower, random(10,100))
 ...
 //Deux individus se reproduisent, le nombre de descendant 
 //est borné par une feature 'capaciteGestation'
 const offspings = glib.reproduce(individu1,individu2, 
 random(1, get_phenotype(individu2,'capaciteGestation')))
 ...
 const killed = glib.kill(population)
 ...
//j'ai déjà ma propre structure de données/objet
//Fish avec son comportement
const fish = new Fish('toto')
console.log(fish) // = {toto:'foo'}
//je veux qu'il puisse se reproduire, le rendre
//genetique
fish = glib.setSpecie(fish, 'espece#1')
//fish dispose maintenant de toutes les features
//de l'espce#1 et peut se reproduire
const babyFish = glib.reproduce({fish, args: {bar}},fish2)
//babyFish a conservé tout ce dont il hérite
//de sa structure originelle
console.log(babyFish) // = {toto:'bar', phenotype: {....}} 

        </pre>
    </code>

    <h2>Exemples : reproduction de cas connus</h2>

    <h3>Lapins</h3>
    <h3>Snapdragons (dominance incomplète)</h3>
    <h3>Groupe sanguin chez l'Homme (codominance)</h3>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>