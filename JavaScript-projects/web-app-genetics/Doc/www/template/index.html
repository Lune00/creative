<!doctype html>
<html class="no-js" lang="en">

<head>
    <meta charset="utf-8">

    <!--====== Title ======-->
    <title>Modele Design</title>

    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--====== Favicon Icon ======-->
    <link rel="shortcut icon" href="" type="image/png">

    <!--====== Magnific Popup CSS ======-->
    <link rel="stylesheet" href="assets/css/magnific-popup.css">

    <!--====== Slick CSS ======-->
    <link rel="stylesheet" href="assets/css/slick.css">

    <!--====== Line Icons CSS ======-->
    <link rel="stylesheet" href="assets/css/LineIcons.css">

    <!--====== Bootstrap CSS ======-->
    <link rel="stylesheet" href="assets/css/bootstrap.min.css">

    <!--====== Default CSS ======-->
    <link rel="stylesheet" href="assets/css/default.css">

    <!--====== Style CSS ======-->
    <link rel="stylesheet" href="assets/css/style.css">

</head>

<body>
    <!--[if IE]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->

    <!--====== PRELOADER PART START ======-->

    <div class="preloader">
        <div class="loader">
            <div class="ytp-spinner">
                <div class="ytp-spinner-container">
                    <div class="ytp-spinner-rotator">
                        <div class="ytp-spinner-left">
                            <div class="ytp-spinner-circle"></div>
                        </div>
                        <div class="ytp-spinner-right">
                            <div class="ytp-spinner-circle"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!--====== PRELOADER PART ENDS ======-->

    <!--====== NAVBAR TWO PART START ======-->

    <section class="navbar-area">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <nav class="navbar navbar-expand-lg">



                        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTwo"
                            aria-controls="navbarTwo" aria-expanded="false" aria-label="Toggle navigation">
                            <span class="toggler-icon"></span>
                            <span class="toggler-icon"></span>
                            <span class="toggler-icon"></span>
                        </button>

                        <div class="collapse navbar-collapse sub-menu-bar" id="navbarTwo">
                            <ul class="navbar-nav m-auto">
                                <li class="nav-item active"><a class="page-scroll" href="#home">home</a></li>
                            </ul>
                        </div>

                        <div class="navbar-btn d-none d-sm-inline-block">
                            <ul>

                            </ul>
                        </div>
                    </nav> <!-- navbar -->
                </div>
            </div> <!-- row -->
        </div> <!-- container -->
    </section>

    <!--====== NAVBAR TWO PART ENDS ======-->

    <!--====== SLIDER PART START ======-->

    <section id="home" class="slider_area">
        <div id="carouselThree" class="carousel slide" data-ride="carousel">
            <ol class="carousel-indicators">
                <li data-target="#carouselThree" data-slide-to="0" class="active"></li>
                <li data-target="#carouselThree" data-slide-to="1"></li>
                <li data-target="#carouselThree" data-slide-to="2"></li>
            </ol>

            <div class="carousel-inner">
                <div class="carousel-item active">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-6">
                                <div class="slider-content">
                                    <h1 class="title">Modèle Génétique</h1>
                                    <p class="text">Du génome au phénotype, d'un individu à une population</p>
                                </div>
                            </div>
                        </div> <!-- row -->
                    </div> <!-- container -->
                    <div class="slider-image-box d-none d-lg-flex align-items-end">
                        <div class="slider-image">
                            
                        </div> <!-- slider-imgae -->
                    </div> <!-- slider-imgae box -->
                </div> <!-- carousel-item -->

                <div class="carousel-item">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-6">
                                <div class="slider-content">
                                    <h1 class="title">Modèle démographique</h1>
                                    <p class="text">Toute l'histoire des populations, des individus est accessible à
                                        tout moment. Remontez dans le temps, changez le cours de l'histoire</p>
                                </div> <!-- slider-content -->
                            </div>
                        </div> <!-- row -->
                    </div> <!-- container -->
                    <div class="slider-image-box d-none d-lg-flex align-items-end">
                        <div class="slider-image">
                          
                        </div> <!-- slider-imgae -->
                    </div> <!-- slider-imgae box -->
                </div> <!-- carousel-item -->

                <div class="carousel-item">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-6">
                                <div class="slider-content">
                                    <h1 class="title">Modèle fonctionnel</h1>
                                    <p class="text">Tout est ici valeurs et fonctions pures (ou presque)</p>
                                </div> <!-- slider-content -->
                            </div>
                        </div> <!-- row -->
                    </div> <!-- container -->
                    <div class="slider-image-box d-none d-lg-flex align-items-end">
                        <div class="slider-image">
                           
                        </div> <!-- slider-imgae -->
                    </div> <!-- slider-imgae box -->
                </div> <!-- carousel-item -->
            </div>

            <a class="carousel-control-prev" href="#carouselThree" role="button" data-slide="prev">
                <i class="lni lni-arrow-left"></i>
            </a>
            <a class="carousel-control-next" href="#carouselThree" role="button" data-slide="next">
                <i class="lni lni-arrow-right"></i>
            </a>
        </div>
    </section>

    <!--====== SLIDER PART ENDS ======-->

    <!--====== FEATRES TWO PART START ======-->

    <section id="services" class="features-area">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-lg-10 col-md-10">
                    <div class="section-titlepb-10">

                        <p>22/02/2021</p>
                        <h2 id="ce-quon-fabrique">Qu'est ce qu'on cherche à faire ?</h2>
                        <p>Construire une bibliothèque que n’importe qui peut installer et utiliser dans ses propres
                            projets informatiques. Cette bibliothèque est constituée d’un moteur (un ensemble de
                            fonctions implémentant le modèle) ainsi que de données (avec un format bien défini)
                            exportables et importables. Ainsi, les utilisateurs pourront partager leurs données entre
                            eux (design du génome, des traits phénotypiques et des espèces) et une communauté
                            <em>pourrait</em> se former construisant petit à petit des designs de plus en plus élaborés.
                            L’idée c’est qu’on pourra construire à partir de ce qu’on a construit.</p>
                        <p>Pour permettre cela tout en étant <em>user-friendly</em> des éditeurs avec interface
                            graphique seront développés :</p>
                        <ul>
                            <li>Un éditeur de <a href="#support-g%C3%A9n%C3%A9tique">support génétique</a></li>
                            <li>Un éditeur de <a href="#features">traits phénotypiques</a></li>
                            <li>Un éditeur de <a href="#mutations">mutations</a></li>
                            <li>Un éditeur d’<a href="#esp%C3%A8ces">espèces</a></li>
                            <li>Un bac à sable pour tester et explorer rapidement ses designs</li>
                            <li>Un générateur de documentation des allèles et features de chaque espèce dans lequel il
                                sera facile de chercher (nom, données retournées par une feature etc...)</li>
                        </ul>
                        <p>Les 3 éditeurs permettront d’éditer, importer, exporter, dupliquer, supprimer, ces 3 type de
                            données facilement. Ces données seront ensuite importées dans le projet informatique de
                            l’utilisateur et celui-ci, après import du moteur, pourra faire tourner le modèle dans le
                            but qu’il s’est fixé.</p>
                        <h2 id="objectifs">Objectifs</h2>
                        <p>S’amuser. Fournir un moteur permettant de simuler des entités (biologiques ou non) possédant
                            des caractéristiques (traits phénotypiques) <strong>interprétables par
                                l’utilisateur</strong>. Ces caractéristiques sont le résultat de l’évaluation d’un
                            support génétique (principalement). Les entités pourront se reproduire et transmettre à leur
                            descendance une part de leur génome pour créer de l’hérédité, de la filiation (et de
                            l’histoire). Ce génome pourra également être soumis à des mutations et évoluer.
                            L’utilisateur pourra alors facilement simuler de la sélection et des populations au cours du
                            temps dans son propre projet. Les espèces pourront muter, les populations évoluer etc. En
                            somme un gros bac à sable. Ce modèle pourrait avoir des ambitions plus générales. Car s’il
                            vise principalement à simuler <em>de la vie</em>, le moteur pourrait être appliqué à
                            d’autres <em>objets</em>. On peut penser par exemple à faire une filiation de langues (en
                            utilisant des méthodes de <a href="https://fr.wikipedia.org/wiki/Philologie">philologie
                                comparée</a> comme a pu le faire (sérieusement) Tolkien : utiliser des règles
                            spécifiques de mutation qui permette de passer d’un mot ancêtre à un mot descendant et vice
                            versa). En fait tout ce qui est sujet à itérations successives, tout objet qui« produit du
                            nouveau a partir de lui même » pourrait être simulé.</p>
                        <h2 id="contraintes">Contraintes</h2>
                        <p>La contrainte forte du modèle c’est qu’il faut définir à l’avance des traits phénotypiques
                            auxquels l’utilisateur pourra donner <strong>du sens</strong>. J’insiste là dessus car le
                            but est de pouvoir <strong>interpréter fonctionnellement le phénotype pour prendre des
                                décisions.</strong> Ce que j’entends par là c’est que si une espèce possède un trait
                            phénotypique qui renvoie la valeur ‘foo’ il faut que cette valeur <strong>puisse</strong>
                            (pas nécessairement) avoir un sens pour l’utilisateur dans son programme. En ce sens, les
                            traits phénotypiques doivent être définis dès le départ et le réservoir de phénotypes
                            possibles doit pouvoir être contrôlé.</p>
                        <h2 id="composants-à-développer">Composants à développer</h2>
                        <p><img src="./img/composants.png" alt="Composants"><br>
                            Le projet se compose des composants suivants à concevoir et développer :</p>
                        <ul>
                            <li>Les structures de données :
                                <ul>
                                    <li>Support génétique</li>
                                    <li>Feature (traits phénotypiques)</li>
                                    <li>Espèce</li>
                                </ul>
                            </li>
                            <li>Les éditeurs graphiques (web) pour les éditeurs de données:</li>
                            <li>Un bac à sable pour aider à prototyper et tester ses designs</li>
                            <li>Le moteur (toutes les fonctions, dépendances qui implémentent le modèle)</li>
                        </ul>
                        <p>Les structures de données seront complexes et un éditeur graphique pour les manipuler sera
                            (quasi) indispensable. Ces éditeurs permettront d’importer et d’exporter les données
                            facilement, de les éditer, dupliquer, supprimer. Le modèle est <em>piloté par les
                                données</em>, ces structures sont capitales et doivent être manipulées et définies de
                            manière rigoureuses.</p>
                        <h2 id="aperçu-général-du-modèle-génétique--du-génome-au-phénotype">Aperçu général du modèle
                            génétique : du génome au phénotype</h2>
                        <p>L’utilisateur de la bibliothèque pourra faire évoluer des populations d’individus possédant
                            un phénotype, ou un ensemble de traits observables et mesurables. L’utilisateur pourra
                            évaluer les traits de chaque individu et leur appliquer le traitement qu’il souhaite. Ces
                            traits seront l’expression d’un génome <strong>diploïde</strong> porté par chaque individu,
                            transmissible par reproduction ou clonage de génération en génération.</p>
                        <p>Le <em>support génétique</em> (encodé en binaire) lorsqu’il est évalué produit une valeur.
                            Cette valeur est ensuite interprétée par une <em>feature</em> qui produit à son tour une
                            valeur auquel l’utilisateur donne une unité de mesure. L’expression de la feature est alors
                            remontée dans le phénotype, le résultat de l’évaluation de toutes les <em>features</em> de
                            l’individu. La valeur en sortie d’une feature peut servir d’entrée à une autre
                            <em>feature</em> et ainsi de suite. Ainsi, le phénotype forme une collection de couples
                            clé:{valeur, unité} produite par l’évaluation d'un réseau de features (possiblement)
                            interdépendantes, fondé sur un support génétique. </p>


                        <img id="general-model" class="modele-img" src="./img/modele-general" alt="Modèle général">


                        <p>Lors de la reproduction ou du clonage, le support génétique est transmis à l’aide de
                            mécanismes connus de la biologie (mais nécessairement simplifiés) : mitose, méiose.</p>
                        <p>Le support génétique pourra être exposé à des mutations. Chaque individu disposera en plus de
                            son support génétique d’un état interne modélisant les effets <em>épigénétiques</em>. Cet
                            état supplémentaire, non encodé dans le génome, pourra modéliser la transmission de
                            caractères acquis.</p>
                        <h2 id="notations">Notations</h2>
                        <ul>
                            <li> \(a-B\) : allèles a et B sur le même locus d’une paire de chromosomes analogues. a est
                                récessif et B est dominant</li>
                            <li> \((a-B)(a-c)(B-B)\) : ensemble de couples d'allèles sur 3 gènes d’une paire de
                                chromosomes analogues. L'ordre des couples n'a pas d'importance</li>
                        </ul>

                        <h2 id="les-modèles-de-données">Les modèles de données</h2>
                        <h3 id="support-génétique">Support génétique</h3>
                        <p>Un support génétique est une séquence en binaire (de 0 et de 1) qui peut être évalué pour
                            <strong>produire des valeurs</strong> entières.</p>
                        <table>
                            <thead>
                                <tr>
                                    <th colspan="4">Support génétique</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <th>Paramètre</th>
                                    <th>Description</th>
                                    <th>Type</th>
                                    <th>Contraintes</th>
                                </tr>
                                <tr>
                                    <td>Nom</td>
                                    <td>Un nom donné au support</td>
                                    <td>String</td>
                                    <td>Unique</td>
                                </tr>
                                <tr>
                                    <td>Nombre de gènes <code>N</code></td>
                                    <td>Nombre de gènes contribuant à la valeur du support</td>
                                    <td>Integer</td>
                                    <td>\( N \ge 1\)</td>
                                </tr>
                                <tr>
                                    <td>Nombre de bits <code>n</code></td>
                                    <td>Nombre de bits sur lequel est encodé chaque gène du support : l’utilisateur
                                        pourra choisir d’encoder des gènes sur des structures allant de 1 à 8 bits
                                        (limite arbitraire). Ce paramètre défini par défaut le nombre de variations d’un
                                        même gène (allèles) accessibles. Par exemple, sur un support à 2 bits on a 4
                                        valeurs possibles : 00 (0), 01 (1), 10 (2) et 11 (3). On a donc, au maximum 4
                                        allèles pour ce gène dans notre « réservoir ». Sur 8 bits on a 256 valeurs
                                        possibles, donc 256 allèles possibles pour un même gène. La structure binaire
                                        est suffisante pour créer assez de variations (pas besoin de 4 caractères AGCT).
                                    </td>
                                    <td>Integer</td>
                                    <td>\( 1 \le n \le 8 \)</td>
                                </tr>
                                <tr>
                                    <td>Rareté d'une allèle \(r\)</td>
                                    <td>Sur les allèles disponibles on peut définir une rareté, un nombre qui sert au
                                        moment de la génération de populations. Ce nombre permettra de définir chance
                                        qu'un individu généré (non issu d'une reproduction) porte cet allèle
                                        initialement. </td>
                                    <td>Float</td>
                                    <td>\( 0 \le r \le 1 \)</td>
                                </tr>
                                </tr>
                                <tr>
                                    <td>Allèles disponibles <code>n<sub>a</sub></code></td>
                                    <td>Le réservoir d'allèles disponibles est par définition définie par le nombre de
                                        bits sur lequel est encodé un gène. L’utilisateur pourra décider de n’utiliser
                                        qu'un sous-ensemble de ce réservoir s’il le souhaite. <strong>Une allèle est une
                                            valeur</strong> possible d'un gène. Elle peut donc muter dans l'espace
                                        défini par le gène vers une autre valeur. </td>
                                    <td>(Integer...)</td>
                                    <td>\( 1 \le n_a \le N^{2} \)</td>
                                </tr>
                                <tr>
                                    <td>Relations entre allèles <code>U</code></td>
                                    <td>Tableau de coefficients dont chaque valeur permet de calculer la contribution de
                                        chacune des 2 allèles du même gène à l’évaluation du support génétique.
                                        L’utilisateur pourra générer ces coefficients de manière aléatoire ou suivant
                                        des règles prédéfinies, ou les écrire manuellement (il y a toujours le contrôle
                                        total si on le souhaite).</td>
                                    <td>[Float]</td>
                                    <td>
                                        \( n_a(n_a+1)/2\) coefficients nécessaires pour évaluer toutes les combinaisons
                                        possibles, voir <a href="#table-genetic-support-summary">ce tableau</a>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <p>Pour résumer, l’évaluation d’un support génétique (et la production d’une valeur) se fait en
                            évaluant pour chacun de ses gènes la paire d’<a
                                href="https://fr.wikipedia.org/wiki/All%C3%A8le">allèles</a> (une allèle sur chaque <a
                                href="https://fr.wikipedia.org/wiki/Chromosome_homologue">chromosome homologue</a>)
                            correspondante. Les relations entre allèles permettent de calculer la
                            <strong>valeur</strong> du support génétique.</p>



                            <h4>Dominat/Récessif, dominance incomplète et codominance</h4>
<p>
    <a href="https://fr.wikipedia.org/wiki/All%C3%A8le#Relations_entre_all%C3%A8les">Plusieurs relations entre allèles</a> existent. Le modèle se propose de modéliser 3 d'entre elles :

</p>


   <ul>
       <li><strong>Dominant/récessif :</strong>  un allèle récessif demande l'homozygotie d'un gène pour pouvoir s'exprimer. Autrement dit, soit \(a-B\) deux allèles du même gène, a est récessif (et B est dominant) si  \(u(a,B)=0\). Ce gène est évalué à \(B\)</li>
       <li><strong> Dominance incomplète :</strong> aucun des allèles qui déterminent le caractère est dominant, les deux s'expriment et le caractère est un mélange des deux contributions. Autrement dit, soit \(a-b\) deux allèles du même gène, a et b ont une dominance incomplète si  \( u(a,b) \in  \left] 0 : 1\right[ \). Ce gène est évalué à {\(A: u(a,b), B: 1-u(a,b)\)}. En ce sens, le modèle Dominant/récessif n'est qu'un cas particulier de dominance incomplète.</li>
       <li><strong>Codominance :</strong>  les deux allèles s'expriment en même temps, et le trait est l'expression conjointe des deux allèles.Autrement dit, soit \(A-B\) deux allèles du même gène, il faut donner au coefficient une valeur distincte pour prendre en compte ce cas. On pose par définition la valeur \(u(A,B)=-1\) pour symboliser ce cas. L'évaluation du gène retourne la valeur \(AB\). Dans ce cas, deux allèles peuvent produire 3 valeurs distinctes : A , B et AB  </li>

       <li><strong>Allèle inerte :</strong>on verra à la section sur <a href="#mutations">les mutations</a> qu'une allèle peut devenir inerte, c'est à dire qu'elle n'exprime plus rien. Une allèle inerte est toujours récessive, si deux allèles inertes sont sur le même gène le gène ne renvoie aucune évaluation.</li>
       <li><strong>Allèle létale :</strong>: si cette allèle s'exprime l'individu meurt</li>
   </ul>

   
<p>
    Voici un tableau résumant les valeurs prises par les coefficients pour chaque type de relation entre allèles, ainsi que le résultat de l'évaluation d'un gène \(A-B\). L'évaluation produit un ensemble clé:valeur noté \( \{ A: w_A , B: w_B \} \) où \(A\) est l'identifiant de l'allèle A et \(w_A\) son poids dans l'expression du gène. Si le poids est nul l'allèle n'est pas exprimé, s'il est égal à 1 on écrira \( \{ A: 1 \}  \equiv \{ A\} \equiv A \). S'il n'y qu'un gène on pourra écrire  \( \{ A\} \equiv A \)
</p>
   <table id="table-genetic-support-summary">
    <thead>
        <tr>
            <th colspan="5">Supports génétiques</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Relation</td>
            <td>Valeurs du coefficient</td>
            <td>Evaluation</td>
        </tr>
        <tr>
            <td>Dominant/Récessif</td>
            <td>\(u(A,B) \in \{0 , 1\}\)</td>
            <td>\( A \) ou \( B \) </td> 
        </tr>
        <tr>
            <td>Dominance incomplète</td>
            <td>\(u(A,B) \in \left]0:1\right[\)</td> 
            <td>\( \{ A: u(A,B) , B: 1-u(A,B) \} \)</td>  
        </tr>
        <tr>
            <td>Codominance</td>
            <td>\(u(A,B) = -1\)</td> 
            <td>\( \{ AB: 1 \}\)</td>  
        </tr>
        <tr>
            <td>Allèle inerte \(A\)</td>
            <td>\(u(A,B) = 0, \forall B\)</td> 
            <td>\( \{ B: 1 \}\)</td>  
        </tr>
        <tr>
            <td>Allèles inertes \(A\) et \(B\) </td>
            <td>\(u(A,B) = u(B,A) = 0\)</td> 
            <td>\( \{ \}\)</td>  
        </tr>
    </tbody>
</table>

<p>
    Pour le moment aucune valeur n'est assignée à chaque allèle, sa valeur est son code binaire (ou son nom qui est un alias pour ce code). La valeur et le sens seront défini au niveau d'une <a href="#features">feature</a>.
</p>


    <h4 id="exemple--support-génétique-continu">Exemple 1 :</h4>
    <p>Prenons un support génétique :</p>
    <ul>
    <li>codé sur 3 gènes</li>
    <li>chaque gène est codé sur 2 bits</li>
    <li>Allèles disponibles : toutes, soit
    <ul>
    <li>00 ( A )</li>
    <li>01 ( B )</li>
    <li>10 ( C )</li>
    <li>11 ( D )</li>
    </ul>
    </li>
    </ul>
    <p>Initialisons le tableau des relations entre allèles :</p>
    <div class="center-container">
    <table>
        <tbody>
            <tr>
                <td></td>
                <td>A</td>
                 <td>B</td>
                <td>C</td>
                 <td>D</td>
            </tr>
            <tr>
                <td>A</td>
                <td>1</td>
                 <td>0.3</td>
                <td>0.7</td>
                 <td>1</td>
            </tr>
              <tr>
                <td>B</td>
                <td>-</td>
                 <td>1</td>
                <td>0.2</td>
                 <td>0.4</td>
            </tr>
            <tr>
                <td>C</td>
                <td>-</td>
                 <td>-</td>
                <td>1</td>
                 <td>0.5</td>
            </tr>
             <tr>
                <td>D</td>
                <td>-</td>
                 <td>-</td>
                <td>-</td>
                 <td>1</td>
            </tr>
        </tbody>
    </table>
</div>

<p>On a par définition</p>
    $$u(A,B) = 1 - u(B,A) $$ 
    <p>si A et B ne sont pas codominants. Pour le cas de codominance on a défini une valeur arbitraire</p>
    $$u(A,B) = u(B,A) = -1 $$ 

<p>On peut noter que l'allèle D est récessif vis à vis de A qui est dominant. Dans tous les autres rapports d'allèles nous sommes dans un cas de dominance incomplète. Évaluons à présent un individu qui posséderait un support génétique initialisé comme suit :</p>
$$(a-b)(c-b)(a-d)$$

<p>L’individu est <a href="https://fr.wikipeda.org/wiki/H%C3%A9t%C3%A9rozygote">hétérozygote</a> pour chacun des 3 gènes. L'évaluation du support génétique donne </p>

    $$ v = \{ A:1.3, B:0.9, C:0.8 \}$$
   
<p>On peut voir que si le support génétique est constitué de plusieurs gènes il suffit d'ajouter les contributions de chaque gène.</p>

    <h4>Exemple 2</h4>

    <p>Reprenons le même support génétique :</p>
    <ul>
    <li>codé sur 3 gènes</li>
    <li>chaque gène est codé sur 2 bits</li>
    <li>Allèles disponibles : 3 sur les 4 disponibles, soit
    <ul>
    <li>00 ( A )</li>
    <li>01 ( B )</li>
    <li>10 ( C )</li>
    </ul>
    </li>
    </ul>
    <p>Construisons un autre tableau de relations entre allèles :</p>
    <div class="center-container">
    <table>
        <tbody>
            <tr>
                <td></td>
                <td>A</td>
                 <td>B</td>
                <td>C</td>
            </tr>
            <tr>
                <td>A</td>
                <td>1</td>
                 <td>-1</td>
                <td>1</td>
            </tr>
              <tr>
                <td>B</td>
                <td>-</td>
                 <td>1</td>
                <td>0.5</td>
            </tr>
            <tr>
                <td>C</td>
                <td>-</td>
                 <td>-</td>
                <td>1</td>
            </tr>
        </tbody>
    </table>
</div>

<p> Évaluons à présent un individu qui posséderait un support génétique initialisé comme suit :</p>
$$ (C-B)(A-C)(A-B) $$


<p>L’individu est <a href="https://fr.wikipeda.org/wiki/H%C3%A9t%C3%A9rozygote">hétérozygote</a> pour chacun des 3 gènes. L'évaluation du support génétique donne </p>
$$ v = \{ AB: 1, A:1, B:0.5, C:0.5 \}$$

<p>Les allèles A et B sont codominantes, elles s'expriment donc toutes les deux mais leurs effets ne se combinent pas, elles produisent une nouvelle valeur \(AB\), un nouveau phénotype.</p>

<h3>Sur les allèles</h3>
Un allèle est un code binaire, une variation d'un gène. Son code binaire est son identifiant, qu'on pourra surharger avec un nom. Un allèle peut être déclaré :
<ul>
    <li>Disponible : l'allèle pourra être présent à l'initialisation d'une population d'individus</li>
    <li>Mutant : non accessible par défaut, seulement par mutation de son code génétique</li>
</ul>
Un allèle pourra muter 
<ul>
    <li>vers un allèle existant (Disponible), équivalent à du brassage génétique</li>
    <li>vers un allèle mutant (Mutant), introduction d'un nouvel allèle dans la population</li>
</ul>
Au niveau de la feature, la valeur de cet allèle (ainsi que son rapport aux autres) peut être
<ul>
    <li>défini à l'avance par l'utilisateur. Ainsi il garde le contrôle complet sur les entrées/sorties au niveau des features </li>
    <li>défini aléatoirement (par une fonction), l'utilisateur perd alors le contrôle sur l'évaluation du génome qui va évoluer de lui même (selon des règles définies à l'avance) </li>
</ul>
Dans le deuxième cas de figure, de l'évolution incontrôlée pourra apparaître car même l'utilisateur ne saura pas à l'avance la valeur que va produire le support génétique. Les deux cas sont intéressants, le contrôle doit être libre pour l'utilisateur. Dans le cas où les valeurs ne seront pas définies à l'avance (et pourront être n'importe quoi), il faudra prévenir l'utilisateur que la valeur que prend en entrée la feature est inconnue ou imprévisible, afin d'être sûr de ne pas casser son code. A charge de l'utilisateur de faire le nécessaire pour l'interpréter (la solution la plus simple consistant à retourner la valeur telle quelle.)
    <h3 id="features">Feature (ou trait, phénotype local)</h3>

    <h4>Définition</h4>

    <p>Une fois définis des supports génétiques on peut commencer à designer le composant à l'étage du dessus : la feature. Une feature est un trait (un phénotype) observable au niveau de l'individu. Jusqu’ici on a seulement parlé de support génétique dont l'évaluation produit des valeurs.  C’est donc à ce niveau qu’on va  <em>donner un sens aux valeurs générées par le support génétique</em>. La feature produit une   <strong>observable</strong> que l'utilisateur va définir. </p>

    <p>L’intérêt de découpler la production de valeur par un support génétique de son interprétation c’est qu'ont peut réutiliser un même support pour plusieurs features (dans différents projets) et redéfinir l'interprétation que l'on fait de sa valeur.</p>
    <p>
        La feature est une fonction qui va prendre en entrée la valeur d'un support génétique, <a href="#features-coupling">ou d'une autre feature</a>, et retourner un phénotype, c'est à dire, une valeur et (possiblement) une grandeur et une unité de mesure. C'est une fonction au sens mathématique du terme : à chaque valeur de l'ensemble de départ (valeurs du support génétique) elle produira une valeur (ici un couple {valeur, unité}) dans un ensemble d'arrivée (valeurs du phénotype).
    </p>

    <p>
        Le point important c'est qu'une feature <strong>ne possède pas d'état interne</strong>. Elle prend des valeurs en entrée et renvoie des valeurs en sortie. Les même valeurs en entrée produisent les mêmes valeurs en sortie. Elle n'a aucun effet de bord, c'est à dire que lorsqu'elle est évaluée elle ne <em> modifie pas l'état du monde</em> (exception faite des <a href="#epigenetique"> features attachées à l'état épigénétique</a>). En d'autres termes ce sont des <a href="https://fr.wikipedia.org/wiki/Fonction_pure">fonctions pures</a>. L'état d'un individu est complètement encodé dans ses supports génétiques et son épigénetique. L'ensemble des features vient agir comme une fonction qui prend cet état et renvoie un phénotype macroscopique. 
    </p>

    <img src="./img/feature-function.png" alt="">

   <p>Pour définir l'évaluation d'une feature, lui donner sens, nous allons avoir besoin d' </p>

    <ul>
        <li>une valeur : nombre décimal, une chaîne de caractères, un ensemble de clé:valeur, voir même une fonction</li>
        <li>une grandeur: (ex: temps, longueur, grandeur personnalisée...) [OPTIONNEL]</li>
        <li>une unité de measure: ‘m/s’, des ‘mols’, des ‘kg’, des ‘grade’, des ‘milipilpoils’ etc.. [OPTIONNEL]</li>
    </ul>
    
    <p>
       L'unité de mesure servira à faire de l'analyse dimensionnelle et valider la cohérence de certaines expressions. Elle pourra servir à faire des conversions automatiques. Par exemple si un phénotype représente une taille, on pourra demander à évaluer cette valeur en 'cm', en 'm' sans avoir besoin de faire la conversion nous même.
    </p>

    <p class="note">
        A noter : l'utilisateur s'il souhaite avoir directement accès à la valeur du support génétique peut le faire, il peut demander à la feature de retourner directement la valeur du support. L'utilisateur pourrait lui donner une valeur (et une dimension, et unité de mesure) dynamiquement durant l'execution de son programme. Par exemple, regardons ce pseudo code d'un utilisateur qui utilise notre bibliothèque dans son projet
    </p>


    <h4>Paramètres</h4>

    <table>
        <thead>
            <tr>
                <th colspan="4">Feature</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Paramètre</th>
                <th>Description</th>
                 <th>Type</th>
                  <th>Contraintes</th>
            </tr>
        <tr>
                <td>Nom</td>
                <td>Un nom donné à la feature</td>
                <td>String</td>
                 <td>Unique</td>
            </tr>
            <tr>
                <td>Source</td>
                <td>D'où proviennent les entrées de la feature</td>
                <td>Support Génétique ou (Features...)</td>
                 <td>Unique si support, MAX(à définir) si features</td>
            </tr>
            <tr>
                <td>Output</td>
                <td>Données en sortie de la feature</td>
                <td>Ensemble {clé:valeurs},<code>Object</code></td>
                 <td>
                     Doit respecter le schéma <code>{valeur: Object, dimension: String, unit: String}</code>. Ajouter peut être une contrainte sur le schéma de <code>value</code>
                   </td>
            </tr>
            <tr>
                <td>Input</td>
                <td>Données en entrée de la feature. <ul>
                    <li>Si support génétique : évaluation du support [entrées possibles définies]</li>
                    <li>Si une ou plusieurs features : concaténation des évaluations des features</li>
                </ul></td>
                <td>Ensemble {clé:valeurs},<code>Object</code></td>
                 <td>

                    <ul>
                        <li> Si source est support : structure passée en entrée doit contenir les clefs appartenant à l'ensemble des allèles définis sur le support</li>

                        <li>Si sources est features : voir contraintes à mettre. Chaque input doit respecter le schéma de données Output de la source. Chaque input doit respecter le schéma <code>{valeur: Object, dimension: String, unit: String}</code>  </li>
                    </ul>
                     
                    
                   </td>
            </tr>
            <tr>
                <td>Log</td>
                <td>Historique de toutes les valeurs générées par la feature. A chaque évaluation, si l'évaluation est différente de la précédente valeur on la log.</td>
                <td>Stack (Last in First Out) { t: {valeur, dimension, unit}}, tableau d'Object</td>
                 <td>
                   Aucune
                   </td>

            </tr>
        </tbody>
    </table>


    <h4>Écrire une feature</h4>

    Pour qu'une feature fonctionne il faut définir :

    <ul>
        <li>ce qu'elle prend en entrée: quelles données arrivent du support génétique</li>
        <li>ce qu'elle retourne en sortie: quelle transformation j'opère pour produire une valeur "phénotype"</li>
    </ul>

    <p class="comment">Quand j'écris une valeur phénotype c'est assez général, on n'impose rien sur le type de retour d'une feature [a voir en fonction du design général], mais en général on peut faire retourner à une feature ce qu'on veut. Ce sont là plutôt des questions techniques, savoir s'il faut fabriquer des types de données à respecter pour assurer une architecture robuste. Ces restrictions viendront au fil de l'eau, par défaut, une feature peut renvoyer n'importe quelle valeur.</p>

    <h4>Mapper les valeurs des allèles</h4>

    <p>La première étape est donc de <em>maper</em> (d'associer) à chaque allèle exprimée du support génétique une valeur. Comme les allèles sont définies au niveau du support génétique on peut facilement proposer une liste de valeurs à maper à l'utilisateur. On peut associer à la valeur de l'allèle n'importe quelle valeur de notre choix</p>
<p>Prenons un exemple de valeur produite par le support génétique encodé sur 3 gènes</p>
$$(c-B)A(A-B) $$
<p>qui est évalué à</p>
    $$ S =\{ AB: 1, A:1, B:0.5, C:0.5 \} $$
    On doit proposer à l'utilisateur d'associer à chaque allèle une valeur. Prenons \(A\), voici les possibilités :

    <ul>
        <li>Associer un entier : \(A \mapsto 1 \)</li>
        <li>Associer un nombre décimal : \(A \mapsto 0.1 \)</li>
        <li>Associer une chaine de caractères : \(A \mapsto \text{'foo'}\)</li>
        <li>Associer un tableau : \(A \mapsto \left[1, \text{'foo'}, 0.5, \left[1, \text{'foo'}, 0.5,  \right]\  \right]\)</li>
        <li>Associer une association clé:valeur : \(A \mapsto \{a: 1, b: \text{'foo'}\}\)</li>
        <li> <a href="#fonctionnal-feature">Associer une fonction</a> : \(A \mapsto f(S)\)</li>
    </ul>

    <p>On pourra évidemment proposer ici de mapper des valeurs de manière automatique (pattern, aléatoire etc..)</p>

    <p>On pourrait imaginer ne pas contraindre l'utilisateur à définir la valeur de chaque allèle. Ainsi, une valeur non mappée aurait une valeur assignée par le système, par exemple <code>unknown</code>.</p>

    <code class="pseudo-code">
        <pre>
x = evaluate(individu, feature) // acceder au phénotype retourné par la feature
//Allèle inconnue (mutation, non définie par l'utilisateur)
if(unknown(x)){
    //Do stuff
    valeur = ....
    // retrouve l'allèle unknown et lui assigne valeur,dimension, unité
    setValue(feature, 'valeur', dimension, unité) 
}
        </pre>
    </code>

    <p>Nous reviendrons sur la possibilité de tomber sur des allèles dont l'évaluation est inconnue dans la section <a href="mutations">mutations</a> </p>

    <h4>Cas d'un support codé sur un gène</h4>

    <p>
        Dans le cas d'un support encodé sur un seul gène, la question ne se pose pas, on retourne la valeur mappé à la valeur qui s'est exprimée.
    </p>

    <h4>Cas d'un support codé sur plusieurs gènes</h4>
    <p>
       Comme dans notre exemple, dans ce cas plusieurs stratégies d'interprétation peuvent être définies par l'utilisateur.
       On peut :
       <ul>
           <li>Renvoyer toutes les valeurs avec leurs poids (information transparente, l'utilisateur en fera quelque chose soit dans une feature à l'étage supérieur, soit directement dans son projet)</li>
           <li>Filtrer : ne renvoyer qu'une valeur, envoyer des valeurs dont le poids normalisé respecte une condition</li>
       </ul>
    </p>

    <p>On peut proposer des stratégies de map au lieu de map indivduellement chaque allèle.</p>
   
    <h5>Map Combinaison linéaire</h5>

    <p> <strong>Si et seulement si l'utilisateur map chacune des allèles à un nombre (entier ou décimal) </strong>on peut proposer à l'utilisateur d'en faire un combinaison linéaire se servant du poids caractérisant la contribution de chaque allèle. Par exemple ici, définissons cette association : </p>
    <ul>
        <li>\(AB \mapsto 1 \)</li>
        <li>\(A \mapsto 0 \)</li>
        <li>\(B \mapsto 5 \)</li>
        <li>\(C \mapsto -1 \)</li>
    </ul>
    <p>On peut facilement fabriquer de la variation continue en faisant la combinaison linéaire de l'expression de chaque allèle</p>

    $$ \frac{1}{3} (v_{AB} + v_A + 0.5v_B + 0.5v_C)  $$
    <p>en utilisant le poids de l'expression de chaque allèle. La feature sera évaluée ici à \(1\)</p>

    L'évaluation en combinaison linéaire d'un support génétique encodé sur \(N\) gènes est donné par 

    $$ V = \frac{1}{N}\sum_{i=1}^{N} u(i_a,i_b)v_a + (1-u(i_a,i_b))v_b $$ 

    Soit
    $$ V = \frac{1}{N}\sum_{i=1}^{N}  u(i_a,i_b)\left[v_a -v_b\right] + v_b $$ 

    <p>avec \(i_a\) et \(i_b\) les allèles a et b du gène \(i\).</p>

    <p>
        L'utilisateur peut ensuite <strong>metre à l'échelle (rescale)</strong> les valeurs obtenues vers un nouvel intervalle. En effet, en fonction des valeurs qu'il a associé à chaque allèle, il a accès à l'intervalle du domaine de départ (les bornes min et max), ici \( \left[ -1 : 5 \right]\). Il peut interpoler chaque valeur de cet intervalle vers un autre intervalle. Pour cela il a juste à définir un min, un max et une fonction d'interpolation. Par exemple, il définit l'intervalle d'arrivée à \( \left[ 10 : 300 \right]\) et une fonction d'interpolation linéaire.
    </p>
    <p>
        On peut faire une interpolation linéaire ou avec n’importe quel polynôme. Le choix de l'interpolation est un paramètre intéressant car ainsi, une variation infime du génome (brassage, mutation) peut conduire à des variations phénotypiques plus fortes (et non directement proportionnelle ou graduelle)
    </p>

    <img src="img/interpolation.png" alt="" style="width:80%">



    <h5>Stratégies par défaut</h5>

    <p>On peut proposer des stratégies par défaut (sans avoir à écrire du code) pour définir la valeur renvoyée par la feature</p>

    <ul>
        <li>Faire remonter l'allèle qui s'exprime le plus. Cela revient à donner plus de poids à certains gènes d'un support. </li>
        <li>... ?</li>
    </ul>
 

    <p class="question">Comment ça se passe pour un trait phénotypique encodé sur plusieurs gènes ? Quelles stratégies on peut mettre en place pour fabriquer une interprétation d'un support génétique s'exprimant sur plusieurs gènes ? Quel rôle donner aux <em>poids d'expression</em> ?</p>


    <h5>Ultime possibilité (et la plus forte) : écrire soi même sa fonction !</h5>


    <p>
        L'idéal est de pouvoir écrire soi même une fonction qui renverra le phénotype. Cette fonction permet de couvrir toutes les autres stratégies définies précédemment (celles-ci ne sont que des aides pour l'utilisateur, lui proposer des stratégies clés en main sur des patterns courants). Ainsi on peut imaginer ouvrir une fenêtre d'édition à l'utilisateur pour qu'il écrive soi même sa fonction
    </p>
    <code class="pseudo-code">
        <pre>
function evaluate(args){
    //Write your own function that returns a phenotype (data)
    //...
    return {}
}
        </pre>
    </code>
    <p>où <code>args</code> est une variable d'entrée de la fonction que l'utilisateur peut utiliser. Elle aurait toutes les infos nécessaires pour écrire la fonction : les valeurs de départ du support, les poids et les valeurs mappés. Par exemple ici :</p>
<pre>
    <code>args = {
        genetic: { 
          AB: {
            // poids expression de la valeur retournée par le support
            weight: 1, 
            // la valeur assignée par l'utilisateur
            map: 1 
          },
          A: {
            weight: 1,
            map: 0  
          },
          B: {
            weight: 0.5,
            map: 5  
          },
          C: {
            weight: 0.5,
            map: -1  
          },
         }
        featureB: {}
        ...
    }
    </code>
</pre>

<p> Le code sera à écrire en JavaScript. Il permettra de faire tout ce qu'on veut. Justement, tout ce qu'on veut peut amener à des gros problèmes de sécurité. Il faudra songer à ce point : accès au DOM, Web API du navigateur? Émettre des requêtes? Il faudra proposer un environnement où on peut contrôler les autorisations qu'on donne à ce code.</p>
<p class="note">Peut-être faudra-t-il demander en plus à l'utilisateur de donner un schéma de réponse (la structure de la collection clé/valeurs et les types de données) dans le cas où une autre feature vient prendre en entrée ce résultat. Comme ça on pourrait lui garantir un certain format de données à utiliser pour composer sa prochaine stratégie et éviter bien des bugs.</p>

<h5>Contrainte sur la valeur retournée?</h5>

<p>Si l'utilisateur écrit sa propre fonction (dans les autres cas ça sera fait automatiquement) il devra fournir un schéma de données pour la valeur retournée par la feature. Par exemple </p>
<pre>
    <code>phenotype = [
        {
            value: String,
            dimension: String,
            unit: String,
        },
        {
            value: Integer,
            dimension: String,
            unit: String,
        },
        ...
       ]
    }
    </code>
</pre>
<p>Ainsi il sera beaucoup plus simple dans l'étape de design de coupler les features, car on saura exactement quelles données on recevra en entrée. Il est peut être même possible qu'on puisse récupérer les valeurs possibles retournées (on peut imaginer créer un bouton dans l'éditeur <code>Test</code> qui testerait la fonction (vérification entrées, vérification du retour conforme au schmé) et qui évalue la fonction sur toutes les entrées possibles pour produire tous les outputs possibles. On aurait alors la liste de toutes les sorties qui pourra être accessible à la feature qui veut la prendre en entrée. </p>
    <p>Ici j'ai mis un tableau de structure phénotype {value, dimension, unit}, on pourrait restreindre encore davantage à une seule structure phénotype. On peut contraindre pas mal je pense car si on met trop de libertés ça va compliquer le design. Si une feature peut renvoyer deux phénotypes différents c'est qu'elle peut probablement être découpée en deux features qui retourne chacune un seul. Ces questions seront tranchées par la pratique.</p>
    

<p>Prenons un exemple simple ici j'écris ma fonction, je veux, par exemple, retourner la valeur de \(AB\) si elle existe, sinon je renvoie 'toto'</p>
<code class="pseudo-code">
    <pre>
function evaluate(args, phenotype = { value: undefined, dimension = undefined, 
    units = undefined}){
    if( 'AB' in args.data){
        // valeur du phénotype retourné
        phenotype.value =  args.data['AB'].map
        phenotype.dimension = 'Length'
        phenotype.units = 'm'
        return phenotype
    }
    //Si AB n'est pas présent
    phenotype.value = 'toto'
    return phenotype
}
    </pre>
</code>

<p>Ici on contraint la réponse à respecter le schéma suivant : la valeur retourné doit contenir 3 clés: value, dimension et units. Si une clé manque (ou si une autre clé est ajoutée) une erreur est émise. Un <em>template</em> de phénotype est imposé. </p>
    <p> Ici j'ai deux phénotypes possibles (valeurs, grandeur et unité de mesure différentes). On pourrait imaginer contraindre encore plus le retour en demandant le type de données attendue pour la value, la valeur de la dimension et de l'unité de mesure etc.. Ce sont des points techniques mais intéressants.</p>

    <p class="note">On peut imaginer encore beaucoup de choses dans les contraintes à imposer ici. Plus on met de contraintes plus c'est long d'éditer mais plus on peut proposer des tests automatiques pour avertir l'utilisateur en cas de bug. Autant de temps à débugger en moins dans son projet</p>


 

    <h4 id="fonctionnal-feature">Features <em>fonctionnelles</em></h4>

    <p>
        Jusqu’ici on a parlé d’associer aux valeurs remontées par le support génétique d'autres valeurs qui <em>font sens</em>. On fait correspondre des valeurs à des valeurs, on map. Une feature est une simple <em>fonction</em> au sens mathématique qui, à chaque valeur fait correspondre une autre valeur. Pourquoi s’arrêter là ? Pourquoi ne pas donner la possibilité d’associer à chaque valeur d’un support génétique directement une fonction ? En effet, une fonction est <em>une valeur comme les autres</em> (dans une approche <a href="https://en.wikipedia.org/wiki/First-class_function">first-class function</a>), au même titre que 1 ou ‘toto’.
    </p>

    <p>
        Cette possibilité est <strong>extrêmement intéressante</strong> car elle permet de produire des phénotypes qui sont non plus juste des états (une valeur interprétée du support génétique) mais des <strong>comportements</strong>. 
    </p>

    <p>Reprenons un exemple où notre support génétique est codé sur un gène avec deux allèles A et B, avec \(u(A,B)=1\), soit A dominant et B récessif. On a donc deux valeurs possibles , A ou B, pour ce support. Associons une fonction(une valeur) à chaque allèle dans notre feature que nous appelerons <code>'FeatureA'</code> :</p>
    <ul>
        <li>\(A \mapsto f_A(x,y) \{ \text{return x + y} \} \)</li>
        <li>\(B \mapsto f_B(x,y) \{ \text{return x - y} \} \)</li>
    </ul>

    <p>où \(x\) peut être n'importe quoi (y compris une fonction !) C'est à l'utilisateur de le définir. Attention ici on est pas dans le cas où on va appliquer \(f_A\) quand A s'exprime et renvoyer le résultat. Ici, on <strong>retourne</strong>\(f_A(x)\)</p>

    <p>Par exemple, un extrait de pseudo-code de l'utilisateur dans son projet</p>

    <code class="pseudo-code">
        <pre>
value = evaluate(individu,'FeatureA')
x = value(1,2) // = 3 si A s'exprime, -1 si B s'exprime
        </pre>
    </code>

   <p>Le fait de pouvoir retourner directement des fonctions est une propriété très intéressante et utile au modèle pour créer des phénotypes riches, faits d'états mais aussi de comportements. Cela ouvre énormément de possibilités.</p>

   <h4>Sur les dimensions et unités de mesure</h4>
   <p>
       La bibliothèque embarquera avec elle les dimensions et unités de mesure répandues (sûrement en utilisant une library tierce). L'utilisateur pourra également définir lui même ses propres grandeurs et unités associées.
   </p>

   <h4>Sur le temps</h4>
   <p>
       Pour le moment nous n'avons pas parlé du temps, les features produisent des phénotypes statiques pour un matériel génétique donné. <strong>Le temps sera accessible par défaut à chaque feature en argument</strong> pour permettre à l'utilisateur de produire des évaluations dynamiques du phénotype. En effet, pour faire évoluer un système (un individu par exemple) il faut une notion de temps d'une manière ou d'une autre. L'horloge interne d'un individu (à sa naissance) \(t_0\) sera accessible à chaque individu.
   </p>

   <p>
       Il faudra définir un temps bien caractérisé (unité) qui sera utilisable par toutes les features et défini/initialisé à l'échelle du projet comme une variable globale. A réfléchir...
   </p>





    <h4 id="features-coupling">Créer des features à partir de features, à partir de features, à...</h4>

    <p>Une feature peut prendre en entrée (en argument)</p>
    <ul>
        <li> <strong> un et un seul support génétique</strong></li>
        <li>un support génétique, une ou plusieurs features, voir <a href="#general-model">ce schéma</a></li>
    </ul>

    <p>
        Voici une notion un peu plus avancée du modèle mais qui permet, je crois, de lui donner beaucoup d’intérêt et de puissance.
    </p>
    <p>
        Pour le moment, on peut définir des features, chacune interprétant l'expression d'un support génétique. C’est cool déjà, mais c’est embêtant car toutes ces features sont sagement <em>les unes à coté des autres, à s’ignorer mutuellement et à vivre leur vie</em> . En soi on peut laisser au soin de l’utilisateur de combiner les effets des features pour fabriquer de nouveaux mécanismes lui-même. Mais on peut aussi intégrer nativement cette possibilité dans notre bibliothèque, et créer de manière récursive et <em>infinie</em> des features à partir d’autres features.
    </p>
    <p>
        Créer un réseau de features pour fabriquer des nouvelles features, pour fabriquer des nouvelles features. Ainsi on peut créer du couplage entre supports génétiques et produire des phénotypes beaucoup plus intéressants. Voyons cela plus en détails, à partir d’un exemple concret.
    </p>

    <img src="./img/features-coupling-time" alt="" style="width: 100%;">

    <p>
        Sur le schéma ci dessus on a un cas de couplage qui fait intervenir le temps. On a une feature qui nous renvoie la taille de l'individu. Cette taille est fonction du temps, cette donnée est accessible en lecture et donnée par le système à toutes les features. Pour évaluer la taille d'un individu il faut évaluer cette feature. Cette feature est couplée à trois autres features : taille min qui donne une taille min encodée sur son support génétique, taille max idem, et taux de croissance.
    </p>

    <p>
        On a donc une feature taille qui pour être évaluée doit avant évaluer tout ses dépendances (on pourra optimiser cette étape, avec un cache et n'évaluer que si l'évaluation de cette feature a changé, notamment grâce à la gestion des mutations). Avec cette définition, quand j'évaluerai taille j'aurai toujours la bonne valeur, même si taux de croissance mute entre deux évaluations.
    </p>

    <p>
        Voici comment on peut coupler les features entre elles pour produire des nouvelles features, et créer autant de complexité qu'on le souhaite. On peut imaginer ici reproduire des features à la manière de composants informatiques, qui viennent éteindre et allumer l'expression d'autres features.
    </p>

    <p>
        Comme on peut le voir on se sert des valeurs générées précédemment par la feature pour retourner la taille. On accède à LOG, l'historique, et on récupère la dernière entrée avec <code>popValue()</code>  et <code>popTime()</code>. Le LOG est une <a href="https://fr.wikipedia.org/wiki/Pile_(informatique)">pile</a>, c'est une structure de données "Last In First Out".  Il est temps d'aborder un point important sur l'évaluation et les états d'un individu.
    </p>

    <h4 id="immutability">Les états et l'évaluation</h4>

    <p>C'est sans doute l'un des points les plus importants dans le design de ce modèle. Le phénotype d'un individu, le global (l'aggrégation de tous les phénotypes produits par les features) et le local (produit par une feature) <strong>est un état immutable</strong>. Le phénotype est lui aussi <strong>une valeur</strong>. </p>
        <p>
            Quand on veut connaître la taille d'un individu par exemple, on ne vient pas écraser ou mettre à jour la taille qu'il avait avant. On évalue la feature et elle nous renvoie une valeur. Cette valeur ne change pas dans le temps, la taille d'un individu ne change pas dans le temps : quand on la mesure on obtient des valeurs différentes à chaque instant. Quand on mesurait notre taille enfant en mettant une petite marque sur le mur, on n'effaçait pas la marque d'avant pour mettre la suivante, plus haute. On faisait une nouvelle marque ! Il sera toujours vrai, qu'à un moment donné vous étiez plus petit qu'aujourd'hui. En ce sens, votre taille n'est pas un état mutable. Vous avez plutôt effectué une mesure, et au cours du temps, cette mesure a renvoyé des valeurs différentes.
        </p>

        <p>
            C'est la même chose pour notre phénotype. Le phénotype n'a pas à être un état mutable, qu'on viendrait mettre à jour à chaque pas de temps. Non ! Le phénotype est <strong>un instantanée de l'évaluation de toutes les features d'un individu</strong>. Si je veux connaître la taille d'un individu, j'évalue sa feature taille et elle me renvoie une valeur. Cette valeur dépend du temps (mesurer deux fois la taille au même instant produit la même valeur). 
        </p>
        <p>
            Chaque feature, comme dans l'exemple ci-dessus, conserve un journal, un historique (un log) de toutes les valeurs qu'elle a produite quand on l'a évaluée. Ainsi, j'accède naturellement à l'histoire complète de mon individu. Je ne remplace pas la valeur taille, j'en créée un nouvelle à chaque fois que je fais la mesure. Ce log permet de calculer le présent en fonction du passé. Le présent (ou le futur) ne vient pas écraser le passé. 
        </p>

        <p>
            Il est hors de question pour notre feature d'avoir un état pour ces raisons. Une feature est une fonction qui produit des valeurs (en appelant d'autres features au besoin).
        </p>
        <p>
            Dans ce modèle, l'état mutable est justement le support génétique, sujet à des <em>mutations</em>. Dans toute cette bibliothèque le seul état mutable est le génome (exception faite de l'épigénétique, qui est d'ailleurs peut-être une mauvaise idée, ça peut être utile mais déconseillée à n'utiliser que dans des cas où c'est nécessaire)
        </p>

        <p>
            Pour résumer, <strong>le phénotype d'un individu est une valeur</strong> produite par les features à un instant donné. Les features n'ont pas d'état mutable (elles ne maintiennent pas un état, elle ne font pas d'assignment). Elles peuvent produire une valeur à partir d'une valeur produite dans le passé, c'est bien normal. Mais <strong>elles ne peuvent pas modifier le passé</strong>, elles peuvent juste y accéder en lecture, <strong>ce sont des faits</strong>. Chaque nouvelle entrée s'ajoute aux précédentes sans les modifier, aucune entrée ne peut pas être modifiée ou supprimée par la feature.  
        </p>
      

    <h5>Quelques exemples</h5>

    <h5>Feature présente mais cachée</h5>
   

    <p>Prenons l'exemple d'un d'un serpent. Il possède des gènes pour coder un pied, et d'autres gènes pour lui donner forme (nombre de doigts, pied palmé etc...). Dans la plupart du temps (phénotype dominant à l'état sauvage) il ne s'exprime pas. Dans son phénotype on ne trouve aucune expression du pied, et des traits propres au pied.  </p>
    <img src="./img/coupling-feature-on-off-ex2" style="width: 100%;" alt="">
    <p> Si une feature renvoie une valeur vide \(\{\}\) (ou une valeur définie par le système du genre 'required') toutes les features qui en dépendent ne peuvent plus s'exprimer et renvoient une valeur vide à leur tour. Le résultat est que le génome concerné ne s'exprime pas et que le phénotype n'est pas observé </p>
<p>Ces gènes ne s'activent que si l'allèle A s'exprime, comme ci-dessous. Si c'est le cas l'intégralité du génome du pied s'exprime et on trouve un phénotype</p>
    <img src="./img/coupling-feature-on-off-ex1" style="width: 100%;" alt="">
    <p>L'activation en cascade de toutes les features dépendantes est alors automatique dans le modèle.</p>


    <h5>Les features sont des API</h5>

<p>Les features sont des fonctions pures qui prennent en entrée une valeur et retourne une valeur. En ce sens tout leur comportement est défini par les arguments en entrée. Aussi on pourra fournir pour chacune d'entre elle, en fonction des contraintes qu'on imposera, une documentation des arguments acceptés et des sorties produites. Elles seront alors facilement testables de manière unitaire (isolées). Elles ont donc une <a href="https://fr.wikipedia.org/wiki/Interface_de_programmation">API</a> et il n'est pas utile de regarder dans le détail de leur code source pour s'en servir. La documentation pourra nous dire ce que chaque feature fait, de quelle feature elle dépend etc.. Et une fois définie (ou récupérée) on pourra l'utiliser comme une boîte noire dans notre projet, sans avoir à soulever le capot. </p>

    <h5>Une feature "Groupe de features"</h5>

    <p>
        Comme on l’a vu, on peut coupler des features pour faire des nouvelles features. Cela crée des dépendances entres features. Pour simplifier la vie de l’utilisateur on pourrait rajouter quelque chose de simple : faire des paquets de features. Au lieu d’évaluer chacune d’entre elles on en évalue qu’une qui renverra l ‘évaluation de toutes les features dont elle dépend. C’est juste une fonctionnalité pour faciliter la vie de l’utilisateur et simplifier l’usage de la bibliothèque.
    </p>
    <p>
        Par exemple, je crée tout un ensemble de features relatives à la possibilité de voler d’un animal : absence/présence d’ailes, taille des ailes, types ailes (a plume, mammifère), forme des ailes, couleurs des plumes, bruit que fond les ailes, vitesse en vol, vitesse de pointe etc... Toutes ces features sont reliées les unes aux autres. Par exemple s’il n’y a pas de plumes, il n'y a pas de couleur des plumes. Au lieu d’avoir à interroger manuellement chacune de ces features je pourrais créer une « méta-feature » qui s’appelle « vol » par exemple. Elle les comprendrait toutes. Cela donnerait une paquet prêt à l’emploi ds n’importe quel projet où je veux voir ce trait phénotypique exister. Ainsi dans le code au lieu d’avoir un truc du genre :
    </p>

    <code class="pseudo-code">
        <pre>
hasPlumage = evaluate(individu, ‘hasPlumage’)
plumageColors = evaluate(individu, ‘plumageColors’)
wingsSize = evaluate(individu, ‘wingsSize’)
etc.
//Then do logic
...
//A la place on aurait
vol = evaluate(individu, ‘vol’)
//vol contiendrait toutes les données :
//par ex : vol = {
    hasWings : true,
    hasPlumage : false,
    plumageColor : undefined,
    wingSize : {
        value : 52,
        dimension: 'length'
        unit : ‘cm’
    },
    speed : {
        value : 60 ,
        dimension: 'speed'
        unit : ‘km/h’
    }
    //Etc...
} 
        </pre>
</code>

<p>
    En ce sens, le phénotype global d'un individu (l'ensemble de ses traits), est la méta feature la plus globale
</p>
<code class="pseudo-code">
    <pre>
//evalue toutes les features d'un coup
phenotype = evaluate(individu)
    </pre>
</code>
 

<h4>Pour résumer :</h4>

<p>Pour créer une feature l'utilisateur doit</p>
<ul>
    <li>Lui donner un nom</li>
    <li>Lui donner ses sources (un support génétique, une ou plusieurs features). Ca définit ce qu'elle prend en entrée</li>
    <li>Si une source est un support génétique il doit associer une valeur à chaque allèle retournée par le support. Si la source est une feature il n'a rien à faire (l'entrée est définie par la valeur retournée par cette feature)</li>
    <li>Définir ce que la feature retourne (soit une stratégie, soit il implémente sa propre fonction)</li>
    <li>Si la valeur retournée est définie par une fonction écrite par l'utilisateur il doit en plus renseigner le schéma de la réponse(la structure des données renvoyée)</li>
</ul>

    <h3 id="espèces">Espèce</h3>


    <p>
        Une espèce est définie par un ensemble de features designées préalablement. Une feature peut être utilisée pour plusieurs espèces. A cela s’ajouteront des paramètres (à définir), des caractères irréductibles (non codés par du support génétique). Ces « méta paramètres »seront utiles pour le modèle (pour simplifier des choses).
    </p>




    <p class="question">
        Tout ce modèle est très «génétique centré», est ce qu’on pourrait imaginer des caractères non réductibles à l’expression du génome, à définir directement sur l’espèce (des méta caractères, épigénétique...)?
    </p>


    <h4>Paramètres</h4>

    <table>
        <thead>
            <tr>
                <th colspan="4">Feature</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Paramètre</th>
                <th>Description</th>
                 <th>Type</th>
                  <th>Contraintes</th>
            </tr>
        <tr>
                <td>Nom</td>
                <td>Un nom donné à l'espece</td>
                <td>String</td>
                 <td>Unique</td>
            </tr>
            <tr>
                <td>Features (nombre \(n_f\))</td>
                <td>Liste de features caractérisant l'espece. Chaque feature sélectionnée embarque avec elle son support génétique et ses dépendances</td>
                <td>Liste Features</td>
                 <td>Aucune</td>
            </tr>
            <tr>
                <td>Nombre de paires de chromosomes \(n_p\)</td>
                <td>Toutes les espèces sont diploïdes mais le nombre de paires de chromosomes peut être défini pour chaque espèce (brassage)</td>
                <td>Integer</td>
                 <td>Au moins un gène par chromosome, \(n_p \leq \sum_{i=1}^{n_f} N_i\)</td>
            </tr>
            <tr>
                <td>Placement des gènes sur les chromosomes</td>
                <td>Quel gène va sur quel chromosome. Éditeur permet de placer automatiquement, possibilité de le faire à la main, avec un éditeur Drag&Drop graphique.</td>
                <td>-</td>
                 <td>-</td>
            </tr>
            <tr>
                <td>Gènes non codant</td>
                <td>En plus des gènes codants, générer des séquences génétiques non codantes aléatoires (%, disposition etc..)</td>
                <td>-</td>
                 <td>-</td>
            </tr>
            <tr>
                <td>Type de reproduction</td>
                <td>Auto-fertilisation, clonage, reproduction sexuée</td>
                <td>String</td>
                 <td>Appartenir aux types de reproduction définie par le système</td>
            </tr>
            <tr>
                <td>Peut se reproduire avec d'autres espèces?</td>
                <td class="question">
                    Sous quelles conditions, comment ça marcherait ? Je ne souhaite pas que la notion d’espèce soit trop « cloisonnante », mais plutôt comme c’est en vrai, un concept aux contours évoluant avec le temps, « un flux ». C’est pratique pour programmer. En soi le modèle est piloté par des données donc tout est imaginable. On voudrait bien que des individus d’espèces différentes se croisent ! Sous quelles conditions (proximité génétique : valeur seuil de % génome commun ?) ? Quel génome résultant (chaque individu apporte tout ou une partie de ses features) ? Là ton regard pour être très précieux sur ces aspects pour imaginer des mécanismes.
                </td>
                <td>{booléan, proximité : Float}</td>
                 <td>??</td>
            </tr>
            <tr>
                <td>Autoriser Mutations</td>
                <td>
                    Choisir si le génome de l'espèce peut muter
                </td>
                <td>Boolean</td>
                 <td>Aucune</td>
            </tr>

            
        </tbody>
    </table>

    <h3 id="espèces">Population</h3>
    
    <p>
        On pourra définir des choses à l'échelle d'une population quand on utilisera la méthode <code>generatePopulation</code> pour créer une population initiale d'individus appartenant à une espèce.
    </p>
    <p class="question">
        Quoi donc imaginer/de quoi aurait on besoin à l'échelle d'une population?
    </p>

    <h2 id="mutations">Mutations</h2>

    <h3>Définition d'une mutation dans le modèle</h3>

    <p>
        Une mutation est une modification rare, accidentelle ou provoquée de l'information génétique dans le génome. Dans le modèle une mutation pourrait être
    </p>
    <ul>
        <li>code génétique d'une allèle : transition vers une autre allèle, vers une allèle mutante ou vers une allèle inerte (code inconnu)</li>
        <li class="question">relation entre deux allèles. Est ce raisonnable ? Dans la vraie vie il peut y avoir une mutation qui rend une allèle jusque la récessive tout d'un coup dominante?</li>
        <li>Apparition d'un nouveau gène codant pour une feature</li>
        <li>Disparition d'un nouveau gène codant pour une feature</li>
        <li>Disparition d'une allèle à la prochaine reproduction (remplacé par une allèle inerte</li>
        <li class="question">Autre idée?</li>
    </ul>
  

    <p>
        Le support génétique peut muter : par exemple un bit pourrait se décaler vers la gauche. Prenons un gène codé sur 8bits qui vaut initialement <code>00000001</code> (correspond à une allèle). Une mutation est déclenchée et un bit se décale) à <code>00000010</code> :

        <ul>
            <li>soit j'ai défini une allèle mutante en amont, pris en compte dans ma feature</li>
            <li>soit je n'ai pas associé de valeur. L'allèle sera évaluée à <code>'unknown'</code> ou sera inerte.</li>
        </ul>
    </p>


    <h3>Rôle des gènes non codants</h3>

    <p>
        On peut imaginer introduire des gènes non codants sur les chromosomes. Par exemple :
        $$...\color{grey}0000000\color{red}10000100\color{blue}11011110\color{grey}11001100... $$ 

    <ul>
        <li><span style="color:red;">Gène codant 1 allèle A </span></li>
        <li><span style="color:blue;">Gène codant 2 allèle B </span></li>
        <li><span style="color:grey;">Gène non codant </span></li>
    </ul>



</p>

<p>
    Maintenant on peut imaginer une forme de mutation où chaque bit se décale de 1 pas sur la gauche. Le résultat serait cette séquence (me suis peut être trompé c’est chiant à faire)
</p>

$$...\color{grey}0000001\color{red}00010011\color{blue}01111011\color{grey}10011001... $$ 
<ul>
    <li><span style="color:red;">Gène codant 1 allèle C (par exemple) </span></li>
    <li><span style="color:blue;">Gène codant 2 allèle inconnu (par exemple) </span></li>
    <li><span style="color:grey;">Gène non codant </span></li>
</ul>
On pourrait ainsi donner naturellement un rôle sympa aux séquences non codantes. Après je te laisse imaginer toutes les opérations cools de mutation qu’on peut faire par des opérations très simples sur les bits.
    </p>


    <p>
        Si l'on souhaite faire une simulation plus bas niveau seulement de brassage génétique et de mutations, en analysant le génome d'un individu sans lui donner du sens, on pourrait remplir leur génome que du matériel non codant. Et appliquer des mutations dessus à chaque génération.
    </p>

    <h3>Paramètres (à compléter/modifier)</h3>

    <p>
        Les mutations seront designées comme les supports génétiques, features et espèces.
    </p>

    <table>
        <thead>
            <tr>
                <th colspan="4">Feature</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Paramètre</th>
                <th>Description</th>
                 <th>Type</th>
                  <th>Contraintes</th>
            </tr>
        <tr>
                <td>Nom</td>
                <td>Un nom donné à la mutation</td>
                <td>String</td>
                 <td>Unique</td>
            </tr>      
            <tr>
                <td>Cible</td>
                <td>Qui vise-t-elle, Liste de support génétique, Chromosome entier</td>
                <td>Support génétique (Liste de gènes) ou Gène (codant ou non)</td>
                 <td>Au moins 1 gène visé</td>
            </tr>   
            <tr>
                <td>Action</td>
                <td>Que fait elle sur sa cible</td>
                <td>Proposer des actions : décalage, substitution(nombre de bits concernés), aléatoire, éteindre/allumer (en faisant muter vers une allèle du système défini comme 'unknown')  etc..</td>
                <td></td>
            </tr> 
            <tr>
                <td>Déclenchement</td>
                <td>Proposer des déclenchements automatiques</td>
                <td>Chaque reproduction, aléatoire, fréquence etc...</td>
                <td></td>
            </tr> 
            <tr>
                <td>Agressivité</td>
                <td>Permettre à la cible de résister ou non à la mutation. On définit un nombre de 0 à 100. On jette un dé, si le résultat est en dessus de ce nombre la mutation n'a pas lieu.</td>
                <td>Integer</td>
                <td>Entre 0 et 100 (arbitraire)</td>
            </tr>

        </tbody>
    </table>

    <p>
        Chaque mutation définit pourra être déclenchée automatiquement si elle a été configurée ainsi. Sinon l'utilisateur pourra toujours la déclencher manuellement quand il veut, en fonction des conditions de sa propre simulation(s'il simule un environnement par exemple), du genre
    </p>

    <code class="pseudo-code">
        <pre>
    //Déclenche manuellement une mutation
    mutation = triggerMutation('nomMutation')
    //Tous les individus concernés verront leur génome muter
        </pre>
    </code>
     
    <p>
        Chaque mutation sera loguée par le système.
    </p>

    <h3 id="epigenetique">Épigénétique</h3>

    <p>
        On pourrait introduire ici une notion  "épigénétique", avec des caractères héréditaires non encodés dans le génome sous la forme très simple d’un état transmissible (un ensemble de clé/valeurs) de génération en génération. Cet état mutable viendrait s'ajouter à l'état "génome" d'un individu.
    </p>
    <p>
        Cet état est accessible en écriture/lecture à des features spécifiques. Comme montré sur le schéma, une feature qui utiliserait cet état interne devrait le déclarer. En effet, on fait ici une exception à la règle d'or de notre design, que <a href="#immutability">les features sont des fonctions pures</a>. Une feature qui utiliserait l'état "épigénétique" cesserait d'être pure, elle produirait un effet de bord et changerait l'état du monde. Ce qui provoque des couplages indésirés entre features.
    </p>
    <p class="question">
        L'état épigénétique serait simplement une collection de clé:valeur mutables, et transmissible à la descendance. Quelles contraintes à mettre dessus ? Dans le cas d'une reproduction sexuée comment l'épigénétique de 2 parents se combinent pour être transmis ? Concaténation des clefs:valeurs? Est-ce vraiment une bonne idée (j'ai des doutes) ?s
    </p>


    <h2 id="analyse">Considérations démographiques</h2>

    <h3>Le modèle a une mémoire</h3>

    <p>
        L'intérêt de designer le modèle sous forme d'aggrégations de valeurs, et de composition de fonctions pures, c'est qu'on peut garder mémoire de tout ce qui s'est passé au cours du temps.
    </p>
    <p>
        On peut reconstruire <em>toute l'histoire</em> d'un individu à partir de son état initial (son génome), du temps et des logs des mutations ! En effet, vu que tout est valeur et que rien n'est remplacé sur place (sauf le génome mais on garde ses états précédents), et que toutes les features sont des fonctions pures, le système garde la mémoire de toutes les informations nécessaires pour re-dérouler le fil de l'histoire. On peut même obtenir des valeurs à des instants par lesquels n'est pas passée notre simulation.
    </p>
    <p>
        Regardons la puissance de cette approche (que je n'ai pas du tout inventé, beaucoup inspiré par Rich Hickey et notamment cette   <a href="https://www.youtube.com/watch?v=V6DKjEbdYos&t=3043s">conférence absolument géniale</a>) sur un exemple concret, un pseudo-code (je ne vais pas détailler pour le moment comment tout ça <em>exactement</em> va être implémenté mais c'est possible !)
    </p>
    <code class="pseudo-code">
        <pre>
    //At time t = 102
    history = getPhenotypes(t-50, t, t, individu)
    //history contient tous les phénotypes depuis t-50 à t
    //Say this individual is born at time t=10 of our simulation
    print(history) // = [ {t:101, phenotype:{...}}, 
                          {t:100, phenotype:{...}} 
                          ...
                          {t:10, phenotype:{...}} 
                          ]

    ...
    //All phenotype history between t-50 and t-10
    history = getPhenotypes(t-50, t-10, t, individu)
    //All phenotype history
    history = getPhenotypes(individu)
    //Phenotype at time t-30 only
    history = getPhenotype(t-30, t, individu)
        </pre>
    </code>

    <p>
        Imaginons qu'on n'ai jamais évalué une seule fois notre individu, aucun phénotype n'a été mesuré et mis en entrée dans les logs. Mais est ce un problème ? Comme on a logé toutes les mutations sur son génome (s'il y'en a eu), a partir du temps, de sa date de naissance et des dates et effets des mutations on peut <em>reconstruire toute son histoire</em> jusqu'au présent !
    </p>
    <p>
        Évidemment cette propriété est vraie aussi pour à chaque feature. On peut tracer l'histoire des valeurs mesurées d'une feature de la même manière
    </p>
    <code class="pseudo-code">
        <pre>
//At time t = 102. Get feature history from t-50 to now
featureHistory = getFeatureHistory(t-50, t, t, 
    individu, 'featureName')
        </pre>
    </code>

    <p>
        On n'est pas obligés de re-dérouler tout le fil de l'histoire jusqu'à la naissance de l'individu. On peut optimiser cette approche. On peut par exemple regarder s'il y a une évaluation de la feature à <code>t-50</code>. S'il y'en a une, c'est ok, s'il n'y en a pas on remonte un pas de temps en arrière jusqu'à ce qu'on tombe sur une valeur. Une fois qu'on a trouvé la valeur inférieure la plus proche (qui au minimum correspond à la naissance) on reproduit les valeurs manquantes jusqu'à <code>t-50</code> (en reproduisant le génotype de cette époque, puis les mutations au cours du temps, on refait l'histoire manquante). Ensuite on log cette valeur de la feature et on passe à la suivante, jusqu'à <code>t-50</code>. Et ainsi de suite. Comme ça, si on la redemande, elle sera déjà prête et il sera inutile de refaire le calcul.
    </p>

    <p>
        Si l'on souhaite utiliser le modèle pour faire des simulations et s'amuser à faire de la démographie, on aura naturellement accès à toute l'histoire de notre simulation
    </p>
    <ul>
        <li>Chaque feature log toutes ses évaluations</li>
        <li>Chaque support génétique log les mutations qu'il a subi et chaque mutation est loguée par le système quand elle a lieu</li>
        <li>Chaque individu généré disposera de ces logs et la simulation gardera en mémoire sa date de naissance et de mort</li>
    </ul>

    <p>
        Maintenant on peut faire cette remarque supplémentaire. On peut re-dérouler le fil de l'histoire mais on peut aussi décider, à un moment dans le passé de changer l'histoire ! Comme dans <em>La Vie est Belle</em> de Stephen Jay Gould on peut se poser la question "Est-si on avait mis une petite pichenette ici, est ce que ces espèces seraient encore là aujourd'hui ?" et y répondre ! Car on dispose de tout ce qu'il faut pour re-dérouler le fil de l'histoire et changer une chose, mettre une pichenette, et regarder les deux <em>mondes</em> évoluer vers leurs propres attracteurs.
    </p>
    <p>
        Comment c'est possible ? Et bien c'est très simple : il suffit de récupérer un phénotype dans le passé d'un individu comme on l'a vu précédemment. On dispose non seulement de son phénotype mais également de son génome, sa valeur à cet instant ! Il suffit alors de dupliquer notre individu et de lui assigner ce phénotype <em>du passé</em>. Du point de vue de notre modèle, nous avons là un clone parfait de l'individu à un instant dans le passé. Si l'environnement peut être reproduit à l'identique, on peut lui faire subir une mutation, le mettre un peu plus à gauche ou à droite que sais-je, et observer la divergence des deux lignes de vie. Les possibilités sont grandes ! Et on peut évidemment faire tout ça à l'échelle d'une population : )  
    </p>

    <p>
        Ce qui est intéressant avec ce système de mémoire, c'est qu'on va pouvoir répondre à des questions intéressantes dans notre programme, prendre des décisions sur le passé. Par exemple on pourra écrire une fonction qui dira "si tel individu, entre telle année et telle année n'a pas dépassé cette taille là, n'a pas eu cette couleur, n'a pas synthétisé 10L de telle molécule... alors...".
    </p>


    <h2>Hacker le modèle</h2>

    <p>Il y aurait plein de façons de hacker, de détourner de son usage principal, le modèle pour créer des nouveaux mécanismes au delà des phénotypes et du génome. On pourrait imaginer des features qui ne prennent pas du tout en compte le génome (même indirectement). Et étendre le système d'évaluation dans le temps et de mémoire à des traits non génétiques (opinion politique, goût, caractère, état d'esprit...)</p>


    <h2 id="engine">Moteur : reproduction et transmission du génome</h2>

    <h3>Auto-fertilisation</h3>
    <h3>Clonage</h3>
    <h3>Reproduction Sexuée</h3>
    <h3>Reproduction entre espèces</h3>

    <h2>Modèle reproduction</h2>
    <h3>Méiose</h3>
    <h3>Cross-over</h3>
    <h3>Mitose</h3>


    <h2>Génération d'une documentation interactive automatique</h2>

    <p>Générer une documentation automatiquement décrivant l'API de chaque Feature dans un projet donné. Cette documentation aidera grandement l'utilisateur a desiger ses modèles de données et aussi à les utiliser dans son propre programme.</p>


    <h2>Usage de la bibliothèque (dans les grandes lignes)</h2>
    <p>La bibliothèque sera open-source (évidemment). Le code sera accessible depuis un dépot public. Le code source sera découpé en au moins deux composants:</p>
    <ul>
        <li>code source moteur de la lib (tout ce qui fera tourner le modèle)</li>
        <li>code source des éditeurs, générateur doc, bac à sable</li>
    </ul>
    <p>On pourra imaginer à terme de faire des éditeurs et du bac à sable une web app: éditeur en ligne, création d'une store où les gens peuvent partager leur design et les télécharger (création d'une communauté). Chaque design aura sa doc.</p>

    <p>En tant qu'utilisateur je veux intégrer cette library pour mon projet :</p>
    <ul>
        <li>Je l'installe (avec ses dépendances) dans mon projet (sûrement via npm ou yarn). J'importe seulement le moteur dans mon projet</li>
        <li>Soit:
            <ul>
                <li>j'ai envie de créer mes propres design ou éditer design existants, je lance les éditeurs et je travaille dessus. Quand je suis satisfait, que j'ai testé dans le bac à sable j'exporte les données (sous format d'un fichier). Les données comprennent: les supports génétiques, les features, les espèces, les mutations etc...</li>
                <li>j'ai pas envie d'en faire moi même, d'autres gens en ont peut etre fait des mieux qui me correspondent ou pourraient me servir de base. Je récupère un design de quelqu'un (un fichier) (téléchargable en ligne sur le store), je l'importe, je l'édide et je l'exporte.</li>
            </ul>
        </li>
        <li>J'importe mes fichiers de design dans mon projet</li>
        <li>Je fabrique sûrement un fichier de configuration global demandé par la bibliothèque pour initialiser des choses (sécurité, gestion du temps, gestion des erreurs, generation pop, blabblabla...)</li>
        <li>J'utilise le tout pour fabriquer mon programme !</li>
    </ul>

    <p>Voici un pseudo code de l'utilisation de la bibliothèque (juste pour donner une idée)</p>


<code class="pseudo-code">
        <pre>
 import * as glib from "moteur"

 //Je crée une population initiale  de 50 individus, 
 //de l'espece 'espece#1' que j'ai designé
 const population = glib.generatePopulation('espece#1', 50)
 ...
 //Mon programme arrive à un point
 //où je veux déclencher une mutation designée
 const result = glib.triggerMutation('nomMutation') 
 ...
 //Deux individus se reproduisent et donnent une descendance de 10 individus:
 const offspings = glib.reproduce(individu1,individu2, 10)
 ...
 //Une fleur s'autoféconde pour fabriquer un nombre aléatoire de descendants
 const flowers = glib.reproduce(flower, random(10,100))
 ...
 //Deux individus se reproduisent, le nombre de descendant 
 //est borné par une feature 'capaciteGestation'
 const offspings = glib.reproduce(individu1,individu2, 
 random(1, get_phenotype(individu2,'capaciteGestation')))
 ...
 const killed = glib.kill(population)
 ...
//j'ai déjà ma propre structure de données/objet
//Fish avec son comportement
const fish = new Fish('toto')
console.log(fish) // = {toto:'foo'}
//je veux qu'il puisse se reproduire, le rendre
//genetique
fish = glib.setSpecie(fish, 'espece#1')
//fish dispose maintenant de toutes les features
//de l'espce#1 et peut se reproduire
const babyFish = glib.reproduce({fish, args: {bar}},fish2)
//babyFish a conservé tout ce dont il hérite
//de sa structure originelle
console.log(babyFish) // = {toto:'bar', phenotype: {....}} 
        </pre>
    </code>

    <h2>Exemples : reproduction de cas connus</h2>

    <h3>Lapins</h3>
    <h3>Snapdragons (dominance incomplète)</h3>
    <h3>Groupe sanguin chez l'Homme (codominance)</h3>

                    </div> <!-- row -->
                </div>
            </div> <!-- row -->
        </div>
    </section>



    <!--====== FOOTER PART START ======-->

    <section class="footer-area footer-dark">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-lg-6">
                    <div class="footer-logo text-center">
                        <a class="mt-30" href="index.html"><img src="assets/images/logo.svg" alt="Logo"></a>
                    </div> <!-- footer logo -->
                    <div class="footer-support text-center">
                        <span class="mail">paul.schuhm@gmail.com</span>
                    </div>
                    <div class="copyright text-center mt-35">
                        <p class="text">Designed by <a href="https://uideck.com" rel="nofollow">UIdeck</a> </p>
                    </div> <!--  copyright -->
                </div>
            </div> <!-- row -->
        </div> <!-- container -->
    </section>

    <!--====== FOOTER PART ENDS ======-->

    <!--====== BACK TOP TOP PART START ======-->

    <a href="#" class="back-to-top"><i class="lni lni-chevron-up"></i></a>

    <!--====== BACK TOP TOP PART ENDS ======-->

    <!--====== PART START ======-->

    <!--
    <section class="">
        <div class="container">
            <div class="row">
                <div class="col-lg-">
                    
                </div>
            </div>
        </div>
    </section>
-->

    <!--====== PART ENDS ======-->




    <!--====== Jquery js ======-->
    <script src="assets/js/vendor/jquery-1.12.4.min.js"></script>
    <script src="assets/js/vendor/modernizr-3.7.1.min.js"></script>

    <!--====== Bootstrap js ======-->
    <script src="assets/js/popper.min.js"></script>
    <script src="assets/js/bootstrap.min.js"></script>

    <!--====== Slick js ======-->
    <script src="assets/js/slick.min.js"></script>

    <!--====== Magnific Popup js ======-->
    <script src="assets/js/jquery.magnific-popup.min.js"></script>

    <!--====== Ajax Contact js ======-->
    <script src="assets/js/ajax-contact.js"></script>

    <!--====== Isotope js ======-->
    <script src="assets/js/imagesloaded.pkgd.min.js"></script>
    <script src="assets/js/isotope.pkgd.min.js"></script>

    <!--====== Scrolling Nav js ======-->
    <script src="assets/js/jquery.easing.min.js"></script>
    <script src="assets/js/scrolling-nav.js"></script>

    <!--====== Main js ======-->
    <script src="assets/js/main.js"></script>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</body>

</html>