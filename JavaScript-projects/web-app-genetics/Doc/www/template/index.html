<!doctype html>
<html class="no-js" lang="en">

<head>
    <meta charset="utf-8">

    <!--====== Title ======-->
    <title>Modele Design</title>

    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--====== Favicon Icon ======-->
    <link rel="shortcut icon" href="" type="image/png">

    <!--====== Magnific Popup CSS ======-->
    <link rel="stylesheet" href="assets/css/magnific-popup.css">

    <!--====== Slick CSS ======-->
    <link rel="stylesheet" href="assets/css/slick.css">

    <!--====== Line Icons CSS ======-->
    <link rel="stylesheet" href="assets/css/LineIcons.css">

    <!--====== Bootstrap CSS ======-->
    <link rel="stylesheet" href="assets/css/bootstrap.min.css">

    <!--====== Default CSS ======-->
    <link rel="stylesheet" href="assets/css/default.css">

    <!--====== Style CSS ======-->
    <link rel="stylesheet" href="assets/css/style.css">

</head>

<body>
    <!--[if IE]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->

    <!--====== PRELOADER PART START ======-->

    <div class="preloader">
        <div class="loader">
            <div class="ytp-spinner">
                <div class="ytp-spinner-container">
                    <div class="ytp-spinner-rotator">
                        <div class="ytp-spinner-left">
                            <div class="ytp-spinner-circle"></div>
                        </div>
                        <div class="ytp-spinner-right">
                            <div class="ytp-spinner-circle"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!--====== PRELOADER PART ENDS ======-->

    <!--====== NAVBAR TWO PART START ======-->

    <section class="navbar-area">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <nav class="navbar navbar-expand-lg">



                        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTwo"
                            aria-controls="navbarTwo" aria-expanded="false" aria-label="Toggle navigation">
                            <span class="toggler-icon"></span>
                            <span class="toggler-icon"></span>
                            <span class="toggler-icon"></span>
                        </button>

                        <div class="collapse navbar-collapse sub-menu-bar" id="navbarTwo">
                            <ul class="navbar-nav m-auto">
                                <li class="nav-item active"><a class="page-scroll" href="#home">home</a></li>
                            </ul>
                        </div>

                        <div class="navbar-btn d-none d-sm-inline-block">
                            <ul>

                            </ul>
                        </div>
                    </nav> <!-- navbar -->
                </div>
            </div> <!-- row -->
        </div> <!-- container -->
    </section>

    <!--====== NAVBAR TWO PART ENDS ======-->

    <!--====== SLIDER PART START ======-->

    <section id="home" class="slider_area">
        <div id="carouselThree" class="carousel slide" data-ride="carousel">
            <ol class="carousel-indicators">
                <li data-target="#carouselThree" data-slide-to="0" class="active"></li>
                <li data-target="#carouselThree" data-slide-to="1"></li>
                <li data-target="#carouselThree" data-slide-to="2"></li>
            </ol>

            <div class="carousel-inner">
                <div class="carousel-item active">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-6">
                                <div class="slider-content">
                                    <h1 class="title">Modèle Génétique</h1>
                                    <p class="text">Du génome au phénotype, d'un individu à une population</p>
                                </div>
                            </div>
                        </div> <!-- row -->
                    </div> <!-- container -->
                    <div class="slider-image-box d-none d-lg-flex align-items-end">
                        <div class="slider-image">
                            
                        </div> <!-- slider-imgae -->
                    </div> <!-- slider-imgae box -->
                </div> <!-- carousel-item -->

                <div class="carousel-item">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-6">
                                <div class="slider-content">
                                    <h1 class="title">Modèle démographique</h1>
                                    <p class="text">Remontez dans le temps, changez le cours de l'histoire</p>
                                </div> <!-- slider-content -->
                            </div>
                        </div> <!-- row -->
                    </div> <!-- container -->
                    <div class="slider-image-box d-none d-lg-flex align-items-end">
                        <div class="slider-image">
                          
                        </div> <!-- slider-imgae -->
                    </div> <!-- slider-imgae box -->
                </div> <!-- carousel-item -->

                <div class="carousel-item">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-6">
                                <div class="slider-content">
                                    <h1 class="title">Modèle fonctionnel</h1>
                                    <p class="text">Tout est ici valeurs et fonctions pures (ou presque)</p>
                                </div> <!-- slider-content -->
                            </div>
                        </div> <!-- row -->
                    </div> <!-- container -->
                    <div class="slider-image-box d-none d-lg-flex align-items-end">
                        <div class="slider-image">
                           
                        </div> <!-- slider-imgae -->
                    </div> <!-- slider-imgae box -->
                </div> <!-- carousel-item -->
            </div>

            <a class="carousel-control-prev" href="#carouselThree" role="button" data-slide="prev">
                <i class="lni lni-arrow-left"></i>
            </a>
            <a class="carousel-control-next" href="#carouselThree" role="button" data-slide="next">
                <i class="lni lni-arrow-right"></i>
            </a>
        </div>
    </section>

    <!--====== SLIDER PART ENDS ======-->

    <!--====== FEATRES TWO PART START ======-->

    <section id="services" class="features-area">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-lg-10 col-md-10">
                    <div class="section-titlepb-10">

                        <p>22/02/2021</p>
                        <h2 id="ce-quon-fabrique">Qu'est ce qu'on cherche à faire ?</h2>
                        <p>Construire une bibliothèque que n’importe qui peut installer et utiliser dans ses propres
                            projets informatiques. Cette bibliothèque est constituée d’un moteur (un ensemble de
                            fonctions implémentant le modèle) ainsi que de données (avec un format bien défini)
                            exportables. Ainsi, les utilisateurs pourront partager leurs design entre
                            eux (features, especes) et une communauté
                            <em>pourrait</em> se former construisant par itération des designs de plus en plus élaborés.
                            </p>
                        <p>Pour permettre cela tout en étant <em>user-friendly</em> des éditeurs avec interface
                            graphique seront développés :</p>
                        <ul>
                            <li>Un éditeur de <a href="#support-g%C3%A9n%C3%A9tique">support génétique</a></li>
                            <li>Un éditeur de <a href="#features">traits phénotypiques</a></li>
                            <li>Un éditeur de <a href="#mutations">mutations</a></li>
                            <li>Un éditeur d’<a href="#esp%C3%A8ces">espèces</a></li>
                            <li>Un éditeur d’<a href="#environment">environnement</a></li>
                            <li>Un bac à sable pour tester et explorer rapidement ses designs</li>
                            <li>Un générateur de documentation desenvironment allèles et features de chaque espèce dans lequel il
                                sera facile de chercher (nom, données retournées par une feature etc...)</li>
                        </ul>
                        <p>Les éditeurs permettront d’éditer, importer, exporter, dupliquer, supprimer, ces 3 type de
                            données facilement. Ces données seront ensuite importées dans le projet informatique de
                            l’utilisateur et celui-ci, après import du moteur, pourra faire tourner le modèle dans le
                            but qu’il s’est fixé.</p>
                        <h2 id="objectifs">Objectifs</h2>
                        <p>S’amuser. Fournir un moteur permettant de simuler des entités (biologiques ou non) possédant
                            des phénotypes <strong>interprétables par
                                l’utilisateur</strong>. Le phénotype de chaque individu résulte de l’évaluation d’un
                            support génétique (principalement). Les entités pourront se reproduire et transmettre à leur
                            descendance leur génome pour créer de l’hérédité, de la filiation (et de
                            l’histoire). Ce génome pourra également être soumis à des mutations et évoluer.
                            L’utilisateur pourra alors facilement simuler de la sélection et des populations au cours du
                            temps dans son propre projet. Les espèces pourront muter, les populations évoluer etc. En
                            somme, un gros bac à sable. Ce modèle pourrait avoir des ambitions plus générales. Car s’il
                            vise principalement à simuler <em>de la vie</em>, le moteur pourrait être appliqué à
                            d’autres <em>objets</em>. On peut penser par exemple à faire une filiation de langues (en
                            utilisant des méthodes de <a href="https://fr.wikipedia.org/wiki/Philologie">philologie
                                comparée</a> comme a pu le faire (sérieusement) Tolkien : utiliser des règles
                            spécifiques de mutation qui permette de passer d’un mot ancêtre à un mot descendant et vice
                            versa). En fait tout ce qui est sujet à itérations successives, tout objet qui« produit du
                            nouveau a partir de lui même » pourrait être simulé.</p>
                        <h2 id="contraintes">Contraintes</h2>
                        <p>La contrainte forte du modèle c’est qu’il faut définir à l’avance des traits phénotypiques
                            auxquels l’utilisateur pourra donner <strong>du sens</strong>. J’insiste là dessus car le
                            but est de pouvoir <strong>interpréter fonctionnellement le phénotype pour prendre des
                                décisions.</strong> Ce que j’entends par là c’est que si une espèce possède un trait
                            phénotypique qui renvoie la valeur ‘foo’ il faut que cette valeur <strong>puisse</strong>
                            (pas nécessairement) avoir un sens pour l’utilisateur dans son programme, qu'elle puisse être anticipée. En ce sens, le réservoir de phénotypes
                            possibles doit <em>pouvoir</em> être contrôlé.</p>
                        <h2 id="composants-à-développer">Composants à développer</h2>
                        <p><img src="./img/composants.png" alt="Composants"><br>
                            Le projet se compose des composants suivants à concevoir et développer :</p>
                        <ul>
                            <li>Les structures de données :
                                <ul>
                                    <li>Support génétique</li>
                                    <li>Feature (traits phénotypiques)</li>
                                    <li>Mutation</li>
                                    <li>Espèce</li>
                                </ul>
                            </li>
                            <li>Les éditeurs graphiques (web) pour les éditeurs de données:</li>
                            <li>Un bac à sable pour aider à prototyper et tester ses designs</li>
                            <li>Le moteur (toutes les fonctions, dépendances qui implémentent le modèle)</li>
                        </ul>
                        <p>Les structures de données seront complexes et un éditeur graphique pour les manipuler sera
                            indispensable. Ces éditeurs permettront d’importer et d’exporter les données
                            facilement, de les éditer, dupliquer, supprimer. Le modèle est <em>piloté par les
                                données</em>, ces structures sont capitales et doivent être manipulées et définies de
                            manière rigoureuses.</p>
                        <h2 id="aperçu-général-du-modèle-génétique--du-génome-au-phénotype">Aperçu général du modèle
                            génétique : du génome au phénotype</h2>
                        <p>L’utilisateur de la bibliothèque pourra faire évoluer des populations d’individus et
                            évaluer les traits de chaque individu afin d'appliquer le traitement qu’il souhaite. Ces
                            traits seront l’expression d’un génome <strong>diploïde</strong> porté par chaque individu,
                            transmissible par reproduction sexuée, auto-fécondation ou clonage de génération en génération.</p>
                        <p>Le <em>support génétique</em> (encodé en binaire) lorsqu’il est évalué produit une valeur.
                            Cette valeur est ensuite interprétée par une <em>feature</em> qui produit à son tour une
                            valeur auquel l’utilisateur donne une dimension et une unité de mesure. L’expression de la feature est alors
                            remontée dans le phénotype. La valeur en sortie d’une feature peut servir d’entrée à une autre
                            <em>feature</em> et ainsi de suite. Ainsi, le phénotype forme une collection de couples
                            <code>{nomFeature, {valeur, dimension, unité}}</code>, résultat de l’évaluation d'un réseau de features (possiblement)
                            interdépendantes, fondé sur un support génétique. </p>


                        <img id="general-model" class="modele-img" src="./img/modele-general.png" alt="Modèle général">


                        <p>Lors de la reproduction ou du clonage, le support génétique est transmis à l’aide de
                            mécanismes connus de la biologie (mais nécessairement simplifiés) : mitose, méiose.</p>
                        <p>Le support génétique pourra être exposé à des mutations. Chaque individu disposera en plus de
                            son support génétique d’un état interne modélisant les effets <em>épigénétiques</em>. Cet
                            état supplémentaire, non encodé dans le génome, pourra modéliser la transmission de
                            caractères acquis.</p>
                        <h2 id="notations">Notations</h2>
                        <ul>
                            <li> \(a-B\) : allèles a et B sur le même locus d’une paire de chromosomes analogues. a est
                                récessif et B est dominant</li>
                            <li> \((a-B)(a-c)(B-B)\) : ensemble de couples d'allèles sur 3 gènes d’une paire de
                                chromosomes analogues. L'ordre des couples n'a pas d'importance</li>
                        </ul>

                        <h2 id="les-modèles-de-données">Les modèles de données</h2>
                        <h3 id="support-génétique">Support génétique</h3>
                        <p>Un support génétique est une séquence en binaire (de 0 et de 1) </p>
                        <table>
                            <thead>
                                <tr>
                                    <th colspan="4">Support génétique</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <th>Paramètre</th>
                                    <th>Description</th>
                                    <th>Type</th>
                                    <th>Contraintes</th>
                                </tr>
                                <tr>
                                    <td>Nom</td>
                                    <td>Un nom donné au support</td>
                                    <td>String</td>
                                    <td>Unique</td>
                                </tr>
                                <tr>
                                    <td>Nombre de gènes <code>N</code></td>
                                    <td>Nombre de gènes contribuant à la valeur du support</td>
                                    <td>Integer</td>
                                    <td>\( N \ge 1\)</td>
                                </tr>
                                <tr>
                                    <td>Nombre de bits <code>n</code></td>
                                    <td>Nombre de bits sur lequel est encodé chaque gène du support : l’utilisateur
                                        pourra choisir d’encoder des gènes sur des structures allant de 1 à 8 bits
                                        (limite arbitraire). Ce paramètre défini par défaut le nombre de variations d’un
                                        même gène (allèles) accessibles. Par exemple, sur un support à 2 bits on a 4
                                        valeurs possibles : 00 (0), 01 (1), 10 (2) et 11 (3). On a donc, au maximum 4
                                        allèles pour ce gène dans notre « réservoir ». Sur 8 bits on a 256 valeurs
                                        possibles, donc 256 allèles possibles pour un même gène. La structure binaire
                                        est suffisante pour créer assez de variations (pas besoin de 4 caractères AGCT).
                                    </td>
                                    <td>Integer</td>
                                    <td>\( 1 \le n \le 8 \)</td>
                                </tr>
                                <tr>
                                    <td>Rareté d'une allèle \(r\)</td>
                                    <td>Sur les allèles disponibles on peut définir une rareté, un nombre qui sert au
                                        moment de la génération de populations. Ce nombre permettra de définir chance
                                        qu'un individu généré (non issu d'une reproduction) porte cet allèle
                                        initialement. </td>
                                    <td>Float</td>
                                    <td>\( 0 \le r \le 1 \)</td>
                                </tr>
                                </tr>
                                <tr>
                                    <td>Allèles disponibles <code>n<sub>a</sub></code></td>
                                    <td>Le réservoir d'allèles disponibles est par définition définie par le nombre de
                                        bits sur lequel est encodé un gène. L’utilisateur pourra décider de n’utiliser
                                        qu'un sous-ensemble de ce réservoir s’il le souhaite. <strong>Une allèle est une
                                            valeur</strong> possible d'un gène. Elle peut donc muter dans l'espace
                                        défini par le gène vers une autre valeur. </td>
                                    <td>(Integer...)</td>
                                    <td>\( 1 \le n_a \le N^{2} \)</td>
                                </tr>
                                <tr>
                                    <td>Relations entre allèles <code>U</code></td>
                                    <td>Tableau de coefficients dont chaque valeur permet de calculer la contribution de
                                        chacune des 2 allèles du même gène à l’évaluation du support génétique.
                                        L’utilisateur pourra générer ces coefficients de manière aléatoire ou suivant
                                        des règles prédéfinies, ou les écrire manuellement (il y a toujours le contrôle
                                        total si on le souhaite).</td>
                                    <td>[Float]</td>
                                    <td>
                                        \( n_a(n_a+1)/2\) coefficients nécessaires pour évaluer toutes les combinaisons
                                        possibles, voir <a href="#table-genetic-support-summary">ce tableau</a>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <p>Pour résumer, l’évaluation d’un support génétique (et la production d’une valeur) se fait en
                            évaluant pour chacun de ses gènes la paire d’<a
                                href="https://fr.wikipedia.org/wiki/All%C3%A8le">allèles</a> (une allèle sur chaque <a
                                href="https://fr.wikipedia.org/wiki/Chromosome_homologue">chromosome homologue</a>)
                            correspondante. Les relations entre allèles permettent de calculer la
                            <strong>valeur</strong> du support génétique.</p>



                            <h4>Dominat/Récessif, dominance incomplète et codominance</h4>
<p>
    <a href="https://fr.wikipedia.org/wiki/All%C3%A8le#Relations_entre_all%C3%A8les">Plusieurs relations entre allèles</a> existent. Le modèle se propose de modéliser 3 d'entre elles :

</p>


   <ul>
       <li><strong>Dominant/récessif :</strong>  un allèle récessif demande l'homozygotie d'un gène pour pouvoir s'exprimer. Autrement dit, soit \(a-B\) deux allèles du même gène, a est récessif (et B est dominant) si  \(u(a,B)=0\). Ce gène est évalué à \(B\)</li>
       <li><strong> Dominance incomplète :</strong> aucun des allèles qui déterminent le caractère est dominant, les deux s'expriment et le caractère est un mélange des deux contributions. Autrement dit, soit \(a-b\) deux allèles du même gène, a et b ont une dominance incomplète si  \( u(a,b) \in  \left] 0 : 1\right[ \). Ce gène est évalué à {\(A: u(a,b), B: 1-u(a,b)\)}. En ce sens, le modèle Dominant/récessif n'est qu'un cas particulier de dominance incomplète.</li>
       <li><strong>Codominance :</strong>  les deux allèles s'expriment en même temps, et le trait est l'expression conjointe des deux allèles.Autrement dit, soit \(A-B\) deux allèles du même gène, il faut donner au coefficient une valeur distincte pour prendre en compte ce cas. On pose par définition la valeur \(u(A,B)=-1\) pour symboliser ce cas. L'évaluation du gène retourne la valeur \(AB\). Dans ce cas, deux allèles peuvent produire 3 valeurs distinctes : A , B et AB  </li>

       <li><strong>Allèle inerte :</strong>on verra à la section sur <a href="#mutations">les mutations</a> qu'une allèle peut devenir inerte, c'est à dire qu'elle n'exprime plus rien. Une allèle inerte est toujours récessive, si deux allèles inertes sont sur le même gène le gène ne renvoie aucune évaluation.</li>
       <li><strong>Allèle létale :</strong>: si cette allèle s'exprime l'individu meurt</li>
   </ul>

   
<p>
    Voici un tableau résumant les valeurs prises par les coefficients pour chaque type de relation entre allèles, ainsi que le résultat de l'évaluation d'un gène \(A-B\). L'évaluation produit un ensemble clé:valeur noté \( \{ A: w_A , B: w_B \} \) où \(A\) est l'identifiant de l'allèle A et \(w_A\) son poids dans l'expression du gène. Si le poids est nul l'allèle n'est pas exprimé, s'il est égal à 1 on écrira \( \{ A: 1 \}  \equiv \{ A\} \equiv A \). S'il n'y qu'un gène on pourra écrire  \( \{ A\} \equiv A \)
</p>
   <table id="table-genetic-support-summary">
    <thead>
        <tr>
            <th colspan="5">Supports génétiques</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Relation</td>
            <td>Valeurs du coefficient</td>
            <td>Evaluation</td>
        </tr>
        <tr>
            <td>Dominant/Récessif</td>
            <td>\(u(A,B) \in \{0 , 1\}\)</td>
            <td>\( A \) ou \( B \) </td> 
        </tr>
        <tr>
            <td>Dominance incomplète</td>
            <td>\(u(A,B) \in \left]0:1\right[\)</td> 
            <td>\( \{ A: u(A,B) , B: 1-u(A,B) \} \)</td>  
        </tr>
        <tr>
            <td>Codominance</td>
            <td>\(u(A,B) = -1\)</td> 
            <td>\( \{ AB: 1 \}\)</td>  
        </tr>
        <tr>
            <td>Allèle inerte \(A\)</td>
            <td>\(u(A,B) = 0, \forall B\)</td> 
            <td>\( \{ B: 1 \}\)</td>  
        </tr>
        <tr>
            <td>Allèles inertes \(A\) et \(B\) </td>
            <td>\(u(A,B) = u(B,A) = 0\)</td> 
            <td>\( \{ \}\)</td>  
        </tr>
    </tbody>
</table>

<p>
    La valeur d'un allèle est son code binaire (ou un alias pour ce code). La valeur et le sens seront défini au niveau d'une <a href="#features">feature</a>. Soit un gène codé sur 1 bit avec \(A \equiv 0\) et \(B \equiv 1\). Si le gène mute de 0 à 1, la valeur du gène passe de A à B.
</p>


    <h4 id="exemple--support-génétique-continu">Exemple 1 :</h4>
    <p>Prenons un support génétique :</p>
    <ul>
    <li>codé sur 3 gènes</li>
    <li>chaque gène est codé sur 2 bits</li>
    <li>Allèles disponibles : toutes, soit
    <ul>
    <li>00 ( A )</li>
    <li>01 ( B )</li>
    <li>10 ( C )</li>
    <li>11 ( D )</li>
    </ul>
    </li>
    </ul>
    <p>Initialisons le tableau des relations entre allèles :</p>
    <div class="center-container">
    <table>
        <tbody>
            <tr>
                <td></td>
                <td>A</td>
                 <td>B</td>
                <td>C</td>
                 <td>D</td>
            </tr>
            <tr>
                <td>A</td>
                <td>1</td>
                 <td>0.3</td>
                <td>0.7</td>
                 <td>1</td>
            </tr>
              <tr>
                <td>B</td>
                <td>-</td>
                 <td>1</td>
                <td>0.2</td>
                 <td>0.4</td>
            </tr>
            <tr>
                <td>C</td>
                <td>-</td>
                 <td>-</td>
                <td>1</td>
                 <td>0.5</td>
            </tr>
             <tr>
                <td>D</td>
                <td>-</td>
                 <td>-</td>
                <td>-</td>
                 <td>1</td>
            </tr>
        </tbody>
    </table>
</div>

<p>On a par définition</p>
    $$u(A,B) = 1 - u(B,A) $$ 
    <p>si A et B ne sont pas codominants ou tous les deux inertes. Pour le cas de codominance on a défini une valeur arbitraire</p>
    $$u(A,B) = u(B,A) = -1 $$ 

<p>On peut noter que l'allèle D est récessif vis à vis de A qui est dominant. Dans tous les autres rapports d'allèles nous sommes dans un cas de dominance incomplète. Évaluons à présent un individu qui posséderait un support génétique initialisé comme suit :</p>
$$(a-b)(c-b)(a-d)$$

<p>L’individu est <a href="https://fr.wikipeda.org/wiki/H%C3%A9t%C3%A9rozygote">hétérozygote</a> pour chacun des 3 gènes. L'évaluation du support génétique donne </p>

    $$ v = \{ A:1.3, B:0.9, C:0.8 \}$$
   
<p>On peut voir que si le support génétique est constitué de plusieurs gènes il suffit d'ajouter les contributions de chaque gène.</p>

    <h4>Exemple 2</h4>

    <p>Reprenons le même support génétique :</p>
    <ul>
    <li>codé sur 3 gènes</li>
    <li>chaque gène est codé sur 2 bits</li>
    <li>Allèles disponibles : 3 sur les 4 disponibles, soit
    <ul>
    <li>00 ( A )</li>
    <li>01 ( B )</li>
    <li>10 ( C )</li>
    </ul>
    </li>
    </ul>
    <p>Construisons un autre tableau de relations entre allèles :</p>
    <div class="center-container">
    <table>
        <tbody>
            <tr>
                <td></td>
                <td>A</td>
                 <td>B</td>
                <td>C</td>
            </tr>
            <tr>
                <td>A</td>
                <td>1</td>
                 <td>-1</td>
                <td>1</td>
            </tr>
              <tr>
                <td>B</td>
                <td>-</td>
                 <td>1</td>
                <td>0.5</td>
            </tr>
            <tr>
                <td>C</td>
                <td>-</td>
                 <td>-</td>
                <td>1</td>
            </tr>
        </tbody>
    </table>
</div>

<p> Évaluons à présent un individu qui posséderait un support génétique initialisé comme suit :</p>
$$ (C-B)(A-C)(A-B) $$


<p>L’individu est <a href="https://fr.wikipeda.org/wiki/H%C3%A9t%C3%A9rozygote">hétérozygote</a> pour chacun des 3 gènes. L'évaluation du support génétique donne </p>
$$ v = \{ AB: 1, A:1, B:0.5, C:0.5 \}$$

<p>Les allèles A et B sont codominantes, elles s'expriment donc toutes les deux mais leurs effets ne se combinent pas, elles produisent une nouvelle valeur \(AB\), un nouveau phénotype.</p>

<h3>Sur les allèles</h3>

<p>
    Un allèle est un code binaire, une variation d'un gène. Son code binaire est son identifiant, qu'on pourra surcharger avec un nom. Un allèle peut être déclaré :
</p>

<ul>
    <li>Disponible : l'allèle est accessible lors de l'initialisation d'une population d'individus</li>
    <li>Mutant : non accessible par défaut, seulement par mutation de son code génétique</li>
</ul>
<p>Un allèle pourra muter </p>

<ul>
    <li>vers un allèle existant (Disponible), équivalent à du brassage génétique</li>
    <li>vers un allèle mutant (Mutant), introduction d'un nouvel allèle dans la population</li>
</ul>

    <h3 id="features">Feature (ou trait, phénotype local)</h3>

    <h4>Définition</h4>

    <p>Une fois que les supports génétiques sont définis on peut commencer à designer le composant à l'étage du dessus : la feature. On peut aussi commencer par une feature et designer ensuite le génome.</p>
        
        <p>Une feature est un trait (un phénotype) observable au niveau de l'individu. C’est à ce niveau qu’on va  <em>donner un sens aux valeurs retournées par le support génétique</em>. La feature produit une <strong>observable</strong> que l'utilisateur va définir. </p>

    <p>L’intérêt de découpler la valeur d'un support génétique de son interprétation c’est qu'ont peut réutiliser un même support pour plusieurs features (dans différents projets) et redéfinir l'interprétation qu'on en fait.</p>
    <p>
        La feature est une fonction qui va prendre en entrée la valeur d'un support génétique, <a href="#features-coupling">ou d'une autre feature</a>, et retourner un phénotype, c'est à dire, une valeur et (possiblement) une grandeur et une unité de mesure. C'est une fonction au sens mathématique du terme : à chaque valeur de l'ensemble de départ (valeurs du support génétique) elle produira une valeur dans un ensemble d'arrivée (valeurs du phénotype).
    </p>

    <p>
        Le point important c'est qu'une feature <strong>ne possède pas d'état interne</strong>. Elle prend des valeurs en entrée et renvoie des valeurs en sortie. Les même valeurs en entrée produisent <em>toujours</em> les mêmes valeurs en sortie. Elle n'a aucun effet de bord, c'est à dire que lorsqu'elle est évaluée elle ne <em> modifie pas l'état du monde</em> (exception faite des <a href="#epigenetique"> features attachées à l'état épigénétique</a>). En d'autres termes ce sont des <a href="https://fr.wikipedia.org/wiki/Fonction_pure">fonctions pures</a>. L'état d'un individu est complètement encodé dans ses supports génétiques et son épigénetique. L'ensemble des features vient agir comme une fonction qui prend cet état et renvoie un phénotype macroscopique. 
    </p>

    <img src="./img/feature-function.png" alt="">

   <p>Pour définir l'évaluation d'une feature, lui donner sens, nous allons avoir besoin d' </p>

    <ul>
        <li>une valeur : nombre décimal, une chaîne de caractères, un ensemble de clé:valeur, voir même une fonction</li>
        <li>une grandeur: (ex: temps, longueur, grandeur personnalisée...) [OPTIONNEL]</li>
        <li>une unité de mesure: ‘m/s’, des ‘mols’, des ‘kg’, des ‘grade’, des ‘milipilpoils’ etc.. [OPTIONNEL]</li>
    </ul>
    
    <p>
       L'unité de mesure servira à faire de l'analyse dimensionnelle et valider la cohérence de certaines expressions. Elle pourra servir à faire des conversions automatiques. Par exemple si un phénotype représente une taille, on pourra demander à évaluer cette valeur en 'cm', en 'm' sans avoir besoin de faire la conversion nous même.
    </p>

    <p class="note">
        A noter : l'utilisateur s'il souhaite avoir directement accès à la valeur du support génétique peut le faire, il peut demander à la feature de retourner directement la valeur du support, par exemple <code>{A:1, B:2}</code>.
    </p>


    <h4>Paramètres</h4>

    <table>
        <thead>
            <tr>
                <th colspan="4">Feature</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Paramètre</th>
                <th>Description</th>
                 <th>Type</th>
                  <th>Contraintes</th>
            </tr>
        <tr>
                <td>Nom</td>
                <td>Un nom donné à la feature</td>
                <td>String</td>
                 <td>Unique</td>
            </tr>
            <tr>
                <td>Source</td>
                <td>D'où proviennent les entrées de la feature</td>
                <td>Support Génétique ou (Features...)</td>
                 <td>Unique si support, MAX(à définir) si features</td>
            </tr>
            <tr>
                <td>Output</td>
                <td>Données en sortie de la feature</td>
                <td>Ensemble {clé:valeurs},<code>Object</code></td>
                 <td>
                     Doit respecter le schéma <code>{valeur: Object, dimension: String, unit: String}</code>. Ajouter peut être une contrainte sur le schéma de <code>value</code>
                   </td>
            </tr>
            <tr>
                <td>Input</td>
                <td>Données en entrée de la feature. <ul>
                    <li>Si support génétique : évaluation du support [entrées possibles définies]</li>
                    <li>Si une ou plusieurs features : concaténation des évaluations des features</li>
                </ul></td>
                <td>Ensemble {clé:valeurs},<code>Object</code></td>
                 <td>

                    <ul>
                        <li> Si source est support : structure passée en entrée doit contenir les clefs appartenant à l'ensemble des allèles définis sur le support</li>

                        <li>Si sources est features : voir contraintes à mettre. Chaque input doit respecter le schéma de données Output de la source. Chaque input doit respecter le schéma <code>{valeur: Object, dimension: String, unit: String}</code>  </li>
                    </ul>
                     
                    
                   </td>
            </tr>
            <tr>
                <td>Log</td>
                <td>Historique de toutes les valeurs générées par la feature. A chaque évaluation, si l'évaluation est différente de la précédente valeur on la log.</td>
                <td>Stack (Last in First Out) { t: {valeur, dimension, unit}}, tableau d'Object</td>
                 <td>
                   Aucune
                   </td>

            </tr>
        </tbody>
    </table>


    <h4>Écrire une feature</h4>

    Pour qu'une feature fonctionne il faut définir :

    <ul>
        <li>ce qu'elle prend en entrée (arguments): valeur d'un support génétique, valeur produite par une autre feature</li>
        <li>ce qu'elle retourne en sortie: quelle transformation j'opère pour produire une valeur "phénotype"</li>
    </ul>

    <h4>1) Mapper les valeurs des allèles</h4>

    <p>La première étape est donc de <em>maper</em> (d'associer) à chaque allèle exprimée du support génétique une valeur. Comme les allèles sont définies au niveau du support génétique on peut facilement proposer une liste de valeurs à maper à l'utilisateur. On peut associer à la valeur de l'allèle n'importe quelle valeur de notre choix</p>
<p>Prenons un exemple de valeur produite par le support génétique encodé sur 3 gènes</p>
$$(c-B)A(A-B) $$
<p>qui est évalué à</p>
    $$ S =\{ AB: 1, A:1, B:0.5, C:0.5 \} $$
    On doit proposer à l'utilisateur d'associer à chaque allèle une valeur. Prenons \(A\), voici les possibilités :

    <ul>
        <li>Associer un entier : \(A \mapsto 1 \)</li>
        <li>Associer un nombre décimal : \(A \mapsto 0.1 \)</li>
        <li>Associer une chaine de caractères : \(A \mapsto \text{'foo'}\)</li>
        <li>Associer un tableau : \(A \mapsto \left[1, \text{'foo'}, 0.5, \left[1, \text{'foo'}, 0.5,  \right]\  \right]\)</li>
        <li>Associer une association clé:valeur : \(A \mapsto \{a: 1, b: \text{'foo'}\}\)</li>
        <li> <a href="#fonctionnal-feature">Associer une fonction</a> : \(A \mapsto f(S)\)</li>
    </ul>

    <p>On pourra évidemment proposer ici de mapper des valeurs de manière automatique (pattern, aléatoire etc..)</p>

    <p>On pourrait imaginer ne pas contraindre l'utilisateur à définir la valeur de chaque allèle. Ainsi, une valeur non mappée aurait la valeur de son code binaire, nom et une dimension dédiée, par exemple <code>{value: {A:1, B:1}, dimension: 'gene', unit: 'none'}</code></p>

    <code class="pseudo-code">
        <pre>
x = evaluate(individu, feature) // acceder au phénotype retourné par la feature
//Allèle inconnue (mutation, non définie par l'utilisateur)
if(isGene(x)){
    //Do stuff
    valeur = ....
    // retrouve l'allèle non mappée et lui assigne valeur,dimension, unité
    setValue(feature, 'valeur', dimension, unité) 
}
        </pre>
    </code>

    <p>Nous reviendrons sur la possibilité de tomber sur des allèles dont l'évaluation est inconnue dans la section <a href="mutations">mutations</a> </p>

    <h4>Cas d'un support codé sur un gène</h4>

    <p>
        Dans le cas où la feature prend en entrée l'évaluation d'un support encodé sur un seul gène, la question ne se pose pas, on retourne la valeur mappé à la valeur qui s'est exprimée.
    </p>

    <h4>Cas d'un support codé sur plusieurs gènes</h4>
    <p>
       Reprenons notre exemple précédent, 
       $$ S =\{ AB: 1, A:1, B:0.5, C:0.5 \} $$
       Ici, un support génétique est s'exprime sur plusieurs gènes. Pour interpréter cette valeur, plusieurs stratégies d'interprétation peuvent être définies par l'utilisateur.
       On peut :
       <ul>
           <li>Renvoyer toutes les valeurs avec leurs poids (information transparente, l'utilisateur en fera quelque chose soit dans une feature à l'étage supérieur, soit directement dans son projet)</li>
           <li>Filtrer : ne renvoyer qu'une valeur, envoyer des valeurs dont le poids normalisé respecte une condition</li>
           <li>mapper automatiquement à un type et une valeur (aléatoire, regex...)</li>
       </ul>
    </p>

    <p>
        Si on associe à chaque valeur du support un nombre (entier ou décimal) alors on peut faire une combinaison linéaire.
    </p>
   
    <h5>Combinaison linéaire</h5>

    <p> <strong>Si et seulement si l'utilisateur map chacune des allèles à un nombre (entier ou décimal) </strong>on peut proposer à l'utilisateur d'en faire un combinaison linéaire se servant du poids caractérisant la contribution de chaque allèle. Par exemple ici, définissons cette association : </p>
    <ul>
        <li>\(AB \mapsto 1 \)</li>
        <li>\(A \mapsto 0 \)</li>
        <li>\(B \mapsto 5 \)</li>
        <li>\(C \mapsto -1 \)</li>
    </ul>
    <p>On peut facilement fabriquer de la variation continue en faisant la combinaison linéaire de l'expression de chaque allèle (notamment dans le cas de dominance incomplète)</p>

    $$ \frac{1}{3} (v_{AB} + v_A + 0.5v_B + 0.5v_C)  $$
    <p>en utilisant le poids de l'expression de chaque allèle. La feature sera évaluée ici à \(1\). L'évaluation en combinaison linéaire d'un support génétique encodé sur \(N\) gènes est donné par 

  

    $$ V = \frac{1}{N}\sum_{i=1}^{N} u(i_a,i_b)v_a + (1-u(i_a,i_b))v_b $$ 

    Soit
    $$ V = \frac{1}{N}\sum_{i=1}^{N}  u(i_a,i_b)\left[v_a -v_b\right] + v_b $$ 
</p>

    <p>avec \(i_a\) et \(i_b\) les allèles a et b du gène \(i\).</p>

    <p>
        L'utilisateur peut ensuite <strong>metre à l'échelle (rescale)</strong> les valeurs obtenues vers un nouvel intervalle. En effet, en fonction des valeurs qu'il a associé à chaque allèle, il a défini un domaine de départ (les bornes min et max), ici \( \left[ -1 : 5 \right]\). Il peut interpoler chaque valeur de cet intervalle vers un autre intervalle. Pour cela il a juste à définir un min, un max et une fonction d'interpolation. Par exemple, il définit l'intervalle d'arrivée à \( \left[ 10 : 300 \right]\) et une fonction d'interpolation linéaire.
    </p>
    <p>
        On peut faire une interpolation linéaire ou avec n’importe quel polynôme. Le choix de l'interpolation est un paramètre intéressant car ainsi, une variation infime du génome (brassage, mutation) peut conduire à des variations phénotypiques plus fortes (et non directement proportionnelle ou graduelle)
    </p>

    <img src="img/interpolation.png" alt="" style="width:80%">


    <p class="question">Comment ça se passe pour un trait phénotypique encodé sur plusieurs gènes en vrai? Quelles stratégies peut on mettre en place pour fabriquer une interprétation d'un support génétique s'exprimant sur plusieurs gènes ? Dans ce cas, quel rôle donner aux <em>poids d'expression</em> ?</p>


    <h5>Ultime possibilité (et la plus forte) : écrire soi même sa fonction !</h5>

    <p>
        L'idéal est de pouvoir écrire soi même une fonction qui renverra le phénotype. Cette fonction permet de couvrir toutes les autres stratégies définies précédemment (celles-ci ne sont que des aides pour l'utilisateur, lui proposer des stratégies clés en main sur des patterns courants). Ainsi on peut donner à l'utilisateur un éditeur pour qu'il écrive soi même sa fonction
    </p>
    <code class="pseudo-code">
        <pre>
function evaluate(args){
    //Write your own function that returns a phenotype (data)
    //...
    return {}
}
        </pre>
    </code>
    <p>où <code>args</code> est une variable d'entrée de la fonction que l'utilisateur peut utiliser. Elle aurait toutes les infos nécessaires pour écrire la fonction : les valeurs de départ du support, les poids et les valeurs mappés (si elles l'ont été). Par exemple ici :</p>
<pre>
    <code>args = {
        genetic: { 
          AB: {
            // poids expression de la valeur retournée par le support
            weight: 1, 
            // la valeur assignée par l'utilisateur
            map: 1 
          },
          A: {
            weight: 1,
            map: 0  
          },
          B: {
            weight: 0.5,
            map: 5  
          },
          C: {
            weight: 0.5,
            map: undefined  
          },
         }
        featureB: {}
        ...
    }
    </code>
</pre>

<p> Le code sera à écrire en JavaScript (ou langage de script transpilable vers JS). Il permettra de faire tout ce qu'on veut. Justement, tout ce qu'on veut peut amener à des gros problèmes de sécurité. Il faudra songer à ce point : accès au DOM, Web API du navigateur? Émettre des requêtes? Il faudra proposer un environnement où on peut contrôler les autorisations qu'on donne à ce code.</p>

<h5>Contrainte sur la valeur retournée?</h5>

<p>Si l'utilisateur écrit sa propre fonction (dans les autres cas ça sera fait automatiquement) il devra fournir un schéma de données pour la valeur retournée par la feature. Par exemple </p>
<pre>
    <code>phenotype = [
        {
            value: String,
            dimension: String,
            unit: String,
        },
        {
            value: Integer,
            dimension: String,
            unit: String,
        },
        ...
       ]
    }
    </code>
</pre>
<p>Ainsi il sera beaucoup plus simple dans l'étape de design de coupler les features, car on saura exactement quelles données on recevra en entrée. Il est peut être même possible qu'on puisse récupérer les valeurs possibles retournées (on peut imaginer créer un bouton  <code>Test</code>  dans l'éditeur qui testerait la fonction (vérification entrées, vérification du retour conforme au schéma) et qui l'évaluerait sur toutes les valeurs d'entrées possibles pour produire tous les outputs possibles. On disposerait d'une liste de valeurs retournées pour aider le design d'une autre feature qui la prendrait en argument. </p>
    <p>Ici j'ai mis un tableau de structure phénotype {value, dimension, unit}, on pourrait restreindre encore davantage à une seule structure phénotype. Et demander un schéma de données pour la valeur. On peut contraindre pas mal je pense car si on met trop de libertés ça va compliquer le design. Si une feature peut renvoyer deux <em>schémas</em> (structure de données) de phénotypes différents c'est qu'elle peut probablement être découpée en deux features qui retourne chacune un seul. Ces questions seront tranchées par la pratique.</p>
    

<p>Prenons un exemple simple ici j'écris ma fonction, je veux, par exemple, retourner la valeur de \(AB\) si elle existe, sinon je renvoie 'toto'</p>
<code class="pseudo-code">
    <pre>
function evaluate(args, phenotypes = []}){
    if( 'AB' in args.genetic){
        // valeur du phénotype retourné
        phenotype.value =  args.genetic['AB'].map
        phenotype.dimension = 'Length'
        phenotype.units = 'm'
        return phenotypes.push(phenotype)
    }
    //Si AB n'est pas présent
    phenotype.value = 'toto'
    phenotype.units = 'none'
    phenotype.units = 'none'
    return phenotypes.push(phenotype)
}
    </pre>
</code>

<p>Ici on contraint la réponse à respecter le schéma suivant : la valeur retourné doit contenir 3 clés: value, dimension et units. Si une clé manque (ou si une autre clé est ajoutée) une erreur est émise. Un <em>template</em> de phénotype est imposé. </p>
   

    <p class="note">On peut imaginer encore beaucoup de choses dans les contraintes à imposer ici. Plus on met de contraintes plus c'est long d'éditer mais plus on peut proposer des tests automatiques pour avertir l'utilisateur en cas de bug. Autant de temps à débugger en moins dans son projet</p>

    <h4 id="fonctionnal-feature">Features <em>fonctionnelles</em></h4>

    <p>
        Jusqu’ici on a parlé d’associer aux valeurs remontées par le support génétique d'autres valeurs qui <em>font sens</em>. On fait correspondre des valeurs à des valeurs, on map. Une feature est une simple <em>fonction</em> au sens mathématique qui, à chaque valeur fait correspondre une autre valeur. Pourquoi s’arrêter là ? Pourquoi ne pas donner la possibilité d’associer à chaque valeur d’un support génétique directement une fonction ? En effet, une fonction est <em>une valeur comme les autres</em> (dans une approche <a href="https://en.wikipedia.org/wiki/First-class_function">first-class function</a>), au même titre que 1 ou ‘toto’.
    </p>

    <p>
        Cette possibilité est <strong>extrêmement intéressante</strong> car elle permet de produire des phénotypes qui sont non plus juste des états (une valeur interprétée du support génétique) mais des <strong>comportements</strong>. 
    </p>

    <p>Reprenons un exemple où notre support génétique est codé sur un gène avec deux allèles A et B, avec \(u(A,B)=1\), soit A dominant et B récessif. On a donc deux valeurs possibles , A ou B, pour ce support. Associons une fonction(une valeur) à chaque allèle dans notre feature que nous appellerons <code>'FeatureA'</code> :</p>
    <ul>
        <li>\(A \mapsto f_A(x,y) \{ \text{return x + y} \} \)</li>
        <li>\(B \mapsto f_B(x,y) \{ \text{return x - y} \} \)</li>
    </ul>

    <p>où \(x\) peut être n'importe quoi (y compris une fonction !) C'est à l'utilisateur de le définir. Attention ici on est pas dans le cas où on va appliquer \(f_A\) quand A s'exprime et renvoyer le résultat. Ici, on <strong>retourne</strong>\(f_A(x)\)</p>

    <p>Par exemple, un extrait de pseudo-code de l'utilisateur dans son projet</p>

    <code class="pseudo-code">
        <pre>
value = evaluate(individu,'FeatureA')
x = value(1,2) // = 3 si A s'exprime, -1 si B s'exprime
        </pre>
    </code>

   <p>Le fait de pouvoir retourner directement des fonctions est une propriété très intéressante et utile au modèle pour créer des phénotypes riches, faits d'états mais aussi de comportements. Cela ouvre énormément de possibilités.</p>


   <h4 id="fonctionnal-feature">Features <em>récursives</em></h4>
   <p>
       Des features qui se prennent elle même en argument (possible de le faire déjà à partir d'une feature fonctionnelle récursive non?)
   </p>


   <h4>Sur les dimensions et unités de mesure</h4>
   <p>
       La bibliothèque embarquera avec elle les dimensions et unités de mesure répandues (sûrement en utilisant une library tierce). L'utilisateur pourra également définir lui même ses propres grandeurs et unités associées.
   </p>

   <h4>Sur le temps</h4>
   <p>
       Pour le moment nous n'avons pas parlé du temps, les features produisent des phénotypes statiques pour un matériel génétique donné. <strong>Le temps sera accessible par défaut à chaque feature en argument</strong> pour permettre à l'utilisateur de produire des évaluations dynamiques du phénotype. En effet, pour faire évoluer un système (un individu par exemple) il faut une notion de temps d'une manière ou d'une autre. L'horloge interne d'un individu (à sa naissance) \(t_0\) sera accessible à chaque individu.
   </p>

   <p>
       Il faudra définir un temps bien caractérisé (unité) qui sera utilisable par toutes les features et défini/initialisé à l'échelle du projet comme une variable globale. A réfléchir...
   </p>


    <h4 id="features-coupling">Coupler les features (et donc l'expression des gènes)</h4>

    <p>Une feature peut prendre en entrée (en argument)</p>
    <ul>
        <li> <strong> un et un seul support génétique</strong></li>
        <li>un support génétique et une ou plusieurs features, voir <a href="#general-model">ce schéma</a></li>
        <li>une ou plusieurs valeurs d'<a href="#environment">environnement</a>  (inclus le temps)</li>
    </ul>

    <p>
        Voici une notion un peu plus avancée du modèle mais qui permet, je crois, de lui donner beaucoup d’intérêt et de puissance.
    </p>
    <p>
        Pour le moment, on peut définir des features, chacune interprétant l'expression d'un support génétique. C’est cool déjà, mais c’est embêtant car toutes ces features sont sagement <em>les unes à coté des autres, à s’ignorer mutuellement et à vivre leur vie</em> . En soi on peut laisser au soin de l’utilisateur de combiner les effets des features pour fabriquer de nouveaux mécanismes lui-même. Mais on peut aussi intégrer nativement cette possibilité dans notre bibliothèque, et créer de manière récursive et <em>infinie</em> des features à partir d’autres features.
    </p>
    <p>
        Créer un réseau de features pour fabriquer des nouvelles features, pour fabriquer des nouvelles features. Ainsi on peut créer du couplage entre supports génétiques et produire des phénotypes beaucoup plus intéressants. Voyons cela plus en détails, à partir d’un exemple concret.
    </p>

    <img src="./img/features-coupling-time.png" alt="" style="width: 100%;">

    <p>
        Sur le schéma ci dessus on a un cas de couplage qui fait intervenir le temps. On a une feature qui nous renvoie la taille de l'individu. Cette taille est fonction du temps (accessible en lecture et donnée par le système à toutes les features). Pour évaluer la taille d'un individu il faut évaluer cette feature <code>taille</code>. Cette feature est couplée à trois autres features : <code>taille min</code> qui donne une taille minimale (à la naissance) encodée sur son support génétique, <code></code> idem, et <code>taux de croissance</code> .
    </p>

    <p>
        On a donc une feature <code>taille</code> qui, pour être évaluée, doit évaluer avant tout ses dépendances (on pourra optimiser cette étape, avec un cache et n'évaluer que si l'évaluation de cette feature a changé, notamment grâce à la gestion des mutations). Avec la fonction définie pour la feature <code>taille</code>, quand je l'évaluerai j'aurai toujours la bonne valeur, même si taux de croissance mute entre deux évaluations.
    </p>
    <p>
        Voici comment on peut coupler les features entre elles pour produire des nouvelles features, et créer autant de complexité qu'on le souhaite. On peut imaginer ici reproduire des features à la manière de composants informatiques, qui viennent éteindre et allumer l'expression d'autres features.
    </p>
    <p>
        Comme on peut le voir dans l'exemple, pour évaluer <code>taille</code> on se sert de la dernière valeur renvoyée par la feature. On accède à son<code>LOG</code>, son historique, et on récupère la dernière entrée avec <code>popValue()</code>  et <code>popTime()</code>. Le <code>LOG</code> est une <a href="https://fr.wikipedia.org/wiki/Pile_(informatique)">pile</a>, c'est une structure de données "Last In First Out". C'est une collection de <code>valeurs immutables</code> (on ne peut pas les changer!). Chaque entrée du <code>LOG</code> a la structure <code>{date, value}</code> . Il est temps d'aborder un point important sur l'évaluation et les états d'un individu.
    </p>

   
    <h4 id="immutability">Les états et l'évaluation</h4>

    <p>C'est sans doute l'un des points les plus importants dans le design de ce modèle. Le phénotype d'un individu <strong>est une valeur, elle est donc immutable</strong>.</p>
        <p>
            Quand on veut connaître la taille d'un individu par exemple, on ne vient pas écraser ou mettre à jour la taille qu'on avait noté avant. La taille d'un individu ne change pas dans le temps (votre taille change bien sûr mais pas dans un système d'informations, si elle change c'est une nouvelle entrée) : quand on la mesure on obtient des valeurs différentes à chaque instant. Quand on mesurait notre taille enfant en mettant une petite marque sur le mur, on n'effaçait pas la marque d'avant pour mettre la suivante, plus haute. On faisait une nouvelle marque ! Il sera toujours vrai, qu'à un moment donné vous étiez plus petit qu'aujourd'hui. Prenez une personne que vous connaissiez enfant et qui est devenue adulte, vous vous souvenez d'elle quand elle était petite, vous n'êtes pas allés dans notre cerveau chercher la cellule qui stocke sa taille pour la remplacer par sa taille adulte ! Les deux cohabitent, les informations s'accumulent, de manière associative. Et c'est ce qui vous permet de dire "Oh, ce que tu as grandi!". En ce sens, du point de vue du système d'information, la taille n'est pas un état mutable. 
        </p>

        <p>
            C'est la même chose pour notre phénotype. Le phénotype n'a pas à être un état mutable, qu'on viendrait mettre à jour à chaque pas de temps. Non ! Le phénotype est <strong>un instantanée de l'évaluation de toutes les features d'un individu</strong>. Si je veux connaître la taille d'un individu, j'évalue sa feature <code>taille</code> et elle me renvoie une valeur. Cette valeur dépend du temps (mesurer deux fois la taille au même instant produit la même valeur). 
        </p>
        <p>
            Chaque feature, comme dans l'exemple ci-dessus, conserve un journal, un historique (un <code>LOG</code>) de toutes les valeurs qu'elle a produite par le passées. Ainsi, j'accède naturellement à l'histoire complète de mon individu. Je ne remplace pas la valeur taille, j'en créée un nouvelle à chaque fois que je fais la mesure. Ce <code>LOG</code> permet de calculer le présent en fonction du passé. Le présent (ou le futur) ne vient pas écraser le passé. 
        </p>

        <p>
            Pour ces raisons, il est hors de question pour notre feature d'avoir un état mutable (qui change sur place). Le <code>LOG</code> change non, on ajoute des valeurs. Oui, mais une collection de valeurs immutables, qui s'agrandit peut être vue comme une valeur.
        </p>
        <p>
            Dans ce modèle, l'état mutable est le support génétique, sujet à des <em>mutations</em>. Dans toute cette bibliothèque le seul état mutable est le génome (exception faite de l'épigénétique, qui est d'ailleurs peut-être une mauvaise idée, ça peut être utile mais déconseillée à n'utiliser que dans des cas où c'est nécessaire)
        </p>

        <p>
            Pour résumer, <strong>le phénotype d'un individu est une valeur</strong> produite par les features à un instant donné. Les features n'ont pas d'état mutable (qui change sur place). Elles peuvent produire une valeur à partir d'une valeur produite dans le passé, c'est bien normal. Mais <strong>elles ne peuvent pas modifier le passé</strong>, elles peuvent juste y accéder en lecture, <strong>ce sont des faits</strong>. Chaque nouvelle entrée s'ajoute aux précédentes sans les modifier, aucune entrée ne peut être modifiée ou supprimée par la feature.  
        </p>
      

    <h5>Quelques exemples</h5>

    <h5>Phénotype dormant</h5>
   

    <p>Prenons l'exemple d'un individu <em>serpent</em>. Il possède des gènes pour coder un pied, et d'autres gènes pour lui donner forme (nombre de doigts, pied palmé etc...). Dans la plupart du temps (phénotype dominant à l'état sauvage) il ne s'exprime pas. Dans son phénotype on ne trouve aucune expression du pied, et des traits propres au pied.  </p>
    <img src="./img/coupling-feature-on-off-ex2.png" style="width: 100%;" alt="">
    <p> Ici, l'allèle B (la plus courante) s'exprime. La feature renvoie une valeur vide \(\{\}\). Toutes les features qui en dépendent ne peuvent plus s'exprimer et renvoient une valeur vide à leur tour. Le résultat net est que le génome concerné ne s'exprime pas et que le phénotype n'est pas observé </p>
<p>Ces gènes ne s'activent que si l'allèle A s'exprime, comme ci-dessous. Si c'est le cas l'intégralité du génome du pied s'exprime et on trouve un phénotype</p>
    <img src="./img/coupling-feature-on-off-ex1.png" style="width: 100%;" alt="">
    <p>L'activation en cascade de toutes les features dépendantes est alors automatique dans le modèle.</p>


    <h5>Les features sont des API</h5>

<p>Les features sont des fonctions pures qui prennent en entrée une valeur et retourne une valeur. En ce sens tout leur comportement est défini par les arguments en entrée. Aussi on pourra fournir pour chacune d'entre elle, en fonction des contraintes qu'on imposera, une documentation des arguments acceptés et des sorties produites. Elles seront alors facilement testables de manière unitaire (isolées). Elles ont donc une <a href="https://fr.wikipedia.org/wiki/Interface_de_programmation">API</a> et il n'est pas utile de regarder dans le détail de leur code source pour s'en servir. La documentation pourra nous dire ce que chaque feature fait, de quelle feature elle dépend etc.. Et une fois définie (ou récupérée) on pourra l'utiliser comme une boîte noire dans notre projet, sans avoir à soulever le capot. </p>

    <h5>Une feature "Groupe de features"</h5>

    <p>
        Comme on l’a vu, on peut coupler des features pour faire des nouvelles features. Cela crée des dépendances entres features. Pour simplifier la vie de l’utilisateur on pourrait rajouter quelque chose de simple : faire des paquets de features. Au lieu d’évaluer chacune d’entre elles on en évalue qu’une qui renverra l ‘évaluation de toutes les features dont elle dépend. C’est juste une fonctionnalité pour faciliter la vie de l’utilisateur et simplifier l’usage de la bibliothèque.
    </p>
    <p>
        Par exemple, je crée tout un ensemble de features relatives à la possibilité de voler d’un animal : absence/présence d’ailes, taille des ailes, types ailes (a plume, mammifère), forme des ailes, couleurs des plumes, bruit que fond les ailes, vitesse en vol, vitesse de pointe etc... Toutes ces features sont reliées les unes aux autres. Par exemple s’il n’y a pas de plumes, il n'y a pas de couleur des plumes. Au lieu d’avoir à interroger manuellement chacune de ces features je pourrais créer une « méta-feature » qui s’appelle « vol » par exemple. Elle les comprendrait toutes. Cela donnerait une paquet prêt à l’emploi ds n’importe quel projet où je veux voir ce trait phénotypique exister. Ainsi dans le code au lieu d’avoir un truc du genre :
    </p>

    <code class="pseudo-code">
        <pre>
hasPlumage = evaluate(individu, ‘hasPlumage’)
plumageColors = evaluate(individu, ‘plumageColors’)
wingsSize = evaluate(individu, ‘wingsSize’)
etc.
//Then do logic
...
//A la place on aurait
vol = evaluate(individu, ‘vol’)
//vol contiendrait toutes les données :
//par ex : vol = {
    hasWings : true,
    hasPlumage : false,
    plumageColor : undefined,
    wingSize : {
        value : 52,
        dimension: 'length'
        unit : ‘cm’
    },
    speed : {
        value : 60 ,
        dimension: 'speed'
        unit : ‘km/h’
    }
    //Etc...
} 
        </pre>
</code>

<p>
    En ce sens, le phénotype global d'un individu (l'ensemble de ses traits), est la <em>méta feature</em> la plus globale. A voir. On peut aussi décider qu'une feature dépendante d'une autre feature est embeded dans celle-ci. Si la feature parente ne s'exprime pas, celle-ci ne s'exprime pas et ne remonte pas dans le phénotype. Ainsi la méta-feature est explicite.
</p>
<code class="pseudo-code">
    <pre>
//evalue toutes les features d'un coup
phenotype = evaluate(individu)
    </pre>
</code>
 

<h4>Pour résumer :</h4>

<p>Pour créer une feature l'utilisateur doit</p>
<ul>
    <li>Lui donner un nom</li>
    <li>Lui donner ses sources/arguments (un support génétique, une ou plusieurs features). Ca définit ce qu'elle prend en entrée</li>
    <li>Si une source est un support génétique, il peut associer une valeur à chaque allèle. Si la source est une feature, il n'a rien à faire (l'entrée est définie par le retour de cette feature)</li>
    <li>Définir ce que la feature retourne (soit une stratégie, soit il implémente sa propre fonction)</li>
    <li>Si la valeur retournée est définie par une fonction écrite par l'utilisateur il doit en plus renseigner le schéma de la réponse(la structure des données renvoyée)</li>
</ul>

    <h3 id="espèces">Espèce</h3>


    <p>
        Une espèce est définie par un ensemble de features designées préalablement. Une feature peut être utilisée pour plusieurs espèces. A cela s’ajouteront des paramètres (à définir), des caractères irréductibles (non codés par du support génétique). Ces « méta paramètres »seront utiles pour le modèle (pour simplifier des choses).
    </p>




    <p class="question">
        Tout ce modèle est très «génétique centré», est ce qu’on pourrait imaginer des caractères non réductibles à l’expression du génome, à définir directement sur l’espèce (des méta caractères, épigénétique...)?
    </p>


    <h4>Paramètres</h4>

    <table>
        <thead>
            <tr>
                <th colspan="4">Feature</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Paramètre</th>
                <th>Description</th>
                 <th>Type</th>
                  <th>Contraintes</th>
            </tr>
        <tr>
                <td>Nom</td>
                <td>Un nom donné à l'espece</td>
                <td>String</td>
                 <td>Unique</td>
            </tr>
            <tr>
                <td>Features (nombre \(n_f\))</td>
                <td>Liste de features caractérisant l'espece. Chaque feature sélectionnée embarque avec elle son support génétique et ses dépendances</td>
                <td>Liste Features</td>
                 <td>Aucune</td>
            </tr>
            <tr>
                <td>Nombre de paires de chromosomes \(n_p\)</td>
                <td>Toutes les espèces sont diploïdes mais le nombre de paires de chromosomes peut être défini pour chaque espèce (brassage)</td>
                <td>Integer</td>
                 <td>Au moins un gène par chromosome, \(n_p \leq \sum_{i=1}^{n_f} N_i\)</td>
            </tr>
            <tr>
                <td>Placement des gènes sur les chromosomes</td>
                <td>Quel gène va sur quel chromosome. Éditeur permet de placer automatiquement, possibilité de le faire à la main, avec un éditeur Drag&Drop graphique.</td>
                <td>-</td>
                 <td>-</td>
            </tr>
            <tr>
                <td>Gènes non codant</td>
                <td>En plus des gènes codants, générer des séquences génétiques non codantes aléatoires (%, disposition etc..)</td>
                <td>-</td>
                 <td>-</td>
            </tr>
            <tr>
                <td>Type de reproduction</td>
                <td>Auto-fertilisation, clonage, reproduction sexuée</td>
                <td>String</td>
                 <td>Appartenir aux types de reproduction définie par le système</td>
            </tr>
            <tr>
                <td>Peut se reproduire avec d'autres espèces?</td>
                <td class="question">
                    Sous quelles conditions, comment ça marcherait ? Je ne souhaite pas que la notion d’espèce soit trop « cloisonnante », mais plutôt comme c’est en vrai, un concept aux contours évoluant avec le temps, « un flux ». C’est pratique pour programmer. En soi le modèle est piloté par des données donc tout est imaginable. On voudrait bien que des individus d’espèces différentes se croisent ! Sous quelles conditions (proximité génétique : valeur seuil de % génome commun ?) ? Quel génome résultant (chaque individu apporte tout ou une partie de ses features) ? Là ton regard pour être très précieux sur ces aspects pour imaginer des mécanismes.
                </td>
                <td>{booléan, proximité : Float}</td>
                 <td>??</td>
            </tr>
            <tr>
                <td>Autoriser Mutations</td>
                <td>
                    Choisir si le génome de l'espèce peut muter
                </td>
                <td>Boolean</td>
                 <td>Aucune</td>
            </tr>

            
        </tbody>
    </table>

    <h3 id="espèces">Population</h3>
    
    <p>
        On pourra définir des choses à l'échelle d'une population quand on utilisera la méthode <code>generatePopulation</code> pour créer une population initiale d'individus appartenant à une espèce.
    </p>
    <p>
        Une population peut être couplée à un <a href="#environment">environnement</a>. On peut ainsi créer des boucles de rétroactions !
    </p>
    <p class="question">
        Quoi donc imaginer/de quoi aurait on besoin à l'échelle d'une population?
    </p>

    <h2 id="mutations">Mutations</h2>

    <h3>Définition d'une mutation dans le modèle</h3>

    <p>
        Une mutation est une modification rare, accidentelle ou provoquée de l'information génétique dans le génome. Dans le modèle une mutation pourrait être
    </p>
    <ul>
        <li>code génétique d'une allèle : transition vers une autre allèle, vers une allèle mutante ou vers une allèle inerte (code inconnu)</li>
        <li class="question">relation entre deux allèles. Est ce raisonnable ? Dans la vraie vie il peut y avoir une mutation qui rend une allèle jusque la récessive tout d'un coup dominante?</li>
        <li>Apparition d'un nouveau gène codant pour une feature</li>
        <li>Disparition d'un gène codant pour une feature</li>
        <li>Disparition d'un allèle</li>
        <li class="question">Autre idée?</li>
    </ul>
  

    <p>
        Le support génétique peut muter : par exemple un bit pourrait se décaler vers la gauche. Prenons un gène codé sur 8bits qui vaut initialement <code>00000001</code> (correspond à une allèle). Une mutation est déclenchée et un bit se décale) à <code>00000010</code> :

        <ul>
            <li>soit j'ai défini une allèle mutante en amont, pris en compte dans ma feature</li>
            <li>soit je n'ai pas associé de valeur. L'allèle sera évaluée à <code>'unknown'</code> ou sera inerte.</li>
        </ul>
    </p>


    <h3>Rôle des gènes non codants</h3>

    <p>
        On peut imaginer introduire des gènes non codants sur les chromosomes. Par exemple :
        $$...\color{grey}0000000\color{red}10000100\color{blue}11011110\color{grey}11001100... $$ 

    <ul>
        <li><span style="color:red;">Gène codant 1 allèle A </span></li>
        <li><span style="color:blue;">Gène codant 2 allèle B </span></li>
        <li><span style="color:grey;">Gène non codant </span></li>
    </ul>



</p>

<p>
    Maintenant on peut imaginer une forme de mutation où chaque bit se décale de 1 pas sur la gauche. Le résultat serait cette séquence (me suis peut être trompé c’est chiant à faire)
</p>

$$...\color{grey}0000001\color{red}00010011\color{blue}01111011\color{grey}10011001... $$ 
<ul>
    <li><span style="color:red;">Gène codant 1 allèle C (par exemple) </span></li>
    <li><span style="color:blue;">Gène codant 2 allèle inconnu (par exemple) </span></li>
    <li><span style="color:grey;">Gène non codant </span></li>
</ul>
L'allèle du gène 1 est maintenant l'allèle <code>C</code> dans le modèle. On pourrait ainsi donner naturellement un rôle sympa aux séquences non codantes. Après je te laisse imaginer les opérations cools de mutation qu’on peut faire par des opérations très simples sur les bits.
    </p>


    <p>
        Si l'on souhaite faire une simulation plus bas niveau de brassage génétique et de mutations, en analysant le génome d'un individu sans lui donner du sens, on pourrait remplir utiliser uniquement du matériel non codant. Et appliquer des mutations dessus.
    </p>

    <h3>Paramètres (à compléter/modifier)</h3>

    <p>
        Les mutations seront designées comme les supports génétiques, features et espèces.
    </p>

    <table>
        <thead>
            <tr>
                <th colspan="4">Feature</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Paramètre</th>
                <th>Description</th>
                 <th>Type</th>
                  <th>Contraintes</th>
            </tr>
        <tr>
                <td>Nom</td>
                <td>Un nom donné à la mutation</td>
                <td>String</td>
                 <td>Unique</td>
            </tr>      
            <tr>
                <td>Cible</td>
                <td>Qui vise-t-elle, Liste de support génétique, Chromosome entier</td>
                <td>Support génétique (Liste de gènes) ou Gène (codant ou non)</td>
                 <td>Au moins 1 gène visé</td>
            </tr>   
            <tr>
                <td>Action</td>
                <td>Que fait elle sur sa cible</td>
                <td>Proposer des actions : décalage, substitution(nombre de bits concernés), aléatoire, éteindre/allumer (en faisant muter vers une allèle du système défini comme 'unknown')  etc..</td>
                <td></td>
            </tr> 
            <tr>
                <td>Déclenchement</td>
                <td>Proposer des déclenchements automatiques</td>
                <td>Chaque reproduction, aléatoire, fréquence etc...</td>
                <td></td>
            </tr> 
            <tr>
                <td>Agressivité</td>
                <td>Permettre à la cible de résister ou non à la mutation. On définit un nombre de 0 à 100. On jette un dé, si le résultat est en dessus de ce nombre la mutation n'a pas lieu.</td>
                <td>Integer</td>
                <td>Entre 0 et 100 (arbitraire)</td>
            </tr>

        </tbody>
    </table>

    <p>
        Chaque mutation définie pourra être déclenchée automatiquement si elle a été configurée ainsi. Sinon l'utilisateur pourra toujours la déclencher manuellement quand il veut, en fonction des conditions de sa propre simulation (s'il simule un environnement par exemple), du genre
    </p>

    <code class="pseudo-code">
        <pre>
    //Déclenche manuellement une mutation
    mutation = triggerMutation('nomMutation')
    //Tous les individus concernés verront leur génome muter
        </pre>
    </code>
     
    <p>
        Chaque mutation sera loguée par le système.
    </p>

    <h3 id="epigenetique">Épigénétique</h3>

    <p>
        On pourrait introduire ici une notion  "épigénétique", avec des caractères héréditaires non encodés dans le génome sous la forme très simple d’un état transmissible (un ensemble de clé/valeurs) de génération en génération. Cet état mutable viendrait s'ajouter à l'état "génome" d'un individu.
    </p>
    <p>
        Cet état est accessible en écriture/lecture à des features spécifiques. Comme montré sur le schéma, une feature qui utiliserait cet état interne devrait le déclarer. En effet, on fait ici une exception à la règle d'or de notre design, que <a href="#immutability">les features sont des fonctions pures</a>. Une feature qui utiliserait l'état "épigénétique" cesserait d'être pure, elle produirait un effet de bord et changerait l'état du monde. Ce qui provoque des couplages indésirés entre features.
    </p>
    <p class="question">
        L'état épigénétique serait simplement une collection de clé:valeur mutables, et transmissible à la descendance. Quelles contraintes à mettre dessus ? Dans le cas d'une reproduction sexuée comment l'épigénétique de 2 parents se combinent pour être transmis ? Concaténation des clefs:valeurs? Est-ce vraiment une bonne idée (j'ai des doutes) ?
    </p>


    <h2 id="analyse">Considérations démographiques</h2>

    <h3>Le modèle a une mémoire</h3>

    <p>
        L'intérêt de designer le modèle sous forme d'aggrégations de valeurs, et de composition de fonctions pures, c'est qu'on peut garder mémoire de tout ce qui s'est passé au cours du temps.
    </p>
    <p>
        On peut reconstruire <em>toute l'histoire</em> d'un individu à partir de son état initial (son génome), du temps et des logs des mutations ! En effet, vu que tout est valeur et que rien n'est remplacé sur place (sauf le génome mais le log des mutations nous permet de retrouver toutes ses valeurs), et que toutes les features sont des fonctions pures, le système garde la mémoire de toutes les informations nécessaires pour re-dérouler le fil de l'histoire. On peut même obtenir des valeurs à des instants par lesquels n'est pas passée notre simulation.
    </p>
    <p>
        Regardons la puissance de cette approche (que je n'ai pas du tout inventé, beaucoup inspiré par Rich Hickey et notamment cette   <a href="https://www.youtube.com/watch?v=V6DKjEbdYos&t=3043s">conférence absolument géniale</a>) sur un exemple concret, un pseudo-code (je ne vais pas détailler pour le moment comment tout ça <em>exactement</em> va être implémenté mais c'est possible !)
    </p>
    <code class="pseudo-code">
        <pre>
    //At time t = 102
    history = getPhenotypes(t-50, t, t, individu)
    //history contient tous les phénotypes depuis t-50 à t
    //Say this individual is born at time t=10 of our simulation
    print(history) // = [ {t:101, phenotype:{...}}, 
                          {t:100, phenotype:{...}} 
                          ...
                          {t:10, phenotype:{...}} 
                          ]

    ...
    //All phenotype history between t-50 and t-10
    history = getPhenotypes(t-50, t-10, t, individu)
    //All phenotype history
    history = getPhenotypes(individu)
    //Phenotype at time t-30 only
    history = getPhenotype(t-30, t, individu)</pre></code>
    <p>
        Imaginons qu'on n'ai jamais évalué une seule fois notre individu, aucun phénotype n'a été mesuré et mis en entrée dans les logs. Mais est ce un problème ? Comme on a logé toutes les mutations sur son génome (s'il y'en a eu), a partir du temps, de sa date de naissance et des dates et effets des mutations on peut <em>reconstruire toute son histoire</em> jusqu'au présent !
    </p>
    <p>
        Évidemment cette propriété est vraie aussi pour chaque feature. On peut tracer l'histoire des valeurs mesurées d'une feature de la même manière
    </p>
    <code class="pseudo-code">
        <pre>
//At time t = 102. Get feature history from t-50 to now
featureHistory = getFeatureHistory(t-50, t, t, 
    individu, 'featureName')
        </pre>
    </code>

    <p>
        On n'est pas obligés de re-dérouler tout le fil de l'histoire jusqu'à la naissance de l'individu. On peut optimiser cette approche. On peut par exemple regarder s'il y a une évaluation de la feature à <code>t-50</code>. S'il y'en a une, c'est ok, s'il n'y en a pas, on reconstruit l'histoire. On remonte un pas de temps en arrière <code>t-51</code> jusqu'à ce qu'on tombe sur une valeur. Une fois qu'on a trouvé la valeur inférieure la plus proche (qui au minimum correspond à la naissance) on reproduit les valeurs manquantes jusqu'à <code>t-50</code> (en reproduisant le génotype de cette époque à partir des mutations au cours du temps). Ensuite on log cette valeur de la feature et on passe à la suivante, jusqu'à <code>t-50</code>. Et ainsi de suite. Comme ça, si on la redemande, elle sera déjà prête et il sera inutile de refaire le calcul.
    </p>

    <p>
        Si l'on souhaite utiliser le modèle pour faire des simulations et s'amuser à faire de la démographie, on aura naturellement accès à toute l'histoire de notre simulation
    </p>
    <ul>
        <li>Chaque feature log toutes ses évaluations</li>
        <li>Chaque support génétique log les mutations qu'il a subi et chaque mutation est loguée par le système quand elle a lieu</li>
        <li>Chaque individu généré disposera de ces logs et la simulation gardera en mémoire sa date de naissance et de mort</li>
    </ul>

    <p>
        Maintenant on peut faire cette remarque supplémentaire. On peut re-dérouler le fil de l'histoire mais on peut aussi décider, à un moment dans le passé de changer l'histoire ! Comme dans <em>La Vie est Belle</em> de Stephen Jay Gould on peut se poser la question "Est-si on avait mis une petite pichenette ici, est ce que ces espèces seraient encore là aujourd'hui ?" et y répondre ! Car on dispose de tout ce qu'il faut pour re-dérouler le fil de l'histoire et changer une chose, mettre une pichenette, et regarder les deux <em>mondes</em> évoluer vers leurs propres attracteurs.
    </p>
    <p>
        On pourrait faire ça dans n'importe quel modèle heuristique, aléatoire. Mais ici, l'intérêt c'est qu'on peut décider <em>exactement</em> quelle pichnette mettre, et déterminer <em>la cause précise</em> d'une divergence de l'histoire.
    </p>
    <p>
        Comment c'est possible ? Et bien c'est très simple : il suffit de récupérer un phénotype dans le passé d'un individu comme on l'a vu précédemment. On dispose non seulement de son phénotype mais également de son génome, sa valeur à cet instant ! Il suffit alors de dupliquer notre individu et de lui assigner ce phénotype <em>du passé</em>. Du point de vue de notre modèle, nous avons là un clone parfait de l'individu à un instant dans le passé. Si l'environnement peut être reproduit à l'identique, on peut lui faire subir une mutation, le mettre un peu plus à gauche ou à droite que sais-je, et observer la divergence des deux lignes de vie. Les possibilités sont grandes ! Et on peut évidemment faire tout ça à l'échelle d'une population : )  
    </p>

    <p>
        Ce qui est intéressant avec ce système de mémoire, c'est qu'on va pouvoir répondre à des questions intéressantes dans notre programme, prendre des décisions sur le passé. Par exemple on pourra écrire une fonction qui dira "si tel individu, entre telle année et telle année n'a pas dépassé cette taille là, n'a pas eu cette couleur, n'a pas synthétisé 10L de telle molécule... alors...".
    </p>


    <h2 id="environment">Aller plus loin: créer des Environnements (pour finir le boulot)</h2>

    <p>
        Le système fournit aux features une valeur temps (en lecture seule). Et comment faire intervenir des paramètres environnementaux, comme une température ? Chez des lapins, la couleur du pelage dépend de certainez enzymes. Ceux qui ont des couleurs claires sauf aux extrémités indique que des enzymes s'expriment davantage aux basse températures qu'aux hautes températures (reste du corps). 
    </p>
    <p>
        On peut donc imaginer intégrer une autre structure de données (dépendance d'une feature) <code>Environnement</code> qui injecte dans les arguments de la feature une valeur (comme le temps) pour permettre d'évaluer la feature. Si on fait ça, il suffit de rajouter dans le <code>LOG</code> de la feature la valeur l'environnement, par exemple : {date, temperature, valeur}. Ainsi on peut reconstruire toute l'histoire comme avant.
    </p>
    <p>
        Les Environnements fonctionneraient sur le même mode que les mutations, sauf qu'ils ne font pas muter directement le génome, mais conditionne l'expression du phénotype, au même titre que le temps ! Par contre, on peut coupler une mutation à un environnement. Par exemple "si la température dépasse telle valeur déclenche cette mutation". Ainsi, chaque composant a sa responsabilité, la mutation est enregistrée, le génome change, la feature produit une nouvelle valeur (ou non). Et on a toute l'information pour reconstruire l'histoire.
    </p>
    <p>
        Et enfin, pour finir la boucle, faire en sorte qu'une population puisse influencer l'environnement !  Voilà un usage de l'entité population intéressant. Par exemple, pression démographique pousse l'environnement dans un nouvel état, ce qui provoque une mutation ou l'expression du génome. Et la boucle est bouclée ! On peut enfin voir une population s'autoexterminer par destruction de son environnement (tout ça intégré nativement dans le modèle). C'est plus un modèle en fait maintenant, c'est un moteur, un framework.
    </p>

    <h2>Hacker le modèle</h2>

    <p>Il y aurait plein de façons de hacker, de détourner de son usage principal, le modèle pour créer des nouveaux mécanismes au delà des phénotypes et du génome. On pourrait imaginer des features qui ne prennent pas du tout en compte le génome (même indirectement). Et étendre le système d'évaluation dans le temps et de mémoire à des traits non génétiques (opinion politique, goût, caractère, état d'esprit...)</p>


    <h2 id="engine">Moteur : reproduction et transmission du génome</h2>

    <h3>Auto-fertilisation</h3>
    <h3>Clonage</h3>
    <h3>Reproduction Sexuée</h3>
    <h3>Reproduction entre espèces</h3>

    <h2>Modèle reproduction</h2>
    <h3>Méiose</h3>
    <h3>Cross-over</h3>
    <h3>Mitose</h3>

    <h3>Modéliser l'hétérochronie</h3>

    <p>
        <a href="https://fr.wikipedia.org/wiki/H%C3%A9t%C3%A9rochronie#:~:text=L'h%C3%A9t%C3%A9rochronie%20est%20la%20modification,%C3%A0%20celles%20de%20ses%20anc%C3%AAtres.">L’hétérochronie</a> est la modification de la durée et de la vitesse du développement d’un organisme par rapport à celles de ses ancêtres.
    </p>

    <h4>Ontogenèse et phylogenèse</h4>

    <p>
        Chaque individu au cours de sa vie possède une forme de programme de développement. Un trait commence à s'exprimer qu'à partir du moment où un autre trait s'est exprimé jusqu'à un certain stade (ou a fini de s'exprimer).
    </p>
    <p>
        Dans le modèle il faut donc conditionner l'expression d'une feature en fonction d'une autre.
    </p>

    <h4>Les types d'hétérochronie</h4>
    <p>
        Tout d’abord, il existe deux catégories qui nous informent sur l’effet de l’hétérochronie: les changements qui impliquent un sous-développement par rapport à l’ancêtre sont regroupés dans la catégorie de la <em>pédomorphie</em> et ceux qui impliquent un surdéveloppement dans la catégorie de la <em>péramorphie</em>. Chacune de ces deux catégories peut ensuite être divisée en trois catégories qui nous informent sur la nature de l’hétérochronie. Soit l’hétérochronie provient d’un changement de vitesse dans le développement, d’un déplacement du début du développement ou d’un déplacement de la fin du développement.
    </p>

    <table>
        <thead>
            <tr>
                <th colspan="3" style="text-align: center;">Types d'hétérochronie</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Nature/Effet</td>
                <td>Pédomorphie(Sous-développement)</td>
                <td>Péramorphie
                    (surdéveloppement)</td>
            </tr>
            <tr>
                <td>Vitesse du
                    développement</td>
                    <td>
                        Néoténie (ralentissement)
                    </td>
                    <td>
                        Accélération
                    </td>
            </tr>
            <tr>
                <td>
                    Déplacement du début
du développement
                </td>
                <td>
                    Post-déplacement
                </td>
                <td>
                    Pré-déplacement
                </td>
            </tr>
            <tr>
                <td>Déplacement de la fin
                    du développement</td>
                <td>Progenèse/Hypomorphisme
                    (fin prématurée)</td>
                    <td>
                        Hypermorphose
(fin retardée)
                    </td>
            </tr>
        </tbody>
    </table>

    <h4>Déplacement du développement</h4>


    <img src="img/heterochronie.png" alt="Schémas hétérochronie">

    <h4>Deceleration et Accélération du développement</h4>

    <p>
        La néoténie et l'accélération se manifestent sous la forme d'une décélération ou accélération du développement d'un trait, d'une génération à la suivante. Le trait s'exprime sur la même durée <code>t2-t1</code> mais le taux de développement (par exemple un taux de croissance) est plus faible chez le descendant (néoténie) ou plus fort chez le descendant (accélération). La croissance cumulée, sur une même période de la vie d'un individu, est donc différente
    </p>

    $$ \text{Néoténie: } \tau_1 < \tau_0 \equiv \int_{t_1}^{t_2} \tau_{1} dt > \int_{t_1}^{t_2} \tau_{0} dt$$ 
    $$ \text{Accélération: }tau_1 > \tau_0 \equiv \int_{t_1}^{t_2} \tau_{1} dt < \int_{t_1}^{t_2} \tau_{0} dt$$ 

    <p>
        où \(\tau_0\) est le taux de croissance d'un autre trait chez le parent, \(\tau_1\) chez le descendant, \(t_1\) et \(t_2\) sont les ages de l'individu définissant la période de l'expression du gènome (identique chez le descendant et le parent).
    </p>

    <h4>Dans le modèle</h4>

    <p>

    </p>


    <h2>Génération d'une documentation interactive automatique</h2>

    <p>Générer une documentation automatiquement décrivant l'API de chaque Feature dans un projet donné. Cette documentation aidera grandement l'utilisateur a designer ses modèles de données et aussi à les utiliser dans son propre programme.</p>


    <h2>Usage de la bibliothèque (dans les grandes lignes)</h2>
    <p>La bibliothèque sera open-source (évidemment). Le code sera accessible depuis un dépot public. Le code source sera découpé en au moins deux composants:</p>
    <ul>
        <li>code source moteur de la lib (tout ce qui fera tourner le modèle)</li>
        <li>code source des éditeurs, générateur doc, bac à sable</li>
    </ul>
    <p>On pourra imaginer à terme de faire des éditeurs et du bac à sable une web app: éditeur en ligne, création d'une store où les gens peuvent partager leur design et les télécharger (création d'une communauté). Chaque design aura sa doc.</p>

    <p>En tant qu'utilisateur je veux intégrer cette library pour mon projet :</p>
    <ul>
        <li>Je l'installe (avec ses dépendances) dans mon projet (sûrement via npm ou yarn). J'importe seulement le moteur dans mon projet</li>
        <li>Soit:
            <ul>
                <li>j'ai envie de créer mes propres design ou éditer design existants, je lance les éditeurs et je travaille dessus. Quand je suis satisfait, que j'ai testé dans le bac à sable j'exporte les données (sous format d'un fichier). Les données comprennent: les supports génétiques, les features, les espèces, les mutations etc...</li>
                <li>j'ai pas envie d'en faire moi même, d'autres gens en ont peut etre fait des mieux qui me correspondent ou pourraient me servir de base. Je récupère un design de quelqu'un (un fichier) (téléchargable en ligne sur le store), je l'importe, je l'édide et je l'exporte.</li>
            </ul>
        </li>
        <li>J'importe mes fichiers de design dans mon projet</li>
        <li>Je fabrique sûrement un fichier de configuration global demandé par la bibliothèque pour initialiser des choses (sécurité, gestion du temps, gestion des erreurs, generation pop, blabblabla...)</li>
        <li>J'utilise le tout pour fabriquer mon programme !</li>
    </ul>

    <p>Voici un pseudo code de l'utilisation de la bibliothèque (juste pour donner une idée)</p>


<code class="pseudo-code">
        <pre>
 import * as glib from "moteur"

 //Je crée une population initiale  de 50 individus, 
 //de l'espece 'espece#1' que j'ai designé
 const population = glib.generatePopulation('espece#1', 50)
 ...
 //Mon programme arrive à un point
 //où je veux déclencher une mutation designée
 const result = glib.triggerMutation('nomMutation') 
 ...
 //Deux individus se reproduisent et donnent une descendance de 10 individus:
 const offspings = glib.reproduce(individu1,individu2, 10)
 ...
 //Une fleur s'autoféconde pour fabriquer un nombre aléatoire de descendants
 const flowers = glib.reproduce(flower, random(10,100))
 ...
 //Deux individus se reproduisent, le nombre de descendant 
 //est borné par une feature 'capaciteGestation'
 const offspings = glib.reproduce(individu1,individu2, 
 random(1, get_phenotype(individu2,'capaciteGestation')))
 ...
 const killed = glib.kill(population)
 ...
//j'ai déjà ma propre structure de données/objet
//Fish avec son comportement
const fish = new Fish('toto')
console.log(fish) // = {foo:'toto'}
//je veux qu'il puisse se reproduire, le rendre
//genetique
fish = glib.setSpecie(fish, 'espece#1')
//fish dispose maintenant de toutes les features
//de l'espce#1 et peut se reproduire
const babyFish = glib.reproduce({fish, args: {'bar'}},fish2)
//babyFish a conservé tout ce dont il hérite
//de sa structure originelle
console.log(babyFish) // = {foo:'bar', phenotype: {....}} 

//Je veux savoir si mon parent a subi une mutation (provoquée par un accident nucléaire)
//et a commencé à développer un 3e bras
parent = glib.getParent(individu)
troisiemeBras = glib.getPhenotypes(parent,'troisiemeBras')
if(troisiemeBras)
    //Do stuff

        </pre>
    </code>


    

    <h2>Exemples : reproduction de cas connus</h2>

    <h3>Lapins</h3>
    <h3>Snapdragons (dominance incomplète)</h3>
    <h3>Groupe sanguin chez l'Homme (codominance)</h3>

                    </div> <!-- row -->
                </div>
            </div> <!-- row -->
        </div>
    </section>



    <!--====== FOOTER PART START ======-->

    <section class="footer-area footer-dark">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-lg-6">
                    <div class="footer-logo text-center">
                        <a class="mt-30" href="index.html"><img src="assets/images/logo.svg" alt="Logo"></a>
                    </div> <!-- footer logo -->
                    <div class="footer-support text-center">
                        <span class="mail">paul.schuhm@gmail.com</span>
                    </div>
                    <div class="copyright text-center mt-35">
                        <p class="text">Designed by <a href="https://uideck.com" rel="nofollow">UIdeck</a> </p>
                    </div> <!--  copyright -->
                </div>
            </div> <!-- row -->
        </div> <!-- container -->
    </section>

    <!--====== FOOTER PART ENDS ======-->

    <!--====== BACK TOP TOP PART START ======-->

    <a href="#" class="back-to-top"><i class="lni lni-chevron-up"></i></a>

    <!--====== BACK TOP TOP PART ENDS ======-->

    <!--====== PART START ======-->

    <!--
    <section class="">
        <div class="container">
            <div class="row">
                <div class="col-lg-">
                    
                </div>
            </div>
        </div>
    </section>
-->

    <!--====== PART ENDS ======-->




    <!--====== Jquery js ======-->
    <script src="assets/js/vendor/jquery-1.12.4.min.js"></script>
    <script src="assets/js/vendor/modernizr-3.7.1.min.js"></script>

    <!--====== Bootstrap js ======-->
    <script src="assets/js/popper.min.js"></script>
    <script src="assets/js/bootstrap.min.js"></script>

    <!--====== Slick js ======-->
    <script src="assets/js/slick.min.js"></script>

    <!--====== Magnific Popup js ======-->
    <script src="assets/js/jquery.magnific-popup.min.js"></script>

    <!--====== Ajax Contact js ======-->
    <script src="assets/js/ajax-contact.js"></script>

    <!--====== Isotope js ======-->
    <script src="assets/js/imagesloaded.pkgd.min.js"></script>
    <script src="assets/js/isotope.pkgd.min.js"></script>

    <!--====== Scrolling Nav js ======-->
    <script src="assets/js/jquery.easing.min.js"></script>
    <script src="assets/js/scrolling-nav.js"></script>

    <!--====== Main js ======-->
    <script src="assets/js/main.js"></script>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</body>

</html>