<!DOCTYPE html>
<html lang="fr">

<head>
  <script src="js/lib/p5.js"></script>

  <meta charset="utf-8">

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">

  <link href="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/css/bootstrap4-toggle.min.css" rel="stylesheet">

  <!-- code snippet -->
  <link href="css/prism.css" rel="stylesheet" />
  <link rel="stylesheet" type="text/css" href="css/style.css">


</head>

<body>

  <h1>Quadtree</h1>

  <h2>Introduction</h2>

  <h3>Ce que nous allons aborder et ce dont nous ne parlerons pas</h3>

  <p>
    Les <a href="https://fr.wikipedia.org/wiki/Quadtree">Quadtree</a> sont des structures de données qui peuvent être très utiles pour résoudre certains types de problèmes. Précisons d'emblée que cet article ne cherche pas à couvrir de manière
    exhaustive tous les usages et les contextes d'application des Quadtrees. Nous nous nous restreindrons à son usage principal, celui du partitionnement d'un espace à deux dimensions.
    Au lieu de partir de considérations théoriques et générales nous allons plutôt aborder les Quadtrees d'un point de vue pratique en tachant de répondre à ces questions : à quoi un Quadtree peut-il servir ? Qu'est ce qu'un Quadtree ? Comment le
    construire ? Comment l'interroger ? Comment s'en servir ?
    Nous allons donc commencer par proposer une définition d'un Quadtree. Puis, à l'aide de notre définition, nous allons le construire et l'implémenter (en JavaScript ici mais facilement
    reproductible dans n'importe quel langage de programmation). Nous allons ensuite voir comment nous en servir pour manipuler ou interroger efficacement nos données.
    Finalement, nous allons l'utiliser dans un cas pratique où le Quadtree fait largement ses preuves : la détection de collisions.

  </p>



  <h3>Dans quel cas les Quadtrees sont-ils utiles?</h3>

  <p>
    Avant même de définir ce qu'est un Quadtree, il paraît intéressant de voir à quoi peut-il peut servir et à quels types de questions il permet de répondre.
  </p>

  <p>
    Pour nous servir des Quadtrees nous avons besoin d'un espace à deux dimensions (un écran, un sous-espace d'un espace plus grand, une scène où se déplacent des objets, une image etc...)
    et que cet espace contienne des points. Ces points peuvent représenter n'importe quoi, la seule chose qui importe c'est que les <strong>coordonnées de ces points représentent
      quelque-chose</strong>. Par exemple ces points pourraient représenter des particules, les pixels d'une image, les villes d'un pays etc... Les coordonnées ont du sens : deux particules veulent savoir si elles sont en contact ou non, le sens
    d'une image est
    contenu dans les positions relatives de ses pixels, les villes ne sont pas n'importe où !
    Par exemple, un sytème de coordonées peut être défini de sorte à ce qu'un axe représente la distance vers l'avant par rapport à
    l'origine choisie,
    et l'autre celle vers la gauche. La particule pourrait être représentée dans cet espace par un couple de deux valeurs mesurant la position du centre géometrique de la particule. Mais la distance mesurée entre deux points dans un système de
    coordonnées ne se restreint pas
    à
    la mesure d'une distance <i>strictement spatiale</i> : on pourrait tout aussi bien définir un espace avec un axe <i>proportion de voyelles</i> et y représenter des chaînes de caractère. Cet espace permettrait de définir une mesure de proximité
    entre des mots ou
    des phrases par exemple. On pourrait également représenter des points dans un espace où une dimension mesure la position et l'autre le temps etc.
  </p>

  <p>
    Mais prenons l'exemple classique d'un espace à deux dimensions peuplé d'objets, représenté chacun par un point. Pour des raisons pratiques nous appelerons <strong>point</strong> la représentation de l'objet dans notre espace par ses coordonnées.

  <div class="row justify-content-center">
    <figure class="figure">
      <img src="media/figure01.png" class="figure-img img-fluid rounded" alt="un espace bidimensionnel peuplé d'objets représentés par des points" title="un espace bidimensionnel peuplé d'objets représentés par des points" width="452" height="328" />
      <figcaption class="figure-caption text-center">Figure 1 : un espace bidimensionnel peuplé d'objets</figcaption>
    </figure>
  </div>

  Supposons que nous voulions interroger les propriétés de voisinage de ces objets. Par exemple, nous aimerions savoir combien de voisins possède chaque objet dans une zone définie autour de celui-ci? Ces voisins possèdent-ils des propriétés
  analogues ou différentes? Quel
  est le voisin le plus proche de chaque point ? Ou non finalement, qui sont les trois voisins les plus proches ? Ou, tout simplement, combien y'a-t-il d'objets présents dans une zone définie autour d'un point quelconque? La liste n'est pas
  exhaustive, mais toutes ces questions ont ceci en commun :
  elles trouvent leurs réponses dans les mesures des distances entre les points. Elles ont un caractère <i>géometrique</i>.
  </p>

  <div class="row justify-content-center" id="figure02">
    <figure class="figure">
      <img src="media/figure02.png" class="figure-img img-fluid rounded" alt="un espace bidimensionnel peuplé d'objets représentés par des points. Un cercle rouge défini un sous-espace"
        title="Combien de points se trouvent dans le sous-espace défini par le cercle rouge?" width="452" height="328" />
      <figcaption class="figure-caption text-center">Figure 2 : combien de points se trouvent dans <br />le sous-espace défini par le cercle rouge? </figcaption>
    </figure>
  </div>
  <p>
    Reprenons l'une des questions précédentes sur le voisinage : quels sont les objets présents dans une zone bien délimitée de mon espace? Comme nous pouvons le voir sur la <a href="#figure02">figure 2</a>, nous retrouvons notre ensemble d'objets
    dans
    un espace
    bidimensionnel, où chaque objet est repéré par ses coordonnées et représenté par un point blanc. Nous voulons savoir quels sont les objets présents à l'interieur du cercle rouge. Nous voulons, par exemple, sélectionner ces points et leur
    appliquer un traitement particulier. Comment allons-nous nous y prendre? La solution <i>naïve</i> consisterait à parcourir tous les points et à tester s'ils se trouvent à l'intérieur du domaine délimité par le cercle rouge. Cette
    solution demanderait un temps d'execution propotionnel au nombre de points à traiter, on dit qu'elle est <code>O(n)</code>, où <code>n</code> représente le nombre de
    points à parcourir. La <a href="https://fr.wikipedia.org/wiki/Analyse_de_la_complexit%C3%A9_des_algorithmes">complexité</a> d'un algorithme, ou d'une fonction, est une mesure de la quantité de ressources (temps ou mémoire) nécessaire à son
    éxecution : <code>O(n)</code> signifie que les ressources demandées sont proportionnelles à n. Si nous avons un million de points et que notre cercle rouge ne contient que deux points alors nous devrons faire un million d'opérations pour n'en
    sélectionner que deux !
  </p>
  <p>
    Et ce n'est pas tout. Là encore c'est une complexité tolérable. Supposons que nous cherchions à savoir quel est le point le plus proche de chaque point. Pour y arriver nous devrions, pour chaque point, regarder les n - 1 points restants, mesurer
    la distance entre les deux et garder le point pour lequel la distance est la plus courte. Et nous devrions répeter cette opération n fois, pour chaque point. Cela veut dire qu'il faudrait n * (n -1) opérations pour obtenir notre résultat. Il
    serait possible de réduire le coût en ne considérant les paires qu'une fois. Comme chaque paire compte double dans le décompte précédent il est encore possible de diviser par 2 le nombre d'opérations, pour le ramener à n *( n - 1 ) / 2.
    Néanmoins, on
    voit toujours apparaitre un facteur n<sup>2</sup>. La complexité de notre calcul est donc ici en <code>0(n<sup>2</sup>)</code>. Si nous avions un million de points il faudrait faire un billion (1 000 000 000 000) d'opérations pour obtenir notre
    résultat ! Ce n'est
    pas sérieux. La complexité
    <code>0(n<sup>2</sup>)</code> est une complexité qu'il faut éviter à chaque fois que cela est possible, sa mise à l'échelle avec la taille de l'échantillon est trop vertigineuse, et elle indique souvent qu'il y'a <i>un autre chemin</i>.
  </p>

  <p>
    Pou réduire cette complexité l'une des premières choses à faire est de repenser notre structure de données, celle dans laquelle sont rangés nos points. De nombreuses structures de données existent
    et permettent d'organiser les données de manière à faciliter leur traitement. Chaque structure de données possède des avantages et des inconvénients vis à vis du traitement que l'on
    souhaite réaliser. Réduire la complexité et augmenter les performances d'un programme en charge de la réalisation d'un traitement de données passe d'abord par le choix d'une structure de données adaptée.
  </p>

  <p>
    Pour le moment, nos objets sont stockés sous la forme d'un tableau, ou d'une liste, comme il est courant de le faire. Nous devons parcourir le tableau de points et tester pour chacun d'entre eux s'il est à l'interieur de la zone circulaire rouge.
    Mais c'est embêtant, car nous devons tester tous les points, même ceux à l'autre bout de l'espace, loin, si loin de notre zone. Il doit y avoir une meilleure solution. Pouvons-nous mieux faire? Oui, nous pouvons mieux faire ! Et pour mieux faire
    nous avons besoin d'une
    structure de données adaptée à ce genre de problème : le Quadtree.
  </p>


  <p>
    Le Quadtree est une structure de données où l'on va ranger les points dans des petites boîtes. Ces boîtes seront définies en appliquant une décomposition de l'espace en quatre sous-espaces égaux de manière <a
      href="https://fr.wikipedia.org/wiki/R%C3%A9cursivit%C3%A9">récursive</a>. L'espace sera ainsi divisé <i>sur lui même</i> jusqu'à ce qu'aucune boite ne contienne plus de quatre points. C'est son aspect récursif qui
    lui donne la forme d'un arbre (<i>tree</i>). Le <i>quad</i> vient lui du fait qu'on découpe l'espace toujours en quatre. Même si cette définition parait pour le moment très insatisfaisante, nous allons voir que le but du Quadtree est d'organiser
    autrement les points (sans toucher à leur coordonnées bien entendu) pour optimiser drastiquement le coût de nos investigations. Pour reprendre la
    question que nous nous posons, à savoir combien de points sont compris dans le cercle rouge, le problème de la solution naïve vient du fait qu'elle nous force à interroger tout l'espace (et donc tous les points !). Le Quadtree va nous permettre
    d'affiner
    notre requête et d'interroger une partie de l'espace. Mais inutile de bavarder plus longtemps, et rentrons dans le vif du sujet.
  </p>


  <dl>
    <dt>
      Ce qu'il faut retenir
    </dt>
    <dd>
      <p class="togo">
        Les Quadtrees sont des structures de données qui permettent de traiter efficacement des données existantes dans un espace bidimensionnel. L'utilisation d'un Quadtree pour réaliser ces
        traitements offre un gain de performance considérable par rapport à l'approche <i>naïve</i>. Ce bénéfice provient du fait que le Quadtree partitionne l'espace de manière récursive pour ré-organiser les données.
      </p>
    </dd>
  </dl>


  <h2>Définitions</h2>

  <p>
    Mettons nous d'accord sur le vocabulaire et quelques définitions afin de ne laisser place à aucune ambiguité. En effet, il n'y a pas de définition standard du Quadtree, plusieurs implémentations existent et ont chacune leur intérêt et leur
    défaut. Il existe plusieurs stratégies pour le construire et la structure possède plusieurs paramètres (capacité, profondeur...) ajustables par l'utilisateur en fonction de ses besoins. Néanmoins, tous les Quadtrees partagent une définition
    commune : ce sont des structures de type arbre (récursives) dans laquelle chaque noeud a jusqu'à quatre enfants. La suite de cet article s'appuiera sur l'ensemble des défintions suivantes.
  </p>

  <p>

  </p>

  <dl>
    <dt>
      Noeud
    </dt>
    <dd>
      le noeud est le composant fondamental du Quadtree. Le Quadtree est une association de noeuds, et il commence toujours par un noeud initial, un noeud racine. Les points insérés dans un Quadtree finissent toujours attachés à un et un seul noeud.
      Un noeud peut avoir jusqu'à 4 enfants. Le Quadtree possède deux types de noeuds : les branches et les feuilles.
    </dd>
    <dt>
      Branche
    </dt>
    <dd>
      un noeud qui ne peut porter (avoir pour enfant direct) que des noeuds, branche ou feuille, mais jamais de points.
    </dd>
    <dt>
      Feuille
    </dt>
    <dd>
      un noeud qui ne peut porter que des points, mais jamais d'autres noeuds. Lorsque la capacité de la feuille est dépassée elle se transforme en branche.
    </dd>
    <dt>
      Enfant
    </dt>
    <dd>
      un enfant est un élément du Quadtree qui est porté par son noeud parent. Un enfant peut-être un noeud ou un point. Seul un noeud peut être parent. Par exemple, sur la <a href="#figure3"> figure 3</a>, la feuille <i>b</i> est l'enfant de la
      branche <i>a</i>. On dit que <i>a</i> porte <i>b</i>. De même, le point <i>c</i> est l'enfant de la feuille <i>b</i>, mais <i>c</i> n'est pas l'enfant de <i>a</i>, car <i>a</i> ne porte pas directement <i>b</i>.
    </dd>
    <dt>
      Capacité
    </dt>
    <dd>
      le nombre maximal d'enfants qu'une feuille peut porter. Par défaut la capacité est de quatre. Ainsi on conserve une certaine homogénéité dans notre définition : une branche a la même capacité qu'une feuille. Si la capacité d'une branche est par
      définition de 4 (<i>quad</i>tree) la capacité d'une feuille pourrait être supérieure ou inférieure (chaque feuille ne pourrait porter qu'un point par exemple).
    </dd>
    <dt>
      Profondeur
    </dt>
    <dd>
      le niveau auquel se trouve un noeud. La racine a une profondeur de référence arbitraire p définie par l'utilisateur. Les enfants auront une profondeur p + 1. Ici on a défini la profondeur de la racine à 0.
    </dd>
  </dl>


  <div class="row justify-content-center" id="figure03">
    <figure class="figure">
      <img src="media/quadtree.svg" class="figure-img img-fluid rounded" alt="" title="" width="700" />
      <figcaption class="figure-caption text-center">Figure 3 : Exemple d'un Quadtree. Les feuilles portent les points. Notez qu'une branche ne peut porter<br /> que des branches ou des feuilles mais jamais directement des points.
        Chaque noeud peut porter jusqu'à quatre enfants maximum. </figcaption>
    </figure>
  </div>

  <p>
    La <a href="#figure3"> figure 3</a> montre un exemple de Quatree où les points sont répartis sur des feuilles. Ces points sont ceux qui existent dans notre espace bidimensionnel et que nous avons organisés suivant cette étrange structure, au lieu
    de les garder sous forme de liste.

  </p>
  <p>
    Voyons maintenant comment construire un Quatree comme celui-ci et son rapport à notre esapce bidimensionnel. Nous verrons également pourquoi nous distinguons les noeuds en branches
    et en feuilles.
  </p>

  <p>

  </p>


  <h2>Construction</h2>


  <p>Dans le principe, la construction d'un Quadtree est très simple. Prenez une feuille de papier, elle définira notre espace. Placez-y des points où bon vous semble. A présent, donnez vous une capacité, par exemple 2. Divisez la feuille en 4
    rectangles égaux. Comptez le nombre de points dans chaque rectangle. Si un rectangle en contient plus que 2, divisez le en 4 rectangles égaux. Recommencez l'opération jusqu'à ce que chaque rectangle contienne au maximum 2 points. Et voilà ! Sur
    le papier, rien de bien compliqué. Evidemment, pour ce qui est de le programmer les choses se corsent un peu. </p>

  <p>
    Nous allons voir, pas à pas, comment construire une structure de données Quadtree à partir de nos points. Nous allons d'abord insister sur les principes de construction, plutôt que sur les détails de l'implémentation.
    L'objectif premier est d'obtenir un pseudo-code, les détails de l'algorithme sont discutés dans la partie <a href="implementation">implémentation</a>. L'implémentation proposée dans cet article est une suggestion, et n'est évidemment pas la seule
    possible, libre à vous de l'adapter à vos besoins ou de l'améliorer.
  </p>


  <h3>Le point de départ de l'arbre : la racine</h3>
  <p>
    Nous allons commencer par définir la racine de notre Quadtree, le premier noeud. La racine n'a pas de noeud parent par définition et c'est une feuille. A présent il faut faire la connexion entre notre arbre et
    l'espace géometrique : <strong>chaque noeud aura la responsabilité d'une région de l'espace. La racine a
      sous sa responsabilité l'intégralité de l'espace</strong>. Elle sera
    responsable de tout ce
    qu'il se trouve à l'intérieur. C'est ce que l'on peut voir sur la <a href="#figure04">figure 4a</a>, où la racine a la charge de tout le rectangle noir.
  </p>

  <h3>Insérer des points dans le Quadtree</h3>

  <p>
    Nous allons insérer nos points un à un dans l'arbre. Pour chaque point allons interroger la racine de l'arbre :
  <ul style="list-style-type: '&mdash; '">
    <li>
      Est-ce que ce point se trouve dans ta région ?
    </li>
    <li>
      Bien sûr, par définition, tous les points se trouvent dans ma région !
    </li>
  </ul>
  En effet, la racine recouvre tout l'espace disponible. Le point est donc
  attaché à la racine. Nous allons continuer ainsi jusqu'à ce que le noeud racine porte quatre points, comme nous pouvons le voir sur les images <i>b)</i> à <i>e)</i> de la <a href="#figure04">figure 4</a>.
  </p>

  <div class="row justify-content-center" id="figure04">
    <figure class="figure">
      <img src="media/construction.svg" class="figure-img img-fluid rounded" alt="" title="" width="1000" />
      <figcaption class="figure-caption text-center">Figure 4 : Etapes de construction d'un Quadtree par insertions successives de points. A l'étape f) la feuille originale porte 5 enfants.<br /> Ayant dépassé sa capacité de 4, elle se transforme en
        branche et pousse les points sur leurs feuilles respectives. <br />Le prochain point sera porté par l'une des feuilles de profondeur 1 et le processus se répètera.</figcaption>
    </figure>
  </div>

  <h3>Mécanisme de division</h3>

  <p>
    Le noeud racine porte à présent 4 enfants et nous insérons un nouveau point de notre collection. La feuille se retrouve à présent en surcapacité, elle a un point de trop : elle se transforme en branche. D'après notre définition, une branche ne
    peut avoir pour enfant que d'autres noeuds. Elle divise donc la région dont elle a la responsabilité en trois sous-régions égales (la dernière sous-région ne contenant aucun point n'est pas définie). Ces sous-régions sont chacune mises sous la
    responsabilité de nouveaux enfants, des feuilles. Chaque feuille prend
    la charge des points qui se trouvent dans sa région. Chaque point, originellement porté par la branche, se trouve alors poussé sur sa feuille et la structure est de nouveau à l'équilibre. Sur la <a href="figure04">figure 4f</a> on peut voir que 3
    feuilles ont poussé sur l'arbre. Elles contiennent les 5 points insérés. Chacune d'entre elle porte les points qui se trouvent dans la région dont elle est responsable. Enfin, la racine est à présent une branche et elle n'a pour enfant que des
    feuilles.
  </p>

  <p>
    Afin de couvrir l'intégralité du processus de division, il nous reste à discuter de deux cas possibles à la prochaine insertion. Supposons que nous voudrions insérer un point dans le quadrant sud-ouest(2) de notre arbre. Demandons à la racine :
  <ul style="list-style-type: '&mdash; '">
    <li>
      Est-ce que ce point se trouve dans ta région ?
    </li>
    <li>
      Bien sûr, par définition, tous les points se trouvent dans ma région ! Cela dit, celui-ci se trouve aussi dans la région de l'un de mes enfants, c'est donc à lui que revient la responsabilité de s'en occuper. Moi je suis une branche, je ne
      m'occupe plus des points, ce n'est plus mon problème. Demandez donc à ma feuille 2.
    </li>
  </ul>
  Nous allons demander à la feuille 2:
  <ul style="list-style-type: '&mdash; '">
    <li>
      Est-ce que ce point se trouve dans ta région ?
    </li>
    <li>
      Oui, cette région m'appartient désormais, donnez moi votre point, je m'en charge.
    </li>
  </ul>

  Et nous pouvons ajouter un point à la feuille 2, comme montré sur la <a href="#figure05">figure 5g</a>.
  </p>
  <div class="row justify-content-center" id="figure05">
    <figure class="figure">
      <img src="media/construction_suite.svg" class="figure-img img-fluid rounded" alt="" title="" width="800" />
      <figcaption class="figure-caption text-center">Figure 5 : Deux points (en rouge) sont insérés sur l'arbre : la branche délègue la responsabilité à son enfant s'il existe déjà g), <br />ou met à disposition une nouvelle feuille s'il n'existe pas
        encore h)</figcaption>
    </figure>
  </div>
  <p>
    A présent, regardons un deuxième cas de figure, supposons que nous voudrions insérer un point dans la quadrant sud-est(3) de notre arbre. Comme d'habitude, demandons à la racine:
  <ul style="list-style-type: '&mdash; '">
    <li>
      Est-ce que ce point se trouve dans ta région ?
    </li>
    <li>
      Bien sûr, par définition, tous les points se trouvent dans ma région ! Cela dit, celui-ci se trouve dans une sous-région qui n'est sous la responsabilité d'aucun de mes enfants. Cette région est encore sous ma responsabilité mais comme je l'ai
      dit, je ne m'occupe plus personnellement des points, je suis une branche ! Voici, je vais faire pousser une feuille et celle-ci s'en chargera.
    </li>
  </ul>
  Sur la <a href="#figure05">figure 5h</a> une feuille 3 a poussé. Nous pouvons aller lui demander, comme précédemment, si elle veut de notre point, et comme celui-ci se trouve dans la région dont elle a la responsabilité elle le portera.
  </p>

  <p>
    En guise d'exercice, vous pouvez essayer de continuer de construire cet arbre avec des points choisis arbitrairement, en appliquant ces règles. Vous verrez les feuilles se transformer en branches, les branches créer des feuilles, et vos points se
    répartir d'une feuille à l'autre au gré de la construction.
  </p>

  <p>
    <a href="#demo01">Une démo interactive</a> de création et d'inspection du Quadtree est disponbile dans l'article. Vous pouvez y expérimentez la construction d'un Quadtree point par point, par un simple clic sur le canvas. Le nombre de branches et
    de feuilles de l'arbre sont affichés pour vous permettre de savoir si vous avez bien compris les mécanismes de division.
  </p>


  <h3>Pseudo-code</h3>

  <p>
    Maintenant que nous avons bien défini le comportement de notre arbre et de ses composants, nous pouvons écrire un pseudo-code de l'algorithme de construction de notre arbre. La construction n'est rien d'autre qu'une succession d'insertion
    de point au niveau de
    la racine. Voici à quoi le pseudo-code de la fonction d'insertion pourrait ressembler:
  </p>

  <div>
    <pre class="language-javascript">
    <code><span class="variable">racine</span>.<span class="function">inserer</span>(point){
      <span class="if-else">if</span> <span class="statement">le point n'est pas dans mon domaine</span>
        quitter;

      <span class="if-else">if</span> <span class="statement">le point est dans le domaine d'un de mes enfants</span>
        <span class="variable">enfant</span>.<span class="function">inserer</span>(point);
      <span class="if-else">else</span>

        <span class="if-else">if</span> <span class="statement">je suis une branche</span>
          creer un nouvel enfant feuille
          <span class="variable">enfant</span>.<span class="function">inserer</span>(point)
        <span class="if-else">else</span>
          <span class="function">porter</span>(point)

        <span class="if-else">if</span> <span class="statement">j'ai plus de 4 enfants</span>
          se transformer en <span class="variable">branche</span>
          creer autant d'enfants feuille que nécessaire : <span class="variable">mes_feuilles</span>
          recuperer tous mes points : <span class="variable">mes_points</span>
          <span class="variable">mes_feuilles</span>.<span class="function">inserer</span>(<span class="variable">mes_points</span>)
      }</code></pre>

  </div>



  <h2 id="implementation">Implémentation</h2>

  <p>
    Cette partie portera sur l'implémentation (en JavaScript) d'un Quadtree. Nous allons implémenter le composant <i>noeud</i> et la fonctionalité d'insertion. Tous les détails de l'implémentation ne sont pas mentionnés, notamment le code concernant
    les fonctions auxiliaires. Il est cependant accessible dans le <a href="#">code-source</a>.
  </p>


  <h3>Implémentation du noeud : <code>class Node</code> </h3>

  <p>
    Un noeud est la structure fondamentale de l'arbre. Elle possède une région, un espace géometrique, dont elle a la responsabilité. Cette région est rectangulaire et est entièrement définie par les variables <code>x,y,w,h</code> où
    <code>(x,y)</code> représentent <strong>le centre</strong> du rectangle et <code>(w,h)</code> sa <strong>demi-largeur et
      demi-longueur</strong>.

  </p>
  <p>
    Un noeud a en pratique toujours 4 enfants, donc <code>children</code> est un tableau de 4 éléments, un pour chaque enfant. Les enfants sont initialisés sous la forme d'un tableau vide. Chaque indice du tableau
    <code>children</code> correspond à une sous-région de l'espace détenu par le noeud, comme représenté sur <a href="figure04">la figure 4</a>. On peut voir que l'espace est virtuellement pré-découpé en 4 sous-regions
    par des traits pointillés blancs. L'indice, allant de 0 à 3 sert d'identité à chaque sous-région. Ainsi <code>children[0]</code> retourne soit l'ensemble des points contenus dans la sous-région <code>0</code> du noeud si le noeud est une feuille,
    soit une feuille si le noeud est une branche.
  </p>

  <p>
    Un attribut <code>capacity</code> définit la capacité de chaque feuille, égale par convention au nombre d'enfants max, soit 4. Un noeud nouvellement crée est par défaut une feuille, et sa profondeur est initialisée à
    partir de celle de son parent, où à 0 dans le cas de la racine.
  </p>


  <div>
    <pre class="language-javascript line-numbers">
    <code >class Node {

        constructor(x, y, w, h, depth = 0) {

          //Region sous responsabilité : (x,y) position du centre, (w,h) demi largeur/hauteur
          this.x = x;
          this.y = y;
          this.w = w;
          this.h = h;
          //                 0   1   2   3
          this.children = [ [], [], [], [] ];

          this.isBranch = false;

          //Capacité
          this.capacity = this.children.length;

          //taille
          this.length = 1;

          //profondeur
          this.depth = depth;
        }
        //Methodes a implementer
        insert( point ){}
        query( area ){}
      }</code></pre>

  </div>

  Pour initialiser la racine il suffira de l'instancier dans notre programme avec <code>let racine = new Node(x, y, w, h)</code>, où <code>(x, y, w, h)</code> sont les données géometriques de l'espace où se trouvent vos points, typiquement les
  propriétés de votre écran.

  <h2 id="implementation">Implémentation de l'insertion : <code>insert(point)</code></h2>

  <p>
    Maintenant que nous avons initialisé notre arbre il faut pouvoir y insérer nos points. C'est le but de la méthode <code>insert(point)</code>. Tout d'abord nous vérifions si le point est contenu dans la région contrôlée
    par le noeud. Si ce n'est pas le cas alors on ne l'insert pas, tout simplement. Un point généré en dehors de votre écran n'intéresse pas le Quadtree.
  </p>
  <p>
    Si le noeud contient le point, la méthode <code>index(point)</code> se charge de récupérer l'index de la sous-région dans laquelle il se trouve. Cet index, allant de 0 à 3 est celui représenté sur <a href="figure04">la
      figure 4</a>. Il permet d'accèder à l'enfant en charge du sous-espace. Nous pouvons ensuite interroger l'enfant <code>children[index]</code>.
  </p>
  <p>
    L'instruction <code>children[index] instanceof
      Node</code>, à la ligne 8, est une syntaxe de la norme <a href="https://www.w3schools.com/js/js_es6.asp">ECMAScript 6</a>. Sous le capot aucun cast, JavaScript se contente de tester si <code>children</code> possède, dans sa <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">chaîne de prototype</a>, une référence vers le prototype du constructeur <code>Node</code>.
  </p>
  <p>
    Deux cas se présentent :
  </p>

  <p>
  <ul>
    <li>
      si l'enfant est un noeud, le noeud parent lui délegue le travail et la méthode <code>insert(point)</code> est appelée récursivement sur l'enfant. Le travail est terminé pour le noeud parent.
    </li>
    <li>
      si l'enfant n'est pas un noeud, mais encore un tableau, alors deux cas se présentent :
      <ul>
        <li>
          soit le noeud en cours est une branche qui n'a pas encore fait poussé de feuille dans cette sous-région. Dans ce cas on fait pointer l'enfant sur une nouvelle feuille : <code>children[index] =
            getNewNode(index)</code>. Puis on lui demande de s'occuper du point. La méthode <code>getNewNode(index)</code> prend en paramètre l'index de la sous-région sur laquelle il doit pointer et renvoie une feuille
          toute fraiche ayant la charge de cette sous-région. Mais, et si <code>children[index]</code> contenait des points, alors nous pourrions les perdre dans cette opération, non? Non, car le noeud est une branche ! Et
          par définition, une branche ne porte jamais de points.
        </li>
        <li>
          soit c'est une feuille et dans ce cas il garde tout simplement le point.
        </li>
      </ul>
    </li>
  </ul>
  </p>


  <p> Il reste une dernière étape avant de terminer cette fonction. Il faut implémenter la transformation en branche d'une feuille lorsque celle-ci est en surcapacité. C'est le rôle de la dernière évaluation.</p>



  <div>
    <pre class="language-javascript line-numbers">
    <code>insert(point) {

        if (!this.contains(point))
          return;

        let index = this.index(point);

        if (this.children[index] instanceof Node) {
          this.children[index].insert(point);
          return;
        } else {

          //Si c'est une branche alors il faut créer une nouvelle feuille et y insérer le point
          if (this.isBranch) {
            this.children[index] = this.getNewNode(index);
            this.children[index].insert(point);
            return;
          }

          //C'est une feuille, elle porte le point
          this.children[index].push(point);

          //Si la feuille a dépassé sa capacité elle se transforme en branche
          if (this.hasReachedMaxCapacity())
            this.branch();
        }
      }</code></pre>
  </div>

  <p>
    Le code de la méthode <code>branch()</code> est montré ci-dessous. Rappelons nous : lorsqu'une feuille porte plus de 4 points, elle est en sur-capacité et se change en branche. Elle doit alors instancier de nouvelles
    feuilles
    et pousser ses points dessus. A la fin, la branche ne doit avoir que des feuilles pour enfant.
  </p>

  <p>
    Nous parcourons alors tous les enfants de la feuille. Ces enfants, par définition, <strong>sont garantis d'être des tableaux de points</strong>. C'est pour cela que dans la boucle <code>children.forEach((points,index))</code> la référence vers
    chaque enfant est nommée <code>points</code>, et non <code>child</code>. Nous ne voulons pas instancier plus de feuilles que nécessaire, c'est
    pourquoi nous instancions une feuille que lorsqu'un enfant contient des points. Une fois l'enfant transformé en feuille, nous insérons les <code>points</code> dedans.
  </p>

  <div>
    <pre class="language-javascript line-numbers">
    <code>branch() {
        //Seule une feuille peut devenir une branche, ses enfants sont nécessairement des tableaux de points
        this.children.forEach((points, index) => {
          //Si un enfant contient des points, créer une feuille a la place...
          if (points.length !== 0) {
            this.children[index] = this.getNewNode(index);
            //...et y insérer les points
            for (let p of points)
              this.children[index].insert(p);
          }
        });
    }</code></pre>
  </div>


  <h2>Démo interactive</h2>

  <p>
    Ci-dessous vous trouverez une démo interactive de cette implémentation. Vous pouvez insérer des points par un simple click sur le canvas. Vous pouvez insérer point par point pour bien suivre l'évolution du nombre de branches et de feuilles, soit
    par nuages de points. Une zone d'inspection, qui suit le mouvement du curseur, est également à disposition pour inspecter le Quadtree. Vous pouvez régler sa taille. Elle détecte les points contenus à l'intérieur du cercle. Le nombre de
    points candidats montre combien de points il a fallu interroger pour obtenir ce résulat. Vous pouvez observer qu'il est possible de selectionner les points à l'intérieur du cercle sont évaluer tous les points présents (sauf s'ils y sont tous bien
    sûr). Les lignes blanches marquent les frontières des neuds. Un noeud en surbrillance indique une feuille intérogée par la zone d'inspection. Nous verrons dans la prochaine partie comment inspecter et nous servir du Quadtree. N'hésitez pas alors
    à revenir expérimenter avec cette démo.
  </p>


  <div class="row justify-content-center" id="demo01">


    <h4>Insertion</h4>
    <div class="radioContainer">
      <input type="radio" id="normal" name="insertionModeGroup" value="point" checked="checked">
      <label for="point"><acronym title="Insère un unique point à chaque clic">Point</acronym></label>

      <input type="radio" id="gaussian" name="insertionModeGroup" value="gaussian">
      <label for="gaussian"><acronym title="Insère un nuage gaussien de points à chaque clic">Nuage de points</acronym></label>

      <label for="nbPointsGaussian">Nombre de points à insérer</label>
      <input type="range" id="nbPointsGaussian" name="nbPointsGaussian" value="100" min="10" max="250" disabled="">
      <output id="nbPointsGaussianValue"></output>
    </div>

    <h4>Inspection</h4>
    <div class="slideContainer">
      <label for="sliderProbeSize">Taille zone d'inspection</label>
      <input type="range" min="10" max="200" value="100" id="sliderProbeSize" name="sliderProbeSize">
    </div>

    <h4>Infos</h4>
    <div class="infos">
      <div>
        <label for="nbBranch">Nombre de branches : </label>
        <span id="nbBranch" name="nbBranch"></span>
      </div>

      <div>
        <label for="nbLeaf">Nombre de feuilles : </label>
        <span id="nbLeaf" name="nbLeaf"></span>
      </div>

      <div>
        <label for="nbPointsTotal">Nombre de points : </label>
        <span id="nbPointsTotal" name="nbPointsTotal">0</span> points
      </div>


      <div id="groupNbPoitnsEvaluated">
        <label for="nbPoitnsEvaluated" <acronym title="Nombre total de points évalués lors de la requête (présence ou non dans la zone circulaire)"><b>Points candidats (% Total)</b> : </label>
        <span id="nbPoitnsEvaluated" name="nbPoitnsEvaluated"></span>
      </div>

      <div id="groupNbPoitnsSelected">
        <label for="nbPoitnsSelected" <acronym title="Nombre total de points évalués et retournés par la reqûete (présence ou non dans la zone circulaire)"><b>Points inclus dans la zone d'inspection (% Total) : </b></label>
        <span id="nbPoitnsSelected" name="nbPoitnsSelected"></span>
      </div>

    </div>

    <div class="resetButtonContainer">
      <!-- <input type="button" value="reset"> -->
      <button type="button" class="btn btn-primary btn-sm" id="resetButton">Réinitialiser</button>
      <input id="switch-demo01" type="checkbox" data-toggle="toggle" checked data-on="En cours" data-off="En Pause" data-onstyle="success" data-offstyle="warning" data-size="sm" class="switch-demo">
    </div>
    <div>Naviguer vers la démo: <a href="#demo01">1</a> - <a href="#demo02">2</a> - <a href="#demo03">3</a></div>
    <div id="canvas-demo01-insert-querry" class="myCanvas">

    </div>
  </div>

  <br />
  <p>
    Nous avons à présent construit notre Quadtree. Notre structure de données est enfin prête. La partie intéressante peut commencer, nous allons à présent nous servir de notre Quadtree pour obtenir des réponses aux questions que nous nous posions !
  </p>

  <h2>Se servir (enfin) du Quadtree</h2>

  <h3>Rappel</h3>
  <p>
    La question que nous nous posions à la base était la suivante : quels sont les points, sur la <a href="#figure02">figure 2</a>, présents à l'interieur du cercle rouge ? Et nous voulions y répondre sans devoir interroger l'intégralité des points
    et
    écopper de la complexité <code>0(n)</code>. Pour cela nous avons ré-organisé nos données dans une structure Quadtree. Comment récupérer les points que nous cherchons ?
  </p>

  <h3>Pseudo-code d'une requête</h3>
  <p>
    Nous devons définir notre zone d'inspection, notre cercle rouge, comme dans <a href="#demo01">la démo</a>. Dans ce cas ci la zone d'inspection est vraiment très simple: elle est définie par les coordonnées de son centre et par un rayon. Nous
    allons initialiser notre requête au Quadtree en demandant à la racine si notre cercle recouvre, même partiellement, l'espace mis sous sa reponsabilité. Si c'est le cas, et si la racine a des noeuds enfants, alors le cercle doit nécessairement
    recouvrir au moins une des sous-régions à la charge de l'un de ses enfants. Récursivement nous allons donc interroger les enfants recouverts jusqu'à arriver sur les feuilles. Les feuilles sont les noeuds les plus profonds de l'arbre, il n'y a
    rien en dessous, mis à
    part nos points. Les enfants des feuilles sont les points que nous cherchons. Nous n'avons plus qu'à remonter tous les points contenus dans les feuilles recouvertes par notre cercle. Le pseudo-code est de la forme :
  </p>



  <div>
    <pre class="language-javascript">
    <code><span class="variable">racine</span>.<span class="function">query</span>(cercle_rouge){

      <span class="if-else">if !</span><span class="statement">cercle_rouge</span>.<span class="function">recouvre</span>(<span class="variable">racine.region</span>)
        quitter;

      Pour chaque <span class="variable">enfant</span>
        <span class="if-else">if</span> <span class="variable">enfant</span> est un noeud
          <span class="variable">enfant</span>.<span class="function">query</span>(cercle_rouge)
        <span class="if-else">else</span>
          Pour chaque <span class="variable">point</span> de <span class="variable">enfant</span>
            <span class="if-else">if</span> <span class="statement">cercle_rouge</span>.<span class="function">contient</span>(<span class="variable">point</span>)
              garder <span class="variable">point</span>
   }</code></pre>
  </div>

  <p>
    Nous profitons ici de l'architecture en arbre. Le fait d'avoir partionné l'espace de manière récursive nous permet de changer la manière dont nous posons notre question : nous ne demandons plus "parmi tous les points quels sont ceux qui se
    trouvent dans le cercle rouge ?". La complexité <code>0(n)</code> est loin maintenant. L'espace étant divisé et mis sous la reponsabilité d'une multitude de noeuds, nous n'avons plus qu'à descendre l'arbre étage par étage. Tant qu'un noeud nous
    répond "oui, vous me recouvrez" nous continuons à poser encore et toujours la même question. Jusqu'à arriver au dernier noeud, à la feuille qui nous dit "oui, vous me recouvrez, tenez, voici les points que j'ai sous ma responsabilité". Et là,
    seulement à ce moment là, on peut tester si le point est contenu dans le cercle rouge.


  <div class="row justify-content-center" id="figure06">
    <figure class="figure">
      <img src="media/requete.svg" class="figure-img img-fluid rounded" alt="" title="" width="800" />
      <figcaption class="figure-caption text-center">Figure 6 :</figcaption>
    </figure>
  </div>


  <p>
    En somme, grâce au travail préalable de division de l'espace et de construction de l'arbre nous avons déplacé ce sur quoi porte notre question : nous ne demandons plus aux points "êtes vous dans le cercle?", nous demandons aux noeuds "êtes vous
    dans le cercle?" Et si un noeud nous répond non, nous n'irons pas poser la question à ses noeuds enfants. Nous pouvons alors tout simplement abandonner les recherches dans la région sous sa reponsabilité, il n'y aucune chance qu'un de ses points
    se trouve dans notre cercle. Un pan entier de l'espace est soustrait à nos efforts de recherche.
  </p>

  <h3>Complexité d'une reqûete</h3>
  <p>
    Analyser la complexité d'une requête dans un Quadtree n'est pas évidente car elle dépend de la requête elle même et de la structure de l'arbre. Cependant nous pouvons estimer les complexité aux cas limites : si tous les points sont présents dans
    notre cercle rouge alors nous retombons sur la pire complexité, en <code>0(n)</code>. Si cette situation se présente majoritairement cela ne signifie pas que le Quadtree est à blâmer, mais plutôt qu'il y'a un problème en terme de design au niveau
    de votre programme. Si 99% des points sont systématiquement candidats à votre requête alors l'utilisation d'un Quadtree n'est pas nécessairement pertinent. A l'inverse, si la requête est très ciblée, et qu'une seule feuille est recouverte par le
    cercle, elle va traverser l'arbre directement de la racine à la feuille et la complexité sera de <code>0(p)</code>, où p est la profondeur de la feuille. On peut donc au moins garantir que la complexité de notre requête est comprise entre
    <code>0(p)</code> et <code>0(n)</code>. C'est déjà une grande nouvelle, car la complexité <code>0(n)</code> qui était garantie à 100% par notre solution naïve est désormais devenue celle du cas le plus extrême.
  </p>


  Voyons à présent les détails de l'implémentation de la requête.
  </p>
  <h2 id="implementation">Implémentation de l'interrogation du Quadtree : <code>query()</code></h2>

  <pre id="query" class="language-javascript line-numbers">
    <code class="language-javascript">query(circleProbe, points) {

        if (!points) {
          points = [];
        }

        let boundingBox = {
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h
        };

        if (!circleProbe.intersects(boundingBox))
          return;

        this.children.forEach(child => {

          if (child instanceof Node)
            child.query(circleProbe, points);
          else
            child.forEach(p => {
              if (circleProbe.contains(p))
                points.push(p);
            });

        });

        return points;
    }</code></pre>

  <p>
    La méthode <code>query</code>, tout comme la méthode <code>insert</code>, fonctionne de manière récursive et est appelée sur le noeud racine. Elle prend en argument la zone d'inspection circulaire <code>circleProbe</code> et <code>points</code>,
    le tableau de points contenant le résultat de notre requête, à savoir l'ensemble des points contenus dans <code>circleProbe</code>. Ici la subtilité c'est que <code>query</code> est une fonction récursive et qu'elle doit retourner un résultat,
    comme ici
  </p>
  <pre class="language-javascript">
  <code class="language-javascript"> let pointsInsideCircleProbe = rootNode.query(circleProbe);</code></pre>

  <p>La méthode est donc appelée sans l'argument optionnel <code>points</code>, <code>points</code> aura donc pour valeur <code>undefined</code> lors du premier appel sur le noeud racine. Dans ce cas, nous assignons à <code>points</code> un tableau
    vide. La variable <code>points</code> va servir de <em>variable globale</em> à l'ensemble des appels récursifs de <code>query</code>.</p>
  <p>
    Nous regardons d'abord, à la ligne 14, si la zone d'inspection recouvre la zone sous la responsabilité du noeud courant. Si ce n'est pas le cas, alors on retourne, il n'y a rien à voir. Si c'est le cas, on parcourt les enfants du noeud :
  <ul>
    <li>si l'enfant est un noeud, le noeud courant est une branche. <code>circleProbe</code> pourrait recouvrir ce noeud enfant et la méthode <code>query</code> est appelée </li> sur lui.
    <li>si l'enfant n'est pas un noeud, le noeud courant est une feuille. <code>circleProbe</code> pourrait alors contenir un ou plusieurs points portés par ses enfants. On parcourt les points attachés à la feuille (ligne 22) : si un point est
      contenu dans <code>circleProble</code> on l'ajoute à <code>points</code>.</li>
  </ul>
  </p>

  <p> Remarquez qu'à la ligne 22, on retrouve le parcours de tous les points contenus dans la région sous la responsabilité de la feuille. On voit ici clairement le bénéfice du Quadtree: au lieu d'interroger tous les points de l'espace, comme dans la
    solution naïve, on interroge ici <strong>seulement les points contenus dans cette sous-région</strong>.</p>

  <p>Enfin, le premier appel de <code>query</code> sur le noeud racine retourne <code>points</code>. </p>

  <p>Visualisez la méthode <code>query</code> sur la <a href="#demo01">demo 1</a>. La zone circulaire autour du pointeur de la souris représente <code>circleProbe</code>. Vous pouvez alors visualiser l'ensemble des points à l'intérieur mais également
    l'ensemble des points candidats à la requête. Vous pouvez voir que le nombre de points parcourus et évalués n'est pas systématiquement égal au nombre de points total, comme dans le cas de la solution naïve. Ce cas se présente d'ailleurs très
    rarement et généralement le nombre de points évalués lors de la requête est une petite fraction du nombre de points total.</p>

  <p>On peut enfin goûter ici à la puissance et à l'intérêt du Quadtree.</p>


  <h2>L'intérêt des branches et des feuilles</h2>


  <p>
    Vous vous demandez peut-être à ce stade pourquoi avoir pris la peine de distinguer les noeuds en branches et en feuilles.
  </p>
  <p>
    Le fait qu'un noeud, une fois atteint sa capacité maximale, se divise et ne compte parmi ses enfants que d'autres noeuds a un intérêt. Le concept de <em>branche</em> a un intérêt. Imaginons qu'un noeud ait à la fois des points et des noeuds pour
    enfants, et que nous ne faisions pas la distinction entre branche et feuille. Si nous interrogeons ce noeud et que notre zone d'inspection l'intersecte alors nous n'aurions pas d'autre choix que d'évaluer tous ses enfants points, peut importe où
    ils
    se trouvent, à la <a href="#query">ligne 22 du code précédent</a>. Imposer à un noeud d'avoir que des enfants noeuds (branche) ou que des enfants points (feuille) nous préserve d'évaluations inutiles.
  </p>
  <p>
    Enfin, le fait qu'un noeud qui devient branche ne se subdivise pas automatiquement en 4 feuilles mais uniquement en autant de feuilles que nécessaire, nous permet d'éviter des appels inutiles de <code>query</code>. En effet, si nous divisions
    automatiquement en 4 chaque noeud en surcapacité, celui-ci pourrait créer des feuilles vides. <a href="#query">Aux lignes 19 et 20</a> nous ferions alors des appels inutiles de <code>query</code> sur ces noeuds enfants vides.
  </p>

  <h2>Paramètres du Quadtree : capacité et profondeur</h2>

  <p>
    Ces paramètres permettent d'optimiser les performances du Quadtree en insertion (<code>insert</code>) ou en recherche (<code>query</code>). Ces considérations dépassent l'ambition de cet article mais il est utile néanmoins d'en discuter un peu
    pour que vous soyez au moins conscient de ces aspects.
  </p>

  <p>
    Le Quadtree possède deux paramètres ajustables par l'utilisateur : la capacité et la profondeur. La capacité est le nombre de points maximal que peut porter une feuille, la profondeur (ou aussi appelée <em>taille</em> de l'arbre) est une mesure
    de la récursivité de l'arbre. Plus il est profond plus il est nécessaire de faire des appels récursifs pour récupérer les points. On remarque que ces deux paramètres sont corrélés : plus la capacité des noeuds est grande, moins il sera profond et
    inversement.
  </p>



  <h3>Définir une profondeur maximale</h3>
  <p>
    Dans cette implémentation il n'y a aucune restriction sur la profondeur de l'arbre. Chaque noeud peut se diviser et donner naissance à d'autres noeuds plus profonds. On pourrait très facilement rajouter cette fonctionalité en définissant une
    profondeur maximal <code>MAX_DEPTH</code> mettant une condition sur la méthode <code>branch()</code> :
  </p>
  <div>
    <pre class="language-javascript line-numbers">
    <code>insert(point) {
          ...
          if (this.hasReachedMaxCapacity() && this.depth < MAX_DEPTH)
            this.branch();
        }
      }</code></pre>
  </div>

  <p>
    Ainsi, l'arbre aura une taille maximale qu'il ne peut pas dépasser, et les feuilles a la profondeur maximale porteront un nombre indeterminé de points (au delà de leur capacité), ceux-ci <em>s'entasseront au fond</em> de l'arbre.
  </p>
  <p>
    Y'a-t-il un intérêt à définir une profondeur maximale ? Cela dépend des cas mais c'est un choix judicieux lorsqu'on souhaite avoir un peu de contrôle sur les appeles récursifs. Par exemple, dans le cas où vous avez une scène remplie de points
    infinement proches (séparés de quelques pixels). Ces points très proches pourraient être le centre d'objets superposés. Sans profondeur maximale imposée votre Quadtree risque d'avoir des profondeurs localisées très importantes là où les points
    sont infiniment proches. Cette <em>surpartition</em> de l'espace n'est pas très utile car en pratique, si vous voulez faire de la détection de voisinage de l'un de ces points, toutes ces feuilles seront de toute manière inspectées.
  </p>

  <h3>Quelle valeurs choisir pour la capacité et la profondeur maximale?</h3>

  <p>
    La réponse à cette question n'est pas évidente mais elle pourrait être "cela dépend de ce que vous voulez".
  </p>


<!-- TODO : reformuler et synthétisez -->
  <!-- <p>
    Si vous voulez construire rapidement le QuadTree alors vous avez besoin d'un <code>insert</code> rapide. Pour cela, il suffit d'augmenter la capacité de l'arbre : plus une feuille pourra porter de points, moins elle aura de chance de se
    subdiviser. Ainsi, augmenter la capacité diminue le nombre d'appels récursifs d'<code>insert</code> et diminue le nombre d'appels à <code>branch</code>.
  </p>

  <p>
    Cela dit, en gagnant de l'efficacité à la construction vous en perdez nécessairement en recherche, car il faudra évaluer plus de points à chaque appel de <code>query</code>.
    D'un autre côté, si vous diminuez la capacité vous augmenter la profondeur de l'arbre. La profondeur de l'arbre est mauvaise à la fois à la construction et à la recherche : plus elle est grande, plus la recherche est lente car il faut faire plus d'appels récurifs de <code>query</code>. -->
  <p>

  <p>
     Comme nous l'avons vu, il n'y a pas de réponse toute faite. Dans cette implémentation nous avons avons donné choisi une valeur de 4, ce qui est un choix totalement arbitraire. Au final, choisir ces valeurs fait partie d'un processus plus large qui est celui de l'optimisation de notre Quadtree. L'optimisation dépend du problème que l'on
    cherche à résoudre mais également d'autres éléments non négligeables : des propriétés même de nos points (dispersion et nombre), de l'implémentation, de l'utilisation de la mémoire etc.
  </p>
<p>
  Voilà pourquoi ces aspects méritent d'être mentionnés, mais ne seront pas traités en profondeur ici, car ce n'est pas le but de l'article. L'optimisation vient toujours après la réalisation. Des sources en bas de l'article sont proposées pour aller plus loin sur l'optimisation.
</p>


  <h4>Insertion</h4>

  <div id="demo02">
    <div id="radioContainer-demo02">

      <input type="radio" id="normal-demo02" name="insertionModeGroup-demo02" value="point" checked="checked">
      <label for="point"><acronym title="Insère un unique point à chaque clic">Point</acronym></label>

      <input type="radio" id="gaussian-demo02" name="insertionModeGroup-demo02" value="gaussian">
      <label for="gaussian"><acronym title="Insère un nuage gaussien de points à chaque clic">Nuage de points</acronym></label>

      <label for="nbPointsGaussian-demo02">Nombre de points à insérer</label>
      <input type="range" id="nbPointsGaussian-demo02" name="nbPointsGaussian-demo02" value="100" min="10" max="250" disabled="">
      <output id="nbPointsGaussianValue-demo02"></output>
    </div>

    <h4>Infos</h4>
    <div class="highlightContainer">

      <label for="depth_current" <acronym title="Profondeur du noeud sous la souris">Profondeur sous le curseur: </label>
      <span id="depth_current" name="depth_current"></span>

      <label for="depth_max" <acronym title="Profondeur maximale observée dans le Quadtree">Profondeur maximale de l'arbre: </label>
      <span id="depth_max" name="depth_max"></span>

      <div>
        <label for="nbPointsTotal-demo02">Points insérés : </label>
        <span id="nbPointsTotal-demo02" name="nbPointsTotal-demo02">0</span>
      </div>

    </div>
    <div class="resetButtonContainer_demo02">
      <!-- <input type="button" value="reset"> -->
      <button type="button" class="btn btn-primary btn-sm" id="resetButton-demo02" disabled>Réinitialiser</button>
      <input id="switch-demo02" type="checkbox" data-toggle="toggle" data-on="En cours" data-off="En Pause" data-onstyle="success" data-offstyle="warning" data-size="sm" class="switch-demo">
    </div>

    <div>Naviguer vers la démo: <a href="#demo01">1</a> - <a href="#demo02">2</a> - <a href="#demo03">3</a></div>
    <div id="canvas-demo02-depth" class="myCanvas">

    </div>

  </div>


  <h2>Attacher des données aux feuilles</h2>

  <h2>Utilisation d'un Quadtree pour la détection de collisions</h2>


  <div id="demo03">
    <div>
      <div id="radioContainer-demo03">

        <input type="radio" id="quadtree" name="algorithme" value="quadtree" checked="checked">
        <label for="quadtree"><acronym title="Utiliser le quadtree">Quadtree</acronym></label>

        <input type="radio" id="naive" name="algorithme" value="naive">
        <label for="naive"><acronym title="Utiliser l'algorithme naïf qui parcourt toutes les paires">Approche naïve</acronym></label>



        <label for="nbParticules">Nombre de particules</label>
        <input type="range" id="nbParticulesRange" name="nbParticules" value="200" min="2" max="1000">
        <output id="output-nbParticules"></output>
      </div>
    </div>

    <h4>Infos</h4>
    <div>
      <label for="timeToBuildQuadtree" <acronym title="Temps d'éxecution nécessaire à la construction du quadtree uniquement">Temps construction du Quadtree (ms) : </label>
      <span id="timeToBuildQuadtree" name="timeToBuildQuadtree"></span>
    </div>
    <div>
      <label for="timeToComputeInteractions" <acronym
        title="Temps d'execution nécessaire au calcul de toutes les interactions. Dans le cas de l'approche naive le calcul mesure le temps nécessaire pour parcourir toutes les paires de particules. Dans le cas du Quadtree, le calcul comprend le temps de construction du Quadtree et des querry.">Temps
        total du calcul de toutes les interactions (ms) :</label>
      <span id="timeToComputeInteractions" name="timeToComputeInteractions"></span>

      <div><label for="pourcentage" <acronym title="Rapport (en %) du temps nécessaire à la construction du Quadtree par rapport au temps nécessaire au calcul des interactions">Rapport du temps de
          construction du Quadtree au temps du calcul des interactions (%):</label>
        <span id="pourcentage" name="pourcentage"></span></div>


      <div>
        <label for="frameRate">FrameRate (frames/s): </label>
        <span id="frameRate">0</span>
      </div>
    </div>

    <div>
      <input type="checkbox" name="showQuadTreeCheckbox" id="showQuadTreeCheckbox">
      <label for="showQuadTreeCheckbox">Afficher quadtree</label>
      <input type="checkbox" name="showDetectionZoneCheckbox" id="showDetectionZoneCheckbox">
      <label for="showDetectionZoneCheckbox">Afficher zones de détection</label>
    </div>

    <div>Naviguer vers la démo: <a href="#demo01">1</a> - <a href="#demo02">2</a> - <a href="#demo03">3</a></div>

    <div class="resetButtonContainer">
      <!-- <input type="button" value="reset"> -->
      <button type="button" class="btn btn-primary btn-sm" id="resetButton-demo03">Réinitialiser</button>
      <input id="switch-demo03" type="checkbox" data-toggle="toggle" checked data-on="En cours" data-off="En Pause" data-onstyle="success" data-offstyle="warning" data-size="sm" class="switch-demo">
    </div>

    <div id="canvas-demo03-collisions" class="myCanvas">
    </div>
  </div>



  <h2>Sources : aller plus loin</h2>

  <dl>
    <dt></dt>
    <dd>
      <a href="https://dev.solita.fi/2015/08/06/quad-tree.html">Is there an optimal quad tree out there?</a>, Paavo Toivanen
    </dd>
    <dd>
      <a href="https://stackoverflow.com/questions/41946007/efficient-and-well-explained-implementation-of-a-quadtree-for-2d-collision-det/48330314#48330314">Efficient QuadTree on StackOverflow</a>, Dragon Energy
    </dd>

  </dl>


  <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

  <script src="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/js/bootstrap4-toggle.min.js"></script>
  <p>
    Si vous voulez construire rapidement le QuadTree alors vous avez besoin d'un <code>insert</code> rapide. Pour cela, il suffit d'augmenter la capacité de l'arbre : plus une feuille pourra porter de points, moins elle aura de chance de se
    subdiviser. Ainsi, augmenter la capacité diminue le nombre d'appels récursifs d'<code>insert</code> et diminue le nombre d'appels à <code>branch</code>. Cela dit, vous perdez nécessairement en efficacité en recherche, car vous aurez plus de
    points à évaluer.
  </p>
  <script src="js/lib/prism.js"></script>

</body>




<!-- TODO: faire import plus propre -->
<script src="js/quadTree.js"></script>
<script src="js/pedagogic_extension.js"></script>
<script src="js/api_render.js"></script>

<script src="js/demo01/ui_app01.js"></script>
<script src="js/demo01/app01.js"></script>

<script src="js/demo02/app02.js"></script>
<script src="js/demo02/ui_app02.js"></script>

<script src="js/demo03/ui_app03.js"></script>
<script src="js/demo03/app03.js"></script>

<script src="js/main.js"></script>


</html>
