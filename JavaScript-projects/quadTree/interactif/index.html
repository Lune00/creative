<!DOCTYPE html>
<html lang="fr">

<head>
  <script src="js/lib/p5.js"></script>

  <meta charset="utf-8">

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">

  <link href="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/css/bootstrap4-toggle.min.css" rel="stylesheet">

  <!-- code snippet -->
  <link href="css/prism.css" rel="stylesheet" />
  <link rel="stylesheet" type="text/css" href="css/style.css">


</head>

<body>

  <h1>Quadtree</h1>

  <h2>Introduction</h2>

  <h3>Ce que nous allons aborder et ce dont nous ne parlerons pas</h3>

  <p>
    Les <a href="https://fr.wikipedia.org/wiki/Quadtree">Quadtree</a> sont des structures de données qui peuvent être très utiles pour résoudre certains types de problèmes. Précisons d'emblée que cet article ne cherche pas à couvrir de manière
    exhaustive tous les usages et les contextes d'application des Quadtrees. Nous nous nous restreindrons à son usage principal, celui du partitionnement d'un espace à deux dimensions.
    Au lieu de partir de considérations théoriques et générales nous allons plutôt aborder les Quadtrees d'un point de vue pratique en tachant de répondre à ces questions : à quoi un Quadtree peut-il servir ? Qu'est ce qu'un Quadtree ? Comment le
    construire ? Comment l'interroger ? Comment s'en servir ?
    Nous allons donc commencer par proposer une définition d'un Quadtree. Puis, à l'aide de notre définition, nous allons le construire et l'implémenter (en JavaScript ici mais facilement
    reproductible dans n'importe quel langage de programmation). Nous allons ensuite voir comment nous en servir pour manipuler ou interroger efficacement nos données.
    Finalement, nous allons l'utiliser dans un cas pratique où le Quadtree fait largement ses preuves : la détection de collisions.

  </p>



  <h3>Dans quel cas les Quadtrees sont-ils utiles?</h3>

  <p>
    Avant même de définir ce qu'est un Quadtree, il paraît intéressant de voir à quoi il peut servir et à quels types de questions il permet de répondre.
  </p>

  <p>
    Pour nous servir des Quadtrees nous avons besoin d'un espace à deux dimensions (un écran, un sous-espace d'un espace plus grand, une scène où se déplacent des objets, une image etc...)
    et que cet espace contienne des points. Ces points peuvent représenter n'importe quoi, la seule chose qui importe c'est que les <strong>coordonnées de ces points représentent
      quelque-chose</strong>. Par exemple ces points pourraient représenter des particules, les pixels d'une image, les villes d'un pays etc... Les coordonnées ont du sens : deux particules veulent savoir si elles sont en contact ou non, le sens
    d'une image est
    contenu dans les positions relatives de ses pixels, les villes ne sont pas n'importe où !
    Par exemple, un sytème de coordonées peut être défini de sorte à ce qu'un axe représente la distance vers l'avant par rapport à
    l'origine choisie,
    et l'autre celle vers la gauche. La particule pourrait être représentée dans cet espace par un couple de deux valeurs mesurant la position du centre géometrique de la particule. Mais la distance mesurée entre deux points dans un système de
    coordonnées ne se restreint pas
    à
    la mesure d'une distance <i>strictement spatiale</i> : on pourrait tout aussi bien définir un espace avec un axe <i>proportion de voyelles</i> et y représenter des chaînes de caractère. Cet espace permettrait de définir une mesure de proximité
    entre des mots ou
    des phrases par exemple. On pourrait également représenter des points dans un espace où une dimension mesure la position et l'autre le temps etc.
  </p>

  <p>
    Mais prenons l'exemple classique d'un espace à deux dimensions peuplé d'objets, représenté chacun par un point. Pour des raisons pratiques nous appelerons <strong>point</strong> la représentation de l'objet dans notre espace par ses coordonnées.

  <div class="row justify-content-center">
    <figure class="figure">
      <img src="media/figure01.png" class="figure-img img-fluid rounded" alt="un espace bidimensionnel peuplé d'objets représentés par des points" title="un espace bidimensionnel peuplé d'objets représentés par des points" width="452" height="328" />
      <figcaption class="figure-caption text-center">Figure 1 : un espace bidimensionnel peuplé d'objets</figcaption>
    </figure>
  </div>

  Supposons que nous voulions interroger les propriétés de voisinage de ces objets. Par exemple, nous aimerions savoir combien de voisins possède chaque objet dans une zone définie autour de celui-ci? Ces voisins possèdent-ils des propriétés
  analogues ou différentes? Quel
  est le voisin le plus proche de chaque point ? Ou non finalement, qui sont les trois voisins les plus proches ? Ou, tout simplement, combien y'a-t-il d'objets présents dans une zone définie autour d'un point quelconque? La liste n'est pas
  exhaustive, mais toutes ces questions ont ceci en commun :
  elles trouvent leurs réponses dans les mesures des distances entre les points. Elles ont un caractère <i>géometrique</i>.
  </p>

  <div class="row justify-content-center" id="figure02">
    <figure class="figure">
      <img src="media/figure02.png" class="figure-img img-fluid rounded" alt="un espace bidimensionnel peuplé d'objets représentés par des points. Un cercle rouge défini un sous-espace"
        title="Combien de points se trouvent dans le sous-espace défini par le cercle rouge?" width="452" height="328" />
      <figcaption class="figure-caption text-center">Figure 2 : combien de points se trouvent dans <br />le sous-espace défini par le cercle rouge? </figcaption>
    </figure>
  </div>
  <p>
    Reprenons l'une des questions précédentes sur le voisinage : quels sont les objets présents dans une zone bien délimitée de mon espace? Comme nous pouvons le voir sur la <a href="#figure02">figure 2</a>, nous retrouvons notre ensemble d'objets
    dans
    un espace
    bidimensionnel, où chaque objet est repéré par ses coordonnées et représenté par un point blanc. Nous voulons savoir quels sont les objets présents à l'interieur du cercle rouge. Nous voulons, par exemple, sélectionner ces points et leur
    appliquer un traitement particulier. Comment allons-nous nous y prendre? La solution <i>naïve</i> consisterait à parcourir tous les points et à tester s'ils se trouvent à l'intérieur du domaine délimité par le cercle rouge. Cette
    solution demanderait un temps d'execution propotionnel au nombre de points à traiter, on dit qu'elle est <code>O(n)</code>, où <code>n</code> représente le nombre de
    points à parcourir. La <a href="https://fr.wikipedia.org/wiki/Analyse_de_la_complexit%C3%A9_des_algorithmes">complexité</a> d'un algorithme, ou d'une fonction, est une mesure de la quantité de ressources (temps ou mémoire) nécessaire à son
    éxecution : <code>O(n)</code> signifie que les ressources demandées sont proportionnelles à n. Si nous avons un million de points et que notre cercle rouge ne contient que deux points alors nous devrons faire un million d'opérations pour n'en
    sélectionner que deux !
  </p>
  <p>
    Et ce n'est pas tout. Là encore c'est une complexité tolérable. Supposons que nous cherchions à savoir quel est le point le plus proche de chaque point. Pour y arriver nous devrions, pour chaque point, regarder les n - 1 points restants, mesurer
    la distance entre les deux et garder le point pour lequel la distance est la plus courte. Et nous devrions répeter cette opération n fois, pour chaque point. Cela veut dire qu'il faudrait n * (n -1) opérations pour obtenir notre résultat. Il
    serait possible de réduire le coût en ne considérant les paires qu'une fois. Comme chaque paire compte double dans le décompte précédent il est encore possible de diviser par 2 le nombre d'opérations, pour le ramener à n *( n - 1 ) / 2.
    Néanmoins, on
    voit toujours apparaitre un facteur n<sup>2</sup>. La complexité de notre calcul est donc ici en <code>0(n<sup>2</sup>)</code>. Si nous avions un million de points il faudrait faire un billion (1 000 000 000 000) d'opérations pour obtenir notre
    résultat ! Ce n'est
    pas sérieux. La complexité
    <code>0(n<sup>2</sup>)</code> est une complexité qu'il faut éviter à chaque fois que cela est possible, sa mise à l'échelle avec la taille de l'échantillon est trop vertigineuse, et elle indique souvent qu'il y'a <i>un autre chemin</i>.
  </p>

  <p>
    Pou réduire cette complexité l'une des premières choses à faire est de repenser notre structure de données, celle dans laquelle sont rangés nos points. De nombreuses structures de données existent
    et permettent d'organiser les données de manière à faciliter leur traitement. Chaque structure de données possède des avantages et des inconvénients vis à vis du traitement que l'on
    souhaite réaliser. Réduire la complexité et augmenter les performances d'un programme en charge de la réalisation d'un traitement de données passe d'abord par le choix d'une structure de données adaptée.
  </p>

  <p>
    Pour le moment, nos objets sont stockés sous la forme d'un tableau, ou d'une liste, comme il est courant de le faire. Nous devons parcourir le tableau de points et tester pour chacun d'entre eux s'il est à l'interieur de la zone circulaire rouge.
    Mais c'est embêtant, car nous devons tester tous les points, même ceux à l'autre bout de l'espace, loin, si loin de notre zone. Il doit y avoir une meilleure solution. Pouvons-nous mieux faire? Oui, nous pouvons mieux faire ! Et pour mieux faire
    nous avons besoin d'une
    structure de données adaptée à ce genre de problème : le Quadtree.
  </p>


  <p>
    Le Quadtree est une structure de données où l'on va ranger les points dans des petites boîtes. Ces boîtes seront définies en appliquant une décomposition de l'espace en quatre sous-espaces égaux de manière <a
      href="https://fr.wikipedia.org/wiki/R%C3%A9cursivit%C3%A9">récursive</a>. L'espace sera ainsi divisé <i>sur lui même</i> jusqu'à ce qu'aucune boite ne contienne plus de quatre points. C'est son aspect récursif qui
    lui donne la forme d'un arbre (<i>tree</i>). Le <i>quad</i> vient lui du fait qu'on découpe l'espace toujours en quatre. Même si cette définition parait pour le moment très insatisfaisante, nous allons voir que le but du Quadtree est d'organiser
    autrement les points (sans toucher à leur coordonnées bien entendu) pour optimiser drastiquement le coût de nos investigations. Pour reprendre la
    question que nous nous posons, à savoir combien de points sont compris dans le cercle rouge, le problème de la solution naïve vient du fait qu'elle nous force à interroger tout l'espace (et donc tous les points !). Le Quadtree va nous permettre
    d'affiner
    notre requête et d'interroger une partie de l'espace. Mais inutile de bavarder plus longtemps, et rentrons dans le vif du sujet.
  </p>


  <dl>
    <dt>
      Ce qu'il faut retenir
    </dt>
    <dd>
      <p class="togo">
        Les Quadtrees sont des structures de données qui permettent de traiter efficacement des données existantes dans un espace bidimensionnel. L'utilisation d'un Quadtree pour réaliser ces
        traitements offre un gain de performance considérable par rapport à l'approche <i>naïve</i>. Ce bénéfice provient du fait que le Quadtree partitionne l'espace de manière récursive pour ré-organiser les données.
      </p>
    </dd>
  </dl>


  <h2>Définitions</h2>

  <p>
    Mettons nous d'accord sur le vocabulaire et quelques définitions afin de ne laisser place à aucune ambiguité. En effet, il n'y a pas de définition standard du Quadtree, plusieurs implémentations existent et ont chacune leur intérêt et leur
    défaut. Il existe plusieurs stratégies pour le construire et la structure possède plusieurs paramètres (capacité, profondeur...) ajustables par l'utilisateur en fonction de ses besoins. Néanmoins, tous les Quadtrees partagent une définition
    commune : ce sont des structures de type arbre (récursives) dans laquelle chaque noeud a jusqu'à quatre enfants. La suite de cet article s'appuiera sur l'ensemble des défintions suivantes.
  </p>

  <p>

  </p>

  <dl>
    <dt>
      Noeud
    </dt>
    <dd>
      le noeud est le composant fondamental du Quadtree. Le Quadtree est une association de noeuds, et il commence toujours par un noeud initial, un noeud racine. Les points insérés dans un Quadtree finissent toujours attachés à un et un seul noeud.
      Un noeud peut avoir jusqu'à 4 enfants. Le Quadtree possède deux types de noeuds : les branches et les feuilles.
    </dd>
    <dt>
      Branche
    </dt>
    <dd>
      un noeud qui ne peut porter (avoir pour enfant direct) que des noeuds, branche ou feuille, mais jamais de points.
    </dd>
    <dt>
      Feuille
    </dt>
    <dd>
      un noeud qui ne peut porter que des points, mais jamais d'autres noeuds. Lorsque la capacité de la feuille est dépassée elle se transforme en branche.
    </dd>
    <dt>
      Enfant
    </dt>
    <dd>
      un enfant est un élément du Quadtree qui est porté par son noeud parent. Un enfant peut-être un noeud ou un point. Seul un noeud peut être parent. Par exemple, sur la <a href="#figure3"> figure 3</a>, la feuille <i>b</i> est l'enfant de la
      branche <i>a</i>. On dit que <i>a</i> porte <i>b</i>. De même, le point <i>c</i> est l'enfant de la feuille <i>b</i>, mais <i>c</i> n'est pas l'enfant de <i>a</i>, car <i>a</i> ne porte pas directement <i>b</i>.
    </dd>
    <dt>
      Capacité
    </dt>
    <dd>
      le nombre maximal d'enfants qu'une feuille peut porter. Par défaut la capacité est de quatre. Ainsi on conserve une certaine homogénéité dans notre définition : une branche a la même capacité qu'une feuille. Si la capacité d'une branche est par
      définition de 4 (<i>quad</i>tree) la capacité d'une feuille pourrait être supérieure ou inférieure (chaque feuille ne pourrait porter qu'un point par exemple).
    </dd>
    <dt>
      Profondeur
    </dt>
    <dd>
      le niveau auquel se trouve un noeud. La racine a une profondeur de référence arbitraire p définie par l'utilisateur. Les enfants auront une profondeur p + 1. Ici on a défini la profondeur de la racine à 0.
    </dd>
  </dl>


  <div class="row justify-content-center" id="figure03">
    <figure class="figure">
      <img src="media/quadtree.svg" class="figure-img img-fluid rounded" alt="" title="" width="700" />
      <figcaption class="figure-caption text-center">Figure 3 : Exemple d'un Quadtree. Les feuilles portent les points. Notez qu'une branche ne peut porter<br /> que des branches ou des feuilles mais jamais directement des points.
        Chaque noeud peut porter jusqu'à quatre enfants maximum. </figcaption>
    </figure>
  </div>

  <p>
    La <a href="#figure3"> figure 3</a> montre un exemple de Quatree où les points sont répartis sur des feuilles. Ces points sont ceux qui existent dans notre espace bidimensionnel et que nous avons organisés suivant cette étrange structure, au lieu
    de les garder sous forme de liste.

  </p>
  <p>
    Voyons maintenant comment construire un Quatree comme celui-ci et son rapport à notre esapce bidimensionnel. Nous verrons également pourquoi nous distinguons les noeuds en branches
    et en feuilles.
  </p>

  <p>

  </p>


  <h2>Construction</h2>


  <p>Dans le principe, la construction d'un Quadtree est très simple. Prenez une feuille de papier, elle définira notre espace. Placez-y des points où bon vous semble. A présent, donnez vous une capacité, par exemple 2. Divisez la feuille en 4
    rectangles égaux. Comptez le nombre de points dans chaque rectangle. Si un rectangle en contient plus que 2, divisez le en 4 rectangles égaux. Recommencez l'opération jusqu'à ce que chaque rectangle contienne au maximum 2 points. Et voilà ! Sur
    le papier, rien de bien compliqué. Evidemment, pour ce qui est de le programmer les choses se corsent un peu. </p>

  <p>
    Nous allons voir, pas à pas, comment construire une structure de données Quadtree à partir de nos points. Nous allons d'abord insister sur les principes de construction, plutôt que sur les détails de l'implémentation.
    L'objectif premier est d'obtenir un pseudo-code, les détails de l'algorithme sont discutés dans la partie <a href="implementation">implémentation</a>. L'implémentation proposée dans cet article est une suggestion, et n'est évidemment pas la seule
    possible, libre à vous de l'adapter à vos besoins ou de l'améliorer.
  </p>


  <h3>Le point de départ de l'arbre : la racine</h3>
  <p>
    Nous allons commencer par définir la racine de notre Quadtree, le premier noeud. La racine n'a pas de noeud parent par définition et c'est une feuille. A présent il faut faire la connexion entre notre arbre et
    l'espace géometrique : <strong>chaque noeud aura la responsabilité d'une région de l'espace. La racine a
      sous sa responsabilité l'intégralité de l'espace</strong>. Elle sera
    responsable de tout ce
    qu'il se trouve à l'intérieur. C'est ce que l'on peut voir sur la <a href="#figure04">figure 4a</a>, où la racine a la charge de tout le rectangle noir.
  </p>

  <h3>Insérer des points dans le Quadtree</h3>

  <p>
    Nous allons insérer nos points un à un dans l'arbre. Pour chaque point allons interroger la racine de l'arbre :
  <ul style="list-style-type: '&mdash; '">
    <li>
      Est-ce que ce point se trouve dans ta région ?
    </li>
    <li>
      Bien sûr, par définition, tous les points se trouvent dans ma région !
    </li>
  </ul>
  En effet, la racine recouvre tout l'espace disponible. Le point est donc
  attaché à la racine. Nous allons continuer ainsi jusqu'à ce que le noeud racine porte quatre points, comme nous pouvons le voir sur les images <i>b)</i> à <i>e)</i> de la <a href="#figure04">figure 4</a>.
  </p>

  <div class="row justify-content-center" id="figure04">
    <figure class="figure">
      <img src="media/construction.svg" class="figure-img img-fluid rounded" alt="" title="" width="1000" />
      <figcaption class="figure-caption text-center">Figure 4 : Etapes de construction d'un Quadtree par insertions successives de points. A l'étape f) la feuille originale porte 5 enfants.<br /> Ayant dépassé sa capacité de 4, elle se transforme en
        branche et pousse les points sur leurs feuilles respectives. <br />Le prochain point sera porté par l'une des feuilles de profondeur 1 et le processus se répètera.</figcaption>
    </figure>
  </div>

  <h3>Mécanisme de division</h3>

  <p>
    Le noeud racine porte à présent 4 enfants et nous insérons un nouveau point de notre collection. La feuille se retrouve à présent en surcapacité, elle a un point de trop : elle se transforme en branche. D'après notre définition, une branche ne
    peut avoir pour enfant que d'autres noeuds. Elle divise donc la région dont elle a la responsabilité en trois sous-régions égales (la dernière sous-région ne contenant aucun point n'est pas définie). Ces sous-régions sont chacune mises sous la
    responsabilité de nouveaux enfants, des feuilles. Chaque feuille prend
    la charge des points qui se trouvent dans sa région. Chaque point, originellement porté par la branche, se trouve alors poussé sur sa feuille et la structure est de nouveau à l'équilibre. Sur la <a href="figure04">figure 4f</a> on peut voir que 3
    feuilles ont poussé sur l'arbre. Elles contiennent les 5 points insérés. Chacune d'entre elle porte les points qui se trouvent dans la région dont elle est responsable. Enfin, la racine est à présent une branche et elle n'a pour enfant que des
    feuilles.
  </p>

  <p>
    Afin de couvrir l'intégralité du processus de division, il nous reste à discuter de deux cas possibles à la prochaine insertion. Supposons que nous voudrions insérer un point dans le quadrant sud-ouest(2) de notre arbre. Demandons à la racine :
  <ul style="list-style-type: '&mdash; '">
    <li>
      Est-ce que ce point se trouve dans ta région ?
    </li>
    <li>
      Bien sûr, par définition, tous les points se trouvent dans ma région ! Cela dit, celui-ci se trouve aussi dans la région de l'un de mes enfants, c'est donc à lui que revient la responsabilité de s'en occuper. Moi je suis une branche, je ne
      m'occupe plus des points, ce n'est plus mon problème. Demandez donc à ma feuille 2.
    </li>
  </ul>
  Nous allons demander à la feuille 2:
  <ul style="list-style-type: '&mdash; '">
    <li>
      Est-ce que ce point se trouve dans ta région ?
    </li>
    <li>
      Oui, cette région m'appartient désormais, donnez moi votre point, je m'en charge.
    </li>
  </ul>

  Et nous pouvons ajouter un point à la feuille 2, comme montré sur la <a href="#figure05">figure 5g</a>.
  </p>
  <div class="row justify-content-center" id="figure05">
    <figure class="figure">
      <img src="media/construction_suite.svg" class="figure-img img-fluid rounded" alt="" title="" width="800" />
      <figcaption class="figure-caption text-center">Figure 5 : Deux points (en rouge) sont insérés sur l'arbre : la branche délègue la responsabilité à son enfant s'il existe déjà g), <br />ou met à disposition une nouvelle feuille s'il n'existe pas
        encore h)</figcaption>
    </figure>
  </div>
  <p>
    A présent, regardons un deuxième cas de figure, supposons que nous voudrions insérer un point dans la quadrant sud-est(3) de notre arbre. Comme d'habitude, demandons à la racine:
  <ul style="list-style-type: '&mdash; '">
    <li>
      Est-ce que ce point se trouve dans ta région ?
    </li>
    <li>
      Bien sûr, par définition, tous les points se trouvent dans ma région ! Cela dit, celui-ci se trouve dans une sous-région qui n'est sous la responsabilité d'aucun de mes enfants. Cette région est encore sous ma responsabilité mais comme je l'ai
      dit, je ne m'occupe plus personnellement des points, je suis une branche ! Voici, je vais faire pousser une feuille et celle-ci s'en chargera.
    </li>
  </ul>
  Sur la <a href="#figure05">figure 5h</a> une feuille 3 a poussé. Nous pouvons aller lui demander, comme précédemment, si elle veut de notre point, et comme celui-ci se trouve dans la région dont elle a la responsabilité elle le portera.
  </p>

  <p>
    En guise d'exercice, vous pouvez essayer de continuer de construire cet arbre avec des points choisis arbitrairement, en appliquant ces règles. Vous verrez les feuilles se transformer en branches, les branches créer des feuilles, et vos points se
    répartir d'une feuille à l'autre au gré de la construction.
  </p>

  <p>
    <a href="#demo01">Une démo interactive</a> de création et d'inspection du Quadtree est disponbile dans l'article. Vous pouvez y expérimentez la construction d'un Quadtree point par point, par un simple clic sur le canvas. Le nombre de branches et
    de feuilles de l'arbre sont affichés pour vous permettre de savoir si vous avez bien compris les mécanismes de division.
  </p>


  <h3>Pseudo-code</h3>

  <p>
    Maintenant que nous avons bien défini le comportement de notre arbre et de ses composants, nous pouvons écrire un pseudo-code de l'algorithme de construction de notre arbre. La construction n'est rien d'autre qu'une succession d'insertion
    de point au niveau de
    la racine. Voici à quoi le pseudo-code de la fonction d'insertion pourrait ressembler:
  </p>

  <div>
    <pre class="language-javascript">
    <code><span class="variable">racine</span>.<span class="function">inserer</span>(point){
      <span class="if-else">if</span> <span class="statement">le point n'est pas dans mon domaine</span>
        quitter;

      <span class="if-else">if</span> <span class="statement">le point est dans le domaine d'un de mes enfants</span>
        <span class="variable">enfant</span>.<span class="function">inserer</span>(point);
      <span class="if-else">else</span>

        <span class="if-else">if</span> <span class="statement">je suis une branche</span>
          creer un nouvel enfant feuille
          <span class="variable">enfant</span>.<span class="function">inserer</span>(point)
        <span class="if-else">else</span>
          <span class="function">porter</span>(point)

        <span class="if-else">if</span> <span class="statement">j'ai plus de 4 enfants</span>
          se transformer en <span class="variable">branche</span>
          creer autant d'enfants feuille que nécessaire : <span class="variable">mes_feuilles</span>
          recuperer tous mes points : <span class="variable">mes_points</span>
          <span class="variable">mes_feuilles</span>.<span class="function">inserer</span>(<span class="variable">mes_points</span>)
      }</code></pre>

  </div>



  <h2 id="implementation">Implémentation</h2>

  <p>
    Cette partie portera sur l'implémentation (en JavaScript) d'un Quadtree. Nous allons implémenter le composant <i>noeud</i> et la fonctionalité d'insertion. Tous les détails de l'implémentation ne sont pas mentionnés, notamment le code concernant
    les fonctions auxiliaires. Il est cependant accessible dans le <a href="#">code-source</a>.
  </p>


  <h3>Implémentation du noeud : <code>class Node</code> </h3>

  <p>
    Un noeud est la structure fondamentale de l'arbre. Elle possède une région, un espace géometrique, dont elle a la responsabilité. Cette région est rectangulaire et est entièrement définie par les variables <code>x,y,w,h</code> où
    <code>(x,y)</code> représentent <strong>le centre</strong> du rectangle et <code>(w,h)</code> sa <strong>demi-largeur et
      demi-longueur</strong>.

  </p>
  <p>
    Un noeud a en pratique toujours 4 enfants, donc <code>children</code> est un tableau de 4 éléments, un pour chaque enfant. Les enfants sont initialisés sous la forme d'un tableau vide. Chaque indice du tableau
    <code>children</code> correspond à une sous-région de l'espace détenu par le noeud, comme représenté sur <a href="figure04">la figure 4</a>. On peut voir que l'espace est virtuellement pré-découpé en 4 sous-regions
    par des traits pointillés blancs. L'indice, allant de 0 à 3 sert d'identité à chaque sous-région. Ainsi <code>children[0]</code> retourne soit l'ensemble des points contenus dans la sous-région <code>0</code> du noeud si le noeud est une feuille,
    soit une feuille si le noeud est une branche.
  </p>

  <p>
    Un attribut <code>capacity</code> définit la capacité de chaque feuille, égale par convention au nombre d'enfants max, soit 4. Un noeud nouvellement crée est par défaut une feuille, et sa profondeur est initialisée à
    partir de celle de son parent, où à 0 dans le cas de la racine.
  </p>


  <div>
    <pre class="language-javascript line-numbers">
    <code >class Node {

        constructor(x, y, w, h, depth = 0) {

          //Region sous responsabilité : (x,y) position du centre, (w,h) demi largeur/hauteur
          this.x = x;
          this.y = y;
          this.w = w;
          this.h = h;
          //                 0   1   2   3
          this.children = [ [], [], [], [] ];

          this.isBranch = false;

          //Capacité
          this.capacity = this.children.length;

          //taille
          this.length = 1;

          //profondeur
          this.depth = depth;
        }
        //Methodes a implementer
        insert( point ){}
        query( area ){}
      }</code></pre>

  </div>

  Pour initialiser la racine il suffira de l'instancier dans notre programme avec <code>let racine = new Node(x, y, w, h)</code>, où <code>(x, y, w, h)</code> sont les données géometriques de l'espace où se trouvent vos points, typiquement les
  propriétés de votre écran.

  <h2 id="implementation">Implémentation de l'insertion : <code>insert(point)</code></h2>

  <p>
    Maintenant que nous avons initialisé notre arbre il faut pouvoir y insérer nos points. C'est le but de la méthode <code>insert(point)</code>. Tout d'abord nous vérifions si le point est contenu dans la région contrôlée
    par le noeud. Si ce n'est pas le cas alors on ne l'insert pas, tout simplement. Un point généré en dehors de votre écran n'intéresse pas le Quadtree.
  </p>
  <p>
    Si le noeud contient le point, la méthode <code>index(point)</code> se charge de récupérer l'index de la sous-région dans laquelle il se trouve. Cet index, allant de 0 à 3 est celui représenté sur <a href="figure04">la
      figure 4</a>. Il permet d'accèder à l'enfant en charge du sous-espace. Nous pouvons ensuite interroger l'enfant <code>children[index]</code>.
  </p>
  <p>
    L'instruction <code>children[index] instanceof
      Node</code>, à la ligne 8, est une syntaxe de la norme <a href="https://www.w3schools.com/js/js_es6.asp">ECMAScript 6</a>. Sous le capot aucun cast, JavaScript se contente de tester si <code>children</code> possède, dans sa <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">chaîne de prototype</a>, une référence vers le prototype du constructeur <code>Node</code>.
  </p>
  <p>
    Deux cas se présentent :
  </p>

  <p>
  <ul>
    <li>
      si l'enfant est un noeud, le noeud parent lui délegue le travail et la méthode <code>insert(point)</code> est appelée récursivement sur l'enfant. Le travail est terminé pour le noeud parent.
    </li>
    <li>
      si l'enfant n'est pas un noeud, mais encore un tableau, alors deux cas se présentent :
      <ul>
        <li>
          soit le noeud en cours est une branche qui n'a pas encore fait poussé de feuille dans cette sous-région. Dans ce cas on fait pointer l'enfant sur une nouvelle feuille : <code>children[index] =
            getNewNode(index)</code>. Puis on lui demande de s'occuper du point. La méthode <code>getNewNode(index)</code> prend en paramètre l'index de la sous-région sur laquelle il doit pointer et renvoie une feuille
          toute fraiche ayant la charge de cette sous-région. Mais, et si <code>children[index]</code> contenait des points, alors nous pourrions les perdre dans cette opération, non? Non, car le noeud est une branche ! Et
          par définition, une branche ne porte jamais de points.
        </li>
        <li>
          soit c'est une feuille et dans ce cas il garde tout simplement le point.
        </li>
      </ul>
    </li>
  </ul>
  </p>


  <p> Il reste une dernière étape avant de terminer cette fonction. Il faut implémenter la transformation en branche d'une feuille lorsque celle-ci est en surcapacité. C'est le rôle de la dernière évaluation.</p>



  <div>
    <pre class="language-javascript line-numbers">
    <code>insert(point) {

        if (!this.contains(point))
          return;

        let index = this.index(point);

        if (this.children[index] instanceof Node) {
          this.children[index].insert(point);
          return;
        } else {

          //Si c'est une branche alors il faut créer une nouvelle feuille et y insérer le point
          if (this.isBranch) {
            this.children[index] = this.getNewNode(index);
            this.children[index].insert(point);
            return;
          }

          //C'est une feuille, elle porte le point
          this.children[index].push(point);

          //Si la feuille a dépassé sa capacité elle se transforme en branche
          if (this.hasReachedMaxCapacity())
            this.branch();
        }
      }</code></pre>
  </div>

  <p>
    Le code de la méthode <code>branch()</code> est montré ci-dessous. Rappelons nous : lorsqu'une feuille porte plus de 4 points, elle est en sur-capacité et se change en branche. Elle doit alors instancier de nouvelles
    feuilles
    et pousser ses points dessus. A la fin, la branche ne doit avoir que des feuilles pour enfant.
  </p>

  <p>
    Nous parcourons alors tous les enfants de la feuille. Ces enfants, par définition, <strong>sont garantis d'être des tableaux de points</strong>. C'est pour cela que dans la boucle <code>children.forEach((points,index))</code> la référence vers
    chaque enfant est nommée <code>points</code>, et non <code>child</code>. Nous ne voulons pas instancier plus de feuilles que nécessaire, c'est
    pourquoi nous instancions une feuille que lorsqu'un enfant contient des points. Une fois l'enfant transformé en feuille, nous insérons les <code>points</code> dedans.
  </p>

  <div>
    <pre class="language-javascript line-numbers">
    <code>branch() {
        //Seule une feuille peut devenir une branche, ses enfants sont nécessairement des tableaux de points
        this.children.forEach((points, index) => {
          //Si un enfant contient des points, créer une feuille a la place...
          if (points.length !== 0) {
            this.children[index] = this.getNewNode(index);
            //...et y insérer les points
            for (let p of points)
              this.children[index].insert(p);
          }
        });
    }</code></pre>
  </div>


  <h2>Démo interactive</h2>

  <p>
    Ci-dessous vous trouverez une démo interactive de cette implémentation. Vous pouvez insérer des points par un simple click sur le canvas. Vous pouvez insérer point par point pour bien suivre l'évolution du nombre de branches et de feuilles, soit
    par nuages de points. Une zone d'inspection, qui suit le mouvement du curseur, est également à disposition pour inspecter le Quadtree. Vous pouvez régler sa taille. Elle détecte les points contenus à l'intérieur du cercle. Le nombre de
    points candidats montre combien de points il a fallu interroger pour obtenir ce résulat. Vous pouvez observer qu'il est possible de selectionner les points à l'intérieur du cercle sont évaluer tous les points présents (sauf s'ils y sont tous bien
    sûr). Les lignes blanches marquent les frontières des neuds. Un noeud en surbrillance indique une feuille intérogée par la zone d'inspection. Nous verrons dans la prochaine partie comment inspecter et nous servir du Quadtree. N'hésitez pas alors
    à revenir expérimenter avec cette démo.
  </p>

  <div class="row demo1-container" id="demo01">
    <div class="insertion-informations">
      <div class="container-insertion">
        <h4>Insertion</h4>

        <div>
          <input type="radio" id="normal" name="insertionModeGroup" value="point" checked="checked">
          <label for="point"><acronym title="Insère un unique point à chaque clic">Point par point</acronym></label>
        </div>
        <div>

          <input type="radio" id="gaussian" name="insertionModeGroup" value="gaussian">
          <label for="gaussian"><acronym title="Insère un nuage gaussien de points à chaque clic">Nuage de points</acronym></label>
          <label for="nbPointsGaussian">Nombre de points à insérer</label>
          <input type="range" id="nbPointsGaussian" name="nbPointsGaussian" value="100" min="10" max="250" disabled="">
          <output id="nbPointsGaussianValue"></output>
        </div>

        <div class="slideContainer">
          <label for="sliderProbeSize">Taille de la zone d'inspection</label>
          <input type="range" min="10" max="200" value="100" id="sliderProbeSize" name="sliderProbeSize">

        </div>

        <div>
            <label for="nbPointsTotal">Nombre de points insérés :</label>
            <span id="nbPointsTotal" name="nbPointsTotal">0</span>
        </div>

      </div>
      <div class="container-informations">
        <div class="title">
          <h4>Informations</h4>
        </div>

        <div class="left">
          <table class="table table-striped table-hover table-sm table-dark">
            <tbody>
              <tr>
                <th scope="row" class="candidats"><label for="nbPoitnsEvaluated" <abbr title="Nombre total de points évalués lors de la requête (présence ou non dans la zone d'inspection)"><b>Points candidats (% Total)</b> : </label></th>
                <td class="candidats">  <span id="nbPoitnsEvaluated" name="nbPoitnsEvaluated"></span></td>
              </tr>
              <tr>
                <th scope="row" class="inclus"><label for="nbPoitnsSelected" <abbr title="Nombre total de points évalués et retournés par la reqûete (présents ou non dans la zone d'inspection)"><b>Points inclus dans la zone d'inspection (% Total) : </b></label></th>
                <td class="inclus"> <span id="nbPoitnsSelected" name="nbPoitnsSelected"></span></td>
              </tr>
              <tr>
                <th scope="row"><label for="nbLeaf">Nombre de feuilles</label></th>
                <td><span id="nbLeaf" name="nbLeaf"></span></td>

              </tr>
              <tr>
                <th <label for="nbBranch">Nombre de branches</label></th>
                <td><span id="nbBranch" name="nbBranch"></span></td>
              </tr>
            </tbody>
          </table>
          <table class="table table-striped table-hover table-sm ">
            <tbody>

            </tbody>
          </table>


        </div>

        <div class="right">

        </div>

      </div>
    </div>

    <div class="container-buttons">
      <!-- <input type="button" value="reset"> -->
      <button type="button" class="btn btn-primary btn-sm resetButton" id="resetButton">Réinitialiser</button>
      <input id="switch-demo01" type="checkbox" data-toggle="toggle" checked data-on="En cours" data-off="En Pause" data-onstyle="success" data-offstyle="warning" data-size="sm" class="switch-demo">

    </div>

    <div class="navigation">Naviguer vers la démo: <a href="#demo01">1</a> - <a href="#demo02">2</a> - <a href="#demo03">3</a></div>

    <div class="container-canvas">
      <div id="canvas-demo01-insert-querry" class="myCanvas"></div>
    </div>

  </div>

  <br />

  <p>
    Nous avons à présent construitable-hovert notre Quadtree. Notre structure de données est enfin prête. La partie intéressante peut commencer, nous allons à présent nous servir de notre Quadtree pour obtenir des réponses aux questions que nous nous posions !
  </p>

  <h2>Se servir (enfin) du Quadtree</h2>

  <h3>Rappel</h3>
  <p>
    La question que nous nous posions à la base était la suivante : quels sont les points, sur la <a href="#figure02">figure 2</a>, présents à l'interieur du cercle rouge ? Et nous voulions y répondre sans devoir interroger l'intégralité des points
    et
    écopper de la complexité <code>0(n)</code>. Pour cela nous avons ré-organisé nos données dans une structure Quadtree. Comment récupérer les points que nous cherchons ?
  </p>

  <h3>Pseudo-code d'une requête</h3>
  <p>
    Nous devons définir notre zone d'inspection, notre cercle rouge, comme dans <a href="#demo01">la démo</a>. Dans ce cas ci la zone d'inspection est vraiment très simple: elle est définie par les coordonnées de son centre et par un rayon. Nous
    allons initialiser notre requête au Quadtree en demandant à la racine si notre cercle recouvre, même partiellement, l'espace mis sous sa reponsabilité. Si c'est le cas, et si la racine a des noeuds enfants, alors le cercle doit nécessairement
    recouvrir au moins une des sous-régions à la charge de l'un de ses enfants. Récursivement nous allons donc interroger les enfants recouverts jusqu'à arriver sur les feuilles. Les feuilles sont les noeuds les plus profonds de l'arbre, il n'y a
    rien en dessous, mis à
    part nos points. Les enfants des feuilles sont les points que nous cherchons. Nous n'avons plus qu'à remonter tous les points contenus dans les feuilles recouvertes par notre cercle. Le pseudo-code est de la forme :
  </p>



  <div>
    <pre class="language-javascript">
    <code><span class="variable">racine</span>.<span class="function">query</span>(cercle_rouge){

      <span class="if-else">if !</span><span class="statement">cercle_rouge</span>.<span class="function">recouvre</span>(<span class="variable">racine.region</span>)
        quitter;

      Pour chaque <span class="variable">enfant</span>
        <span class="if-else">if</span> <span class="variable">enfant</span> est un noeud
          <span class="variable">enfant</span>.<span class="function">query</span>(cercle_rouge)
        <span class="if-else">else</span>
          Pour chaque <span class="variable">point</span> de <span class="variable">enfant</span>
            <span class="if-else">if</span> <span class="statement">cercle_rouge</span>.<span class="function">contient</span>(<span class="variable">point</span>)
              garder <span class="variable">point</span>
   }</code></pre>
  </div>

  <p>
    Nous profitons ici de l'architecture en arbre. Le fait d'avoir partionné l'espace de manière récursive nous permet de changer la manière dont nous posons notre question : nous ne demandons plus "parmi tous les points quels sont ceux qui se
    trouvent dans le cercle rouge ?". La complexité <code>0(n)</code> est loin maintenant. L'espace étant divisé et mis sous la reponsabilité d'une multitude de noeuds, nous n'avons plus qu'à descendre l'arbre étage par étage. Tant qu'un noeud nous
    répond "oui, vous me recouvrez" nous continuons à poser encore et toujours la même question. Jusqu'à arriver au dernier noeud, à la feuille qui nous dit "oui, vous me recouvrez, tenez, voici les points que j'ai sous ma responsabilité". Et là,
    seulement à ce moment là, on peut tester si le point est contenu dans le cercle rouge.


  <div class="row justify-content-center" id="figure06">
    <figure class="figure">
      <img src="media/requete.svg" class="figure-img img-fluid rounded" alt="" title="" width="800" />
      <figcaption class="figure-caption text-center">Figure 6 :</figcaption>
    </figure>
  </div>


  <p>
    En somme, grâce au travail préalable de division de l'espace et de construction de l'arbre nous avons déplacé ce sur quoi porte notre question : nous ne demandons plus aux points "êtes vous dans le cercle?", nous demandons aux noeuds "êtes vous
    dans le cercle?" Et si un noeud nous répond non, nous n'irons pas poser la question à ses noeuds enfants. Nous pouvons alors tout simplement abandonner les recherches dans la région sous sa reponsabilité, il n'y aucune chance qu'un de ses points
    se trouve dans notre cercle. Un pan entier de l'espace est soustrait à nos efforts de recherche.
  </p>

  <h3>Complexité d'une reqûete</h3>
  <p>
    Analyser la complexité d'une requête dans un Quadtree n'est pas évidente car elle dépend de la requête elle même et de la structure de l'arbre. Cependant nous pouvons estimer les complexité aux cas limites : si tous les points sont présents dans
    notre cercle rouge alors nous retombons sur la pire complexité, en <code>0(n)</code>. Si cette situation se présente majoritairement cela ne signifie pas que le Quadtree est à blâmer, mais plutôt qu'il y'a un problème en terme de design au niveau
    de votre programme. Si 99% des points sont systématiquement candidats à votre requête alors l'utilisation d'un Quadtree n'est pas nécessairement pertinent. A l'inverse, si la requête est très ciblée, et qu'une seule feuille est recouverte par le
    cercle, elle va traverser l'arbre directement de la racine à la feuille et la complexité sera de <code>0(p)</code>, où p est la profondeur de la feuille. On peut donc au moins garantir que la complexité de notre requête est comprise entre
    <code>0(p)</code> et <code>0(n)</code>. C'est déjà une grande nouvelle, car la complexité <code>0(n)</code> qui était garantie à 100% par notre solution naïve est désormais devenue celle du cas le plus extrême.
  </p>


  Voyons à présent les détails de l'implémentation de la requête.
  </p>
  <h2 id="implementation">Implémentation de l'interrogation du Quadtree : <code>query()</code></h2>

  <pre id="query" class="language-javascript line-numbers">
    <code class="language-javascript">query(circleProbe, points = []) {

        let boundingBox = {
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h
        };

        if ( !circleProbe.intersects(boundingBox) )
          return;

        this.children.forEach( child => {

          if (child instanceof Node)
            child.query(circleProbe, points);
          else
            child.forEach( p => {
              if ( circleProbe.contains(p) )
                points.push(p);
            });
        });
        return points;
    }</code></pre>

  <p>
    La méthode <code>query</code>, tout comme la méthode <code>insert</code>, fonctionne de manière récursive et est appelée sur le noeud racine. Elle prend en argument la zone d'inspection circulaire <code>circleProbe</code> et <code>points</code>,
    le tableau de points contenant le résultat de notre requête, à savoir l'ensemble des points contenus dans <code>circleProbe</code>. Ici la subtilité c'est que <code>query</code> est une fonction récursive et qu'elle doit retourner un résultat,
    comme ici
  </p>
  <pre class="language-javascript">
  <code class="language-javascript"> let pointsInsideCircleProbe = rootNode.query(circleProbe);</code></pre>

  <p>La méthode est donc appelée sans l'argument optionnel <code>points</code>, <code>points</code> aura donc pour valeur <code>undefined</code> lors du premier appel sur le noeud racine. Dans ce cas, nous assignons à <code>points</code> un tableau
    vide. La variable <code>points</code> va servir de <em>variable globale</em> à l'ensemble des appels récursifs de <code>query</code>.</p>
  <p>
    Nous regardons d'abord, à la ligne 14, si la zone d'inspection recouvre la zone sous la responsabilité du noeud courant. Si ce n'est pas le cas, alors on retourne, il n'y a rien à voir. Si c'est le cas, on parcourt les enfants du noeud :
  <ul>
    <li>si l'enfant est un noeud, le noeud courant est une branche. <code>circleProbe</code> pourrait recouvrir ce noeud enfant et la méthode <code>query</code> est appelée </li> sur lui.
    <li>si l'enfant n'est pas un noeud, le noeud courant est une feuille. <code>circleProbe</code> pourrait alors contenir un ou plusieurs points portés par ses enfants. On parcourt les points attachés à la feuille (ligne 22) : si un point est
      contenu dans <code>circleProble</code> on l'ajoute à <code>points</code>.</li>
  </ul>
  </p>

  <p> Remarquez qu'à la ligne 22, on retrouve le parcours de tous les points contenus dans la région sous la responsabilité de la feuille. On voit ici clairement le bénéfice du Quadtree: au lieu d'interroger tous les points de l'espace, comme dans la
    solution naïve, on interroge ici <strong>seulement les points contenus dans cette sous-région</strong>.</p>

  <p>Enfin, le premier appel de <code>query</code> sur le noeud racine retourne <code>points</code>. </p>

  <p>Visualisez la méthode <code>query</code> sur la <a href="#demo01">demo 1</a>. La zone circulaire autour du pointeur de la souris représente <code>circleProbe</code>. Vous pouvez alors visualiser l'ensemble des points à l'intérieur mais également
    l'ensemble des points candidats à la requête. Vous pouvez voir que le nombre de points parcourus et évalués n'est pas systématiquement égal au nombre de points total, comme dans le cas de la solution naïve. Ce cas se présente d'ailleurs très
    rarement et généralement le nombre de points évalués lors de la requête est une petite fraction du nombre de points total.</p>

  <p>On peut enfin goûter ici à la puissance et à l'intérêt du Quadtree.</p>


  <h2>L'intérêt des branches et des feuilles</h2>


  <p>
    Vous vous demandez peut-être à ce stade pourquoi avoir pris la peine de distinguer les noeuds en branches et en feuilles.
  </p>
  <p>
    Le fait qu'un noeud, une fois atteint sa capacité maximale, se divise et ne compte parmi ses enfants que d'autres noeuds a un intérêt. Le concept de <em>branche</em> a un intérêt. Imaginons qu'un noeud ait à la fois des points et des noeuds pour
    enfants, et que nous ne faisions pas la distinction entre branche et feuille. Si nous interrogeons ce noeud et que notre zone d'inspection l'intersecte alors nous n'aurions pas d'autre choix que d'évaluer tous ses enfants points, peut importe où
    ils
    se trouvent, à la <a href="#query">ligne 22 du code précédent</a>. Imposer à un noeud d'avoir que des enfants noeuds (branche) ou que des enfants points (feuille) nous préserve d'évaluations inutiles.
  </p>
  <p>
    Enfin, le fait qu'un noeud qui devient branche ne se subdivise pas automatiquement en 4 feuilles mais uniquement en autant de feuilles que nécessaire, nous permet d'éviter des appels inutiles de <code>query</code>. En effet, si nous divisions
    automatiquement en 4 chaque noeud en surcapacité, celui-ci pourrait créer des feuilles vides. <a href="#query">Aux lignes 19 et 20</a> nous ferions alors des appels inutiles de <code>query</code> sur ces noeuds enfants vides.
  </p>
table-hover
  <h2>Paramètres du Quadtree : capacité et profondeur</h2>

  <p>
    Ces paramètres permettent <strong>d'optimiser les performances du Quadtree</strong> en insertion (<code>insert</code>) ou en recherche (<code>query</code>). Ces considérations dépassent l'ambition de cet article, mais il est néanmoins utile de
    les mentionner.
  </p>

  <p>
    Le Quadtree possède deux paramètres ajustables par l'utilisateur : la capacité et la profondeur. La capacité est le nombre de points maximal que peut porter une feuille, la profondeur (ou aussi appelée <em>taille</em> de l'arbre) est une mesure
    de la récursivité de l'arbre. Plus il est profond plus il est nécessaire de faire des appels récursifs pour récupérer les points. On remarque que ces deux paramètres sont corrélés : plus la capacité des noeuds est grande, moins il sera profond et
    inversement.
  </p>

  <h3>Définir une profondeur maximale</h3>
  <p>
    Dans cette implémentation il n'y a aucune restriction sur la profondeur de l'arbre. Chaque noeud peut se diviser et donner naissance à d'autres noeuds plus profonds. On pourrait très facilement rajouter cette fonctionalité en définissant une
    profondeur maximal <code>MAX_DEPTH</code> mettant une condition sur la méthode <code>branch()</code> :
  </p>
  <div>
    <pre class="language-javascript line-numbers">
    <code>insert(point) {
          ...
          if (this.hasReachedMaxCapacity() && this.depth < MAX_DEPTH)
            this.branch();
        }
      }</code></pre>
  </div>

  <p>
    Ainsi, l'arbre aura une taille maximale qu'il ne peut pas dépasser, et les feuilles a la profondeur maximale porteront un nombre indeterminé de points (au delà de leur capacité), ceux-ci <em>s'entasseront au fond</em> de l'arbre.
  </p>
  <p>
    Y'a-t-il un intérêt à définir une profondeur maximale ? Cela dépend des cas mais c'est un choix judicieux lorsqu'on souhaite avoir un peu de contrôle sur les appeles récursifs. Par exemple, dans le cas où vous avez une scène remplie de points
    infinement proches (séparés de quelques pixels). Ces points très proches pourraient être le centre d'objets superposés. Sans profondeur maximale imposée votre Quadtree risque d'avoir des profondeurs localisées très importantes là où les points
    sont infiniment proches. Cette <em>surpartition</em> de l'espace n'est pas très utile car en pratique, si vous voulez faire de la détection de voisinage de l'un de ces points, toutes ces feuilles seront de toute manière inspectées.
  </p>

  <h3>Quelle valeurs choisir pour la capacité et la profondeur maximale?</h3>

  <p>
    La réponse à cette question n'est pas évidente mais elle pourrait être <q>cela dépend de ce que vous voulez</q>. Notez que ces paramètres n'auront pas un effet considérable en soi sur les performances du QuadTree. Un choix minutieux pour ces
    paramètres implique
  </p>

  <p>
    Si vous voulez construire rapidement le QuadTree alors vous avez besoin d'un <code>insert</code> rapide. Pour cela, il suffit d'augmenter la capacité de l'arbre : plus une feuille pourra porter de points, moins elle aura de chance de se
    subdiviser. Ainsi, augmenter la capacité diminue le nombre d'appels récursifs d'<code>insert</code> et diminue le nombre d'appels à <code>branch</code>. Cela dit, en gagnant de l'efficacité en construction vous en perdez nécessairement en
    recherche, car il faudra évaluer plus de points à chaque appel de <code>query</code>.
  </p>

  <p>
    Évidemment, jouer seulement sur la valeur de ces paramètres ne va pas avoir des répercussions importantes sur les performances du QuadTree. Ce choix doit être soutenu par une architecture optimisée en mémoire des fonctions <code>insert</code> et
    <code>querry</code> et surtout d'une optimisation de la gestion de la mémoire.
  </p>
  <p>
    Dans un premier temps, il est inutile de trop s'attarder sur ces paramètres, car choisir leurs valeurs fait partie d'un processus plus large qui est celui de l'optimisation. Et L'optimisation vient toujours après. Si vous voulez en savoir plus
    sur ce sujet des liens sont proposés à
    la fin de l'article sur l'optimisation des Quadtrees.
  </p>

  <p>
    Dans cette implémentation nous avons choisi une valeur de 4, ce qui est un choix totalement arbitraire, mais élégant.
  </p>


  <h2>Démo interactive : profondeur du QuadTree</h2>

  <p>Pour avoir une meilleur idée de la manière dont évolue la profondeur de l'arbre vous avez, ci-dessous, une démo interactive. Vous pouvez ajouter des points (individuellement ou par paquet) et regarder la profondeur d'une feuille sous le curseur.
    La profondeur maximale de l'arbre est également affichée. Le gradient de couleur vous donne une idée de la dispersion des profondeurs des feuilles au sein de l'arbre.</p>


  <h4>Insertion</h4>

  <div id="demo02">
    <div id="radioContainer-demo02">

      <input type="radio" id="normal-demo02" name="insertionModeGroup-demo02" value="point" checked="checked">
      <label for="point"><acronym title="Insère un unique point à chaque clic">Point</acronym></label>

      <input type="radio" id="gaussian-demo02" name="insertionModeGroup-demo02" value="gaussian">
      <label for="gaussian"><acronym title="Insère un nuage gaussien de points à chaque clic">Nuage de points</acronym></label>

      <label for="nbPointsGaussian-demo02">Nombre de points à insérer</label>
      <input type="range" id="nbPointsGaussian-demo02" name="nbPointsGaussian-demo02" value="100" min="10" max="250" disabled="">
      <output id="nbPointsGaussianValue-demo02"></output>
    </div>

    <h4>Infos</h4>
    <div class="highlightContainer">

      <label for="depth_current" <acronym title="Profondeur du noeud sous la souris">Profondeur sous le curseur: </label>
      <span id="depth_current" name="depth_current"></span>

      <label for="depth_max" <acronym title="Profondeur maximale observée dans le Quadtree">Profondeur maximale de l'arbre: </label>
      <span id="depth_max" name="depth_max"></span>

      <div>
        <label for="nbPointsTotal-demo02">Points insérés : </label>
        <span id="nbPointsTotal-demo02" name="nbPointsTotal-demo02">0</span>
      </div>

    </div>
    <div class="resetButtonContainer_demo02">
      <!-- <input type="button" value="reset"> -->
      <button type="button" class="btn btn-primary btn-sm" id="resetButton-demo02" disabled>Réinitialiser</button>
      <input id="switch-demo02" type="checkbox" data-toggle="toggle" data-on="En cours" data-off="En Pause" data-onstyle="success" data-offstyle="warning" data-size="sm" class="switch-demo">
    </div>

    <div>Naviguer vers la démo: <a href="#demo01">1</a> - <a href="#demo02">2</a> - <a href="#demo03">3</a></div>
    <div id="canvas-demo02-depth" class="myCanvas">

    </div>

  </div>

  <p>
    Comme vous pouvez le constater, dans cette application ci la profondeur maximale se stabilise assez rapidement autour de 8, et il n'est pas nécessaire d'implémenter une profondeur maximale.
  </p>


  <h2>Lier notre QuadTree à nos données réelles ou comment attacher des données aux feuilles</h2>

  <p>Jusqu'ici nous avons inséré ou récupéré des points à l'aide de notre QuadTree. C'est bien gentil et intéressant, mais où sont passées nos données ? Ici nous allons voir comment nous allons connecter notre QuadTree à nos données réelles. C'est
    l'ultime étape pour rendre tous nos efforts utiles et notre QuadTree intéressant.</p>
  <p>
    Le principe est très simple et élégant : chaque point inséré dans le QuadTree garde une référence (ou un pointeur) vers la donnée qu'il est supposé représenter. Et c'est tout ! Regardons la structure <code>Point</code>
  </p>

  <div>
    <pre class="language-javascript line-numbers">
    <code>class Point {
      constructor(x, y, data) {
        this.x = x;
        this.y = y;
        this.data = data;
      }
    }</code></pre>
  </div>

  <p>Elle possède trois propriétés : <code>x</code> et <code>y</code> les coordonnées du point, et <code>data</code> qui est une référence vers la donnée que ce point représente, peut importe sa nature.</p>

  <p>L'intérêt de cette façon de faire c'est que notre structure (ou classe, appelez ça comme vous voulez) <code>Point</code> agit comme une interface qui masque les détails du fonctionnement de notre QuadTree et <strong>découple</strong> la donnée
    (qui peut être absolument tout ce que vous voulez) de la représentation qu'a cette donnée dans l'implémentation du QuadTree. Autrement dit, nous n'aurons plus jamais à modifier notre implémentation du QuadTree maintenant que nous avons notre
    structure <code>Point</code>.</p>
  <p>
    Maintenant que chaque point porte une référence sur la donnée qu'il représente, il suffit d'en construire un pour chaque donnée et lui assigner des coordonnées. Ces coordonées peuvent être intrinsèques à la donnée (si votre donnée est une
    particule alors elle possède naturellement des coordonées spatiales par exemple) ou
    calculées au moment de la création de <code>Point</code> (par exemple le nombre de voyelles dans un mot peut agir comme une coordonée dans un espace à une dimension pour ma donnée <q>mot</q>).
  </p>

  <p>
    Par exemple, si j'ai une structure <code>data</code> et que je souhaite l'insérer dans mon QuadTree il faut que j'instancie un <code>Point</code>. Le QuadTree ne connait pas d'autres formes de données que des <code>Point</code>, vos données ne
    l'intéresse pas. Au passage, <code>Point</code> n'est qu'une structure qui possède deux coordonnées <code>x</code> et <code>y</code>. C'est tout ce dont a besoin le QuadTree pour fonctionner. Voici comment on pourrait s'y prendre :
  </p>

  <div>
    <pre class="language-javascript line-numbers">
    <code>let point = new Point(data.x(), data.y(), data)
    rootNode.insert(point);</code></pre>
  </div>
  <p>
    Ici <code>data</code> fournit des coordonnées <code>x</code> et <code>y</code> par des méthodes pour rester le plus général possible, au cas où vos données ne contiennent pas <em>naturellement</em> de coordonnées dans un espace bidimensionnel.
    Remarquez
    que le troisième argument est <code>data</code> lui-même. </p>
  <p>On instancie un point, on le lie à sa donnée et on l'insert dans le QuadTree.</p>

  <p>
    Comment récupérer nos données ? Un appel à <code>query</code> sur notre QuadTree nous renverra une liste de points et non une liste de données. Il suffit simplement d'accèder à la donnée portée par le point : <code>point.data</code>, ou alors
    dans
    le cas d'une liste :
  </p>

  <div>
    <pre class="language-javascript line-numbers">
    <code>const points = rootNode.query(probe);
    const datas = points.map(point => point.data)</code></pre>
  </div>

  <p>
    Sur la première ligne nous récupérons la liste des points correspondant à notre requête. A la deuxième ligne, on récupère ce qu'on veut vraiment : un tableau des données portées par ces points, grâce à la méthode <a
      href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/map">map</a>.
  </p>

  <p>
    En résumé de cette partie, nous avons vu comment lier nos données aux points manipulés par le QuadTree. Grâce à cette implémentation nous pouvons désormais représenter n'importe quelle donnée dans notre QuadTree et nous en servir pour interroger
    efficacement nos données. La structure <code>Point</code> sert <strong>d'interface</strong> et permet de découpler les données de leur représentation dans le QuadTree. Nous n'aurons donc jamais à toucher à notre implémentation du QuadTree lorsque
    nous voudrons l'utiliser pour interroger des nouveaux types de données.
  </p>

  <p>Notre QuadTree est enfin devenu utile ! Dans la prochaine partie, en guise d'illustration, nous allons nous servir du QuadTree pour faire de la détection de collisions entre particules dans une simulation 2D.</p>

  <h2>Utiliser la puissance du QuadTree pour la détection de collisions</h2>



  <p>Supposons que nous ayons un ensemble de particules circulaires qui se déplacent dans un espace en deux dimensions. Nous voudrions savoir quand ces particules rentrent en collision pour y appliquer un traitement. Par exemple, nous souhaiterions
    appliquer des
    forces de répulsion pour qu'elles rebondissent les unes sur les autres. Ou encore, dans le cas d'un jeu de shoot, nous voudrions que deux particules se détruisent lorsqu'elles rentrent en contact. Ce que vous voulez faire du résultat de cette
    détection,
    c'est votre problème. Détecter les collisions en revanche, c'est un problème qu'un QuadTree sait très bien gérer, et de manière efficace.</p>
  <p>

  <h3>Définir une collision</h3>

  Pour savoir si deux particules circulaires entrent en collision il suffit de déterminer si ces deux particules se recouvrent ou non. Prenons deux particules de rayon <code>r<sub>1</sub></code> et <code>r<sub>2</sub></code>. Pour déterminer si ces
  deux particules se chevauchent il suffit de calculer la distance entre leurs centres et de regarder si cette distance est inférieure à la somme de leurs rayons respectifs, soit <code>d<sub>1-2</sub></code>
  < <code>r<sub>1</sub></code> + <code>r<sub>2</sub></code>. Si cette évaluation est vraie, alors les particules sont en collision. On pourrait implémenter une fonction <code>overlap</code> qui prend en argument les deux particules et renvoie vrai
    si elles se chevauchent, faux sinon :
    </p>

    <div>
      <pre class="language-javascript line-numbers">
    <code>overlap(particule1, particule2){
      const distanceSquared = (particule1.x - particule2.x) * (particule1.x - particule2.x) + (particule1.y - particule2.y) * (particule1.y - particule2.y);
      return distanceSquared < (particule1.r + particule2.r) * (particule1.r + particule2.r);
    }</code></pre>
    </div>

    <p>Ici on manipule tout <em>au carré</em> pour éviter de faire des appels coûteux de <code>Math.sqrt()</code> et <code>Math.pow()</code>. C'est une petite optimisation qui a son importance car cette fonction va être appelée de manière intensive.
    </p>

    <h3>Détecter une collision, quand le QuadTree rentre en scène</h3>
    <p>
      Prenons une particule. Quelles particules doit-elle considérer comme étant potentiellement en collision avec elle ?
    </p>
    <h4>Toutes, la solution naïve</h4>

    <p>Souvenez vous, au début de cet article nous avons parlé d'une approche directe, sans structure de données efficace, pour résoudre ce genre de problème. Dans le cas où nous n'avons rien préparé en amont nous devons checker toutes les paires
      possibles de particules. Une procédure qui hérite en temps d'une complexité <code>O(n<sup>2</sup>)</code> car il faut parcourir, pour chaque particule, toutes les autres particules.</p>

    <h4>La solution QuadTree</h4>
    <p>
      Nous pouvons faire mieux à présent ! Nous allons toujours parcourir toutes les particules, ça malheureusement nous avons pas le choix (même s'il est possible de penser ici à faire des optimisations mais ce n'est pas le programme). Seulement à
      présent, nous allons <em>uniquement</em> tester celles qui sont dans son voisinage grâce à notre structure QuadTree et notre partitionnement de l'espace.
    </p>

    <p>
      Premièrement, à chaque instant de notre simulation, nous allons construire un QuadTree. Vous verrez par vous même dans la <a href="#demo3">démo suivante</a> que cette opération ne <strong>coûte rien</strong>, et qu'elle résiste très bien à la
      montée en charge du
      nombre de particules à insérer. Ce n'est pas surprenant car <code>insert</code> réalise des opérations très primitives. Les évaluations ne coûtent pas grand chose, l'accès à la mémoire oui ! Parcourir <code>n<sup>2</sup></code> éléments d'un
      tableau, déférencer le contenu du pointeur, accèder à ses propriétés (ou attributs) ça, ça coûte cher.
    </p>
    <p>
      J'insère donc mon tableau de particules <code>particules</code>, élément par élément, dans mon QuadTree en m'adressant au noeud racine <code>rootNode</code> :
    </p>
    <div>
      <pre class="language-javascript line-numbers">
    <code>particules.forEach( particule => {
      rootNode.insert( new Point(particule.x, particule.y, particule));
    });</code></pre>
    </div>
    <p>
      Maintenant que le QuadTree est construit, il me suffit de parcourir toutes mes particules une par une. Pour chaque particule je n'ai plus besoin d'interroger <em>toutes les autres</em>, il me suffit de faire une requête au QuadTree, avec ma
      zone d'inspection, centrée sur la position de ma particule ! Exactement comme dans la <a href="#demo1">démo 1</a>, lorsque je déplace mon curseur. Je peux alors récupérer toutes les particules voisines de ma particule considérée :
    </p>
    <div>
      <pre class="language-javascript">
    <code>probe(particule.x, particule.y);
    let neighbors = rootNode.query(probe);</code></pre>
    </div>
    <p>
      où <code>probe</code> est une zone d'inspection circulaire positionnée exactement au centre de la particule courante.
    </p>
    <p>
      La zone d'inspection doit cependant avoir une taille souvenez vous, un rayon, que l'on appellera <code>R</code>. Quelle valeur de <code>R</code> doit-on choisir ? Si on veut être sûr de ne rater aucune particule dans le voisinage de la
      particule
      considérée, il faut que cette taille soit suffisament grande. Au moins supérieure à la taille <code>r</code> de la particule, soit <code>R > r</code>. Mais pas trop grande non plus, car sinon on considérerait trop de particules qui <em>ne
        peuvent
        pas</em> être en collision avec cette particule car elles sont trop loin ! Dans le cas où les particules ont toutes une taille différente, c'est à dire que notre échantillon de particules est <em>poly-disperse</em>, il me suffit de connaître
      la
      taille de la particule la plus grande <code>r<sub>max</sub></code>. Je peux facilement la déterminer avant de commencer ma simulation, ou le recalculer si les tailles des particules changent au cours du temps. C'est la distance minimale
      nécessaire d'inspection pour pouvoir affirmer ne rien rater </p>

    <p>
      Une fois <code>r<sub>max</sub></code> connue alors il me suffit de regarder dans un rayon de <code>r + r<sub>max</sub> </code> autour du centre de ma particule pour être sûr de ne rater aucune collision. Voilà la taille de ma zone d'inspection
      : <code>R = r + r<sub>max</sub> </code>. Notez qu'ici cette taille doit être recalculée pour chaque particule. Il est également possible d'y aller de manière plus forte, mais qui ne nécessite pas une mise à jour de la taille, en définissant une
      fois pour toute <code>R</code> = <code>2r<sub>max</sub></code>.
    </p>
    <p>
      Notre tableau de voisins <code>neighbors</code> contient donc toutes les particules dans le voisinage de la particule considérée, c'est à dire dans un rayon <code>2r<sub>max</sub></code> autour d'elle. Il n'y a plus qu'à les parcourir, à
      appliquer notre fonction <code>overlap</code> pour savoir si elles se chevauchent, et voilà ! Vous n'avez plus qu'à faire le traitement qui vous convient en cas de collision.
    </p>

    <h3>Qu'avons-nous gagné ?</h3>
    <p>
      Qu'avons nous gagné dans cette histoire ? Nous héritons toujours de la complexité minimum en <code>O(n)</code>. Souvenez-vous, je dois toujours parcourir <em>au moins une fois</em> toutes mes particules. Très bien, quel complexité à présent
      pour trouver les voisins ? Lorsque nous avons analysé la complexité de
      recherche
      dans le QuadTree, la méthode <code>query</code>, nous avions vu qu'il était difficile de la définir avec certitude. À défaut de la définir nous avons été capable de la borner, ce qui est déjà pas trop mal. Nous pouvions au moins donner les
      bornes min et max de cette complexité.</p>
    <p>
      Au minimum, une requête au QuadTree est proportionnelle à la profondeur
      <code>p</code> de
      l'arbre, soit <code>O(p)</code>. Cette profondeur, vous avez pu l'expérimenter dans la <a href="#demo2">démo précédente</a>, reste assez insensible au <em>nombre</em> de points présents dans le QuadTree, elle est uniquement sensible à <em>la
        densité</em> de points. Vous
      avez pu voir qu'il était difficile de dépasser une profondeur de <code>10</code> par exemple, même en insérant beaucoup de points (car la résolution de l'espace n'est pas suffisament grande). Le point important ici c'est que <strong>la
        profondeur à laquelle une feuille se trouve n'est
        pas fonction du nombre de points total</strong>. Ce sont là <em>deux choses</em> différentes. Évidemment, en moyenne, dans un espace fini, la densité augmente avec le nombre de points. Mais <em>localement</em> cette propriété n'est pas
      nécessairement vraie. Autrement dit, on peut faire l'approximation suivante : la complexité en temps minimale d'une requête au QuadTree, <code>O(p)</code> est équivalente à une complexité constante, c'est à dire <code>O(1)</code>. Elle n'est
      pas fonction du nombre de
      particules, elle n'est pas <code>O(n)</code>.
    </p>

    <p> Concernant la borne maximale, justement, lorsque la densité des points est très importante, quand tous vos points sont agglutinés au même endroit, vous retombez nécessairement sur une complexité
      <code>O(n)</code>, car tous les points sont là, vous devez les considérer !</p>
    <p>
      On en revient donc à cette conclusion minimale sur les performances de notre QuadTree dans le cas de la détection de collisions. La complexité de la détection des collisions est comprise entre <code>O(n)</code> et <code>O(n<sup>2</sup>)</code>.
      La majorité du temps, sauf cas de densité immense (et là aucun algorithme sans <em>a priori</em> sur vos données ne pourra faire mieux), la complexité sera plus proche de la borne inférieure que supérieure. On peut donc dire qu'on a gagné, en
      moyenne, un
      facteur <code>n</code> dans notre complexité. Ce qui n'est pas rien !
    </p>

    <h3>Démo interactive : détection de collisions et analyse des apports du QuadTree face à la méthode <i>naïve</i></h3>

    <p>
      La démo ci-dessous est là pour vous convaincre que tout ce travail préalable n'a pas été fait en vain, et que ces analyses de complexité <em>sont visualisables et se ressentent</em>. La démo fait vivre un ensemble de particules circulaires, de
      tailles
      différentes, qui rebondissent sur les parois d'une boîte. Lorsque deux particules se chevauchent elles changent de couleur pour témoigner d'une collision. Vous pouvez modifier le nombre de particules et choisir la méthode de détection des
      collisions : <em>naïve</em> ou avec l'utilisation du QuadTree.
    </p>
    <p>
      Pour les deux méthodes vous avez accès au temps nécessaire pour calculer toutes les détections de collisions, ainsi qu'au <em>FrameRate</em>, une mesure de performance quantitative. Elle mesure la fluidité de <em>l'animation</em> et donc
      indirectement le temps de calcul des collisions.
    </p>
    <p>
      Dans le cas où vous utilisez le QuadTree vous avez accès à son temps de construction en temps réel. Ce temps est le temps nécessaire pour insérer tous les points dans le noeud racine. Ceci est pour vous convaincre que construire le QuadTree, à
      chaque frame, car les particules changent de position, <em>ne coûte rien</em> comparé au temps nécessaire pour parcourir toutes les particules.
    </p>
    <div id="demo03">
      <div>
        <div id="radioContainer-demo03">

          <input type="radio" id="quadtree" name="algorithme" value="quadtree" checked="checked">
          <label for="quadtree"><acronym title="Utiliser le quadtree">Quadtree</acronym></label>

          <input type="radio" id="naive" name="algorithme" value="naive">
          <label for="naive"><acronym title="Utiliser l'algorithme naïf qui parcourt toutes les paires">Approche naïve</acronym></label>



          <label for="nbParticules">Nombre de particules</label>
          <input type="range" id="nbParticulesRange" name="nbParticules" value="200" min="2" max="1500">
          <output id="output-nbParticules"></output>
        </div>
      </div>

      <h4>Infos</h4>
      <div>
        <label for="timeToBuildQuadtree" <acronym title="Temps d'éxecution nécessaire à la construction du quadtree uniquement">Temps construction du Quadtree (ms) : </label>
        <span id="timeToBuildQuadtree" name="timeToBuildQuadtree"></span>
      </div>
      <div>
        <label for="timeToComputeInteractions" <acronym
          title="Temps d'execution nécessaire au calcul de toutes les interactions. Dans le cas de l'approche naive le calcul mesure le temps nécessaire pour parcourir toutes les paires de particules. Dans le cas du Quadtree, le calcul comprend le temps de construction du Quadtree et des querry.">Temps
          total du calcul de toutes les interactions (ms) :</label>
        <span id="timeToComputeInteractions" name="timeToComputeInteractions"></span>

        <div><label for="pourcentage" <acronym title="Rapport (en %) du temps nécessaire à la construction du Quadtree par rapport au temps nécessaire au calcul des interactions">Rapport du temps de
            construction du Quadtree au temps du calcul des interactions (%):</label>
          <span id="pourcentage" name="pourcentage"></span></div>


        <div>
          <label for="frameRate">FrameRate (frames/s): </label>
          <span id="frameRate">0</span>
        </div>
      </div>

      <div>
        <input type="checkbox" name="showQuadTreeCheckbox" id="showQuadTreeCheckbox">
        <label for="showQuadTreeCheckbox">Afficher quadtree</label>
        <input type="checkbox" name="showDetectionZoneCheckbox" id="showDetectionZoneCheckbox">
        <label for="showDetectionZoneCheckbox">Afficher zones de détection</label>
      </div>

      <div>Naviguer vers la démo: <a href="#demo01">1</a> - <a href="#demo02">2</a> - <a href="#demo03">3</a></div>

      <div class="resetButtonContainer">
        <!-- <input type="button" value="reset"> -->
        <button type="button" class="btn btn-primary btn-sm" id="resetButton-demo03">Réinitialiser</button>
        <input id="switch-demo03" type="checkbox" data-toggle="toggle" checked data-on="En cours" data-off="En Pause" data-onstyle="success" data-offstyle="warning" data-size="sm" class="switch-demo">
      </div>

      <div id="canvas-demo03-collisions" class="myCanvas">
      </div>
    </div>

    <h4>Notes sur la démo</h4>
    <p>
      Les mesures absolues affichées ici n'ont pas d'intérêt en soi, les performances dépendront de votre navigateur, de votre machine. La seule chose qui est objectivement intéressante ici sont les mesures relatives : le rapport du temps de
      construction de l'arbre au temps de calcul des interactions, ou entre la méthode <em>naïve</em> et la méthode <em>QuadTree</em>. D'autre part, étant donné l'objectif de cette démo, il n'y a pas d'implémentation d'une réelle <a
        href="https://developer.mozilla.org/en-US/docs/Games/Anatomy">gameloop</a> : la fréquence de calcul des interactions est la même que la fréquence d'affichage (imposée par défaut à 60 frames par seconde) . Gardez donc à l'esprit que les
      mesures
      et les performances de chaque méthode présentées ici ne sont pas <em>en soi</em> pertinentes. Cette démo a pour but de montrer qualitativement en quoi le QuadTree est plus performant qu'une approche <em>naïve</em>.
    </p>


    <h2>Conclusions</h2>
    <p>
      Dans cet article nous avons vu ce qu'était un QuadTree, à quoi il pouvait servir et à quel genre de questions il pouvait répondre. Le QuadTree est une généralisation du <a href="https://en.wikipedia.org/wiki/Binary_tree">BinaryTree</a> à deux
      dimensions. Il est également possible de généraliser les mécanismes du QuadTree à trois dimensions, c'est ce qu'on appelle un <a href="https://fr.wikipedia.org/wiki/Octree">OctTree</a>. Ces trois structures de données sont fondamentalement les
      mêmes : ce sont des arbres et ils fonctionnent par partition récursive de l'espace en 1, 2 ou 3 dimensions. Tout ce que vous avez appris sur les QuadTrees est transférable aux arbres de dimension inférieure ou supérieure. C'est la bonne
      nouvelle.
    </p>
    <p>
      Nous avons également mis en place une implémentation du QuadTree en JavaScript. Nous avons vu comment cet arbre se construisait, et nous avons abordé les différents types de noeuds de l'arbre: les feuilles et les branches. Enfin, nous nous en
      sommes servis pour un cas d'application concret: la détection de collisions en deux dimensions.
    </p>
    <p>
      Cet article est une longue introduction aux QuadTrees et abordent ses composantes fondamentales. Il est possible d'aller beaucoup plus loin, notamment dans les possibilités d'amélioration et d'optimisation de notre implémentation. Des liens
      vous sont proposés dans la section suivante. Il est également possible de se servir du QuadTree pour poser beaucoup plus de questions que celles évoquées ici. Par exemple, il peut permettre de trouver les voisins les plus proches, de
      compresser des images etc.
    </p>
    <p>
      Il y a encore beaucoup de choses à découvrir sur les QuadTrees ! J'espère que cet article vous aura donné les armes pour aller plus loin et mieux appréhender ces structures en arbre qui offrent de nombreux possibles dans la manipulation et le
      traitement des données. Ces structures en arbre sont présentes dans de nombreux algorithmes et il est intéressant d'apprendre à les connaître et à les utiliser.
    </p>

    <h2>Code source de l'implémentation du QuadTree</h2>
    <p>Le code source de l'implémentation discutée et présentée dans cet article est disponible <a href="">ici</a>.</p>
    <p>Les démos interactives ont été développées avec la librairie <a href="https://p5js.org/">p5js</a>.</p>
    <h2>Sources : aller plus loin</h2>

    <dl>
      <dt>The coding train</dt>
      <p>L'inénarrable <a href="https://shiffman.net/">Daniel Shiffman</a> qui m'a intéressé aux QuadTrees et m'a inspiré pour écrire cet article. Vous pouvez voir sa série en trois vidéos sur le sujet :</p>
      <dd>
        <ul>
          <li><a href="https://www.youtube.com/watch?v=OJxEcs0w_kE">partie 1</a></li>
          <li><a href="https://www.youtube.com/watch?v=QQx_NmCIuCY">partie 2</a></li>
          <li><a href="https://www.youtube.com/watch?v=z0YFFg_nBjw">partie 3</a></li>
        </ul>
      </dd>
      <dd><a href="https://gamedevelopment.tutsplus.com/tutorials/quick-tip-use-quadtrees-to-detect-likely-collisions-in-2d-space--gamedev-374">Quick Tip: Use Quadtrees to Detect Likely Collisions in 2D Space</a>, par Steven Lambert</dd>
      <dt>Visualisation</dt>
      <dd><a href="https://jimkang.com/quadtreevis/">An interactive explanation of quadtrees</a>, par Jim Kang. Une très belle démo interactive où l'on peut se déplacer de l'espace aux noeuds de l'arbre.</dd>
      <dt>Optimisation</dt>
      <dd>
        <a href="https://dev.solita.fi/2015/08/06/quad-tree.html">Is there an optimal quad tree out there?</a> par Paavo Toivanen
      </dd>
      <dd>
        <a href="https://stackoverflow.com/questions/41946007/efficient-and-well-explained-implementation-of-a-quadtree-for-2d-collision-det/48330314#48330314">Efficient QuadTree on StackOverflow</a> par Dragon Energy
      </dd>

    </dl>


    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/js/bootstrap4-toggle.min.js"></script>

    <script src="js/lib/prism.js"></script>

</body>


<script type="module" src="js/main.js">
</script>

<script type="text/javascript" src="js/lib/p5.js">
</script>

<!-- TODO: faire import plus propre -->
<!-- <script src="js/quadTree.js"></script>
<script src="js/pedagogic_extension.js"></script>
<script src="js/api_render.js"></script> -->

<!-- <script src="js/demo01/ui_app01.js"></script>
<script type="module" src="js/demo01/app01.js"></script>

<script src="js/demo02/app02.js"></script>
<script src="js/demo02/ui_app02.js"></script>

<script src="js/demo03/ui_app03.js"></script>
<script src="js/demo03/app03.js"></script> -->


</html>
