<!DOCTYPE html>
<html lang="fr">

<head>
  <script src="js/lib/p5.js"></script>

  <meta charset="utf-8">

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">

  <link href="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/css/bootstrap4-toggle.min.css" rel="stylesheet">

  <link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body>

  <h1>Quadtree</h1>

  <h2>Introduction</h2>

  <h3>Ce que nous allons aborder et ce dont nous ne parlerons pas</h3>

  <p>
    Les <a href="https://fr.wikipedia.org/wiki/Quadtree">quadtree</a> sont des structures de données qui peuvent être très utiles pour résoudre certains types de problèmes. Précisons d'emblée que cet article ne cherche pas à couvrir de manière
    exhaustive tous les usages et les contextes d'application des quadtrees. Nous nous nous restreindrons à son usage principal, celui du partitionnement d'un espace à deux dimensions.
    Au lieu de partir de considérations théoriques et générales nous allons plutôt aborder les quadtrees d'un point de vue pratique en tachant de répondre à ces questions : à quoi un quadtree peut-il servir ? Qu'est ce qu'un quadtree ? Comment le
    construire ? Comment l'interroger ? Comment s'en servir ?
    Nous allons donc commencer par proposer une définition d'un quadtree. Puis, à l'aide de notre définition, nous allons le construire et l'implémenter (en JavaScript ici mais facilement
    reproductible dans n'importe quel langage de programmation). Nous allons ensuite voir comment nous en servir pour manipuler ou interroger efficacement nos données.
    Finalement, nous allons l'utiliser dans un cas pratique où le quadtree fait largement ses preuves : la détection de collisions.

  </p>



  <h3>Dans quel cas les quadtrees sont-ils utiles?</h3>

  <p>
    Avant même de définir ce qu'est un quadtree, il paraît intéressant de voir à quoi peut-il peut servir et à quels types de questions il permet de répondre.
  </p>

  <p>
    Pour nous servir des quadtrees nous avons besoin d'un espace à deux dimensions (un écran, un sous-espace d'un espace plus grand, une scène où se déplacent des objets, une image etc...)
    et que cet espace contienne des points. Ces points peuvent représenter n'importe quoi, la seule chose qui importe c'est que les <strong>coordonnées de ces points représentent
      quelque-chose</strong>. Par exemple ces points pourraient représenter des particules, les pixels d'une image, les villes d'un pays etc... Les coordonnées ont du sens : deux particules veulent savoir si elles sont en contact ou non, le sens
    d'une image est
    contenu dans les positions relatives de ses pixels, les villes ne sont pas n'importe où !
    Par exemple, un sytème de coordonées peut être défini de sorte à ce qu'un axe représente la distance vers l'avant par rapport à
    l'origine choisie,
    et l'autre celle vers la gauche. La particule pourrait être représentée dans cet espace par un couple de deux valeurs mesurant la position du centre géometrique de la particule. Mais la distance mesurée entre deux points dans un système de
    coordonnées ne se restreint pas
    à
    la mesure d'une distance <i>strictement spatiale</i> : on pourrait tout aussi bien définir un espace avec un axe <i>proportion de voyelles</i> et y représenter des chaînes de caractère. Cet espace permettrait de définir une mesure de proximité
    entre des mots ou
    des phrases par exemple. On pourrait également représenter des points dans un espace où une dimension mesure la position et l'autre le temps etc.
  </p>

  <p>
    Mais prenons l'exemple classique d'un espace à deux dimensions peuplé d'objets, représenté chacun par un point. Pour des raisons pratiques nous appelerons <strong>point</strong> la représentation de l'objet dans notre espace par ses coordonnées.

  <div class="row justify-content-center">
    <figure class="figure">
      <img src="media/figure01.png" class="figure-img img-fluid rounded" alt="un espace bidimensionnel peuplé d'objets représentés par des points" title="un espace bidimensionnel peuplé d'objets représentés par des points" width="452" height="328" />
      <figcaption class="figure-caption text-center">Figure 1 : un espace bidimensionnel peuplé d'objets</figcaption>
    </figure>
  </div>

  Supposons que nous voulions interroger les propriétés de voisinage de ces objets. Par exemple, nous aimerions savoir combien de voisins possède chaque objet dans une zone définie autour de celui-ci? Ces voisins possèdent-ils des propriétés
  analogues ou différentes? Quel
  est le voisin le plus proche de chaque point ? Ou non finalement, qui sont les trois voisins les plus proches ? Ou, tout simplement, combien y'a-t-il d'objets présents dans une zone définie autour d'un point quelconque? La liste n'est pas
  exhaustive, mais toutes ces questions ont ceci en commun :
  elles trouvent leurs réponses dans les mesures des distances entre les points. Elles ont un caractère <i>géometrique</i>.
  </p>

  <div class="row justify-content-center" id="figure02">
    <figure class="figure">
      <img src="media/figure02.png" class="figure-img img-fluid rounded" alt="un espace bidimensionnel peuplé d'objets représentés par des points. Un cercle rouge défini un sous-espace"
        title="Combien de points se trouvent dans le sous-espace défini par le cercle rouge?" width="452" height="328" />
      <figcaption class="figure-caption text-center">Figure 2 : combien de points se trouvent dans <br />le sous-espace défini par le cercle rouge? </figcaption>
    </figure>
  </div>
  <p>
    Reprenons l'une des questions précédentes sur le voisinage : quels sont les objets présents dans une zone bien délimitée de mon espace? Comme nous pouvons le voir sur la <a href="#figure02">figure 2</a>, nous retrouvons notre ensemble d'objets
    dans
    un espace
    bidimensionnel, où chaque objet est repéré par ses coordonnées et représenté par un point blanc. Nous voulons savoir quels sont les objets présents à l'interieur du cercle rouge. Nous voulons, par exemple, sélectionner ces points et leur
    appliquer un traitement particulier. Comment allons-nous nous y prendre? La solution <i>naïve</i> consisterait à parcourir tous les points et à tester s'ils se trouvent à l'intérieur du domaine délimité par le cercle rouge. Cette
    solution demanderait un temps d'execution propotionnel au nombre de points à traiter, on dit qu'elle est <code>O(n)</code>, où <code>n</code> représente le nombre de
    points à parcourir. La <a href="https://fr.wikipedia.org/wiki/Analyse_de_la_complexit%C3%A9_des_algorithmes">complexité</a> d'un algorithme, ou d'une fonction, est une mesure de la quantité de ressources (temps ou mémoire) nécessaire à son
    éxecution. Si nous avons un million de points et que notre cercle rouge ne contient que deux points alors nous devrons faire un million d'opérations pour n'en sélectionner que deux !
  </p>
  <p>
    Et ce n'est pas tout. Là encore c'est une complexité tolérable. Supposons que nous cherchions à savoir quel est le point le plus proche de chaque point. Pour y arriver nous devrions, pour chaque point, regarder les n - 1 points restants, mesurer
    la distance entre les deux et garder le point pour lequel la distance est la plus courte. Et nous devrions répeter cette opération n fois, pour chaque point. Cela veut dire qu'il faudrait n * (n -1) opérations pour obtenir notre résultat. Il
    serait possible de réduire le coût en ne considérant les paires qu'une fois. Comme chaque paire compte double dans le décompte précédent il est encore possible de diviser par 2 le nombre d'opérations, pour le ramener à n(n-1)/2. Néanmoins, on
    voit toujours apparaitre un facteur n*n. La complexité de notre calcul est donc ici en <code>0(n2)</code>. Si nous avions un million de points il faudrait faire un billion (1 000 000 000 000) d'opérations pour obtenir notre résultat ! Ce n'est
    pas sérieux. La complexité
    <code>0(n2)</code> est une complexité qu'il faut éviter à chaque fois que cela est possible, sa mise à l'échelle avec la taille de l'échantillon est trop vertigineuse, et elle indique souvent qu'il y'a <i>un autre chemin</i>.
  </p>

  <p>
    Pou réduire cette complexité l'une des premières choses à faire est de repenser notre structure de données, celle dans laquelle sont rangés nos points. De nombreuses structures de données existent
    et permettent d'organiser les données de manière à faciliter leur traitement. Chaque structure de données possède des avantages et des inconvénients vis à vis du traitement que l'on
    souhaite réaliser. Réduire la complexité et augmenter les performances d'un programme en charge de la réalisation d'un traitement de données passe d'abord par le choix d'une structure de données adaptée.
  </p>

  <p>
    Pour le moment, nos objets sont stockés sous la forme d'un tableau, ou d'une liste, comme il est courant de le faire. Nous devons parcourir le tableau de points et tester pour chacun d'entre eux s'il est à l'interieur de la zone circulaire rouge.
    Mais c'est embêtant, car nous devons tester tous les points, même ceux à l'autre bout de l'espace, loin, si loin de notre zone. Il doit y avoir une meilleure solution. Pouvons-nous mieux faire? Oui, nous pouvons mieux faire ! Et pour mieux faire
    nous avons besoin d'une
    structure de données adaptée à ce genre de problème : le quadtree.
  </p>


  <p>
    Le quadtree est une structure de données où l'on va ranger les points dans des petites boîtes. Ces boîtes seront définies en appliquant une décomposition de l'espace en quatre sous-espaces égaux de manière <a
      href="https://fr.wikipedia.org/wiki/R%C3%A9cursivit%C3%A9">récursive</a>. L'espace sera ainsi divisé <i>sur lui même</i> jusqu'à ce qu'aucune boite ne contienne plus de quatre points. C'est son aspect récursif qui
    lui donne la forme d'un arbre (<i>tree</i>). Le <i>quad</i> vient lui du fait qu'on découpe l'espace toujours en quatre. Même si cette définition parait pour le moment très insatisfaisante, nous allons voir que le but du quadtree est d'organiser
    autrement les points (sans toucher à leur coordonnées bien entendu) pour optimiser drastiquement le coût de nos investigations. Pour reprendre la
    question que nous nous posons, à savoir combien de points sont compris dans le cercle rouge, le problème de la solution naïve vient du fait qu'elle nous force à interroger tout l'espace (et donc tous les points !). Le quadtree va nous permettre
    d'affiner
    notre requête et d'interroger une partie de l'espace. Mais inutile de bavarder plus longtemps, et rentrons dans le vif du sujet.
  </p>


  <dl>
    <dt>
      Ce qu'il faut retenir
    </dt>
    <dd>
      <p class="togo">
        Les quadtrees sont des structures de données qui permettent de traiter efficacement des données existantes dans un espace bidimensionnel. L'utilisation d'un quadtree pour réaliser ces
        traitements offre un gain de performance considérable par rapport à l'approche <i>naïve</i>. Ce bénéfice provient du fait que le quadtree partitionne l'espace de manière récursive pour ré-organiser les données.
      </p>
    </dd>
  </dl>


  <h2>Définitions</h2>

  <p>
    Mettons nous d'accord sur le vocabulaire et quelques définitions afin de ne laisser place à aucune ambiguité. En effet, il n'y a pas de définition standard du quadtree, plusieurs implémentations existent et ont chacune leur intérêt et leur
    défaut. Il existe plusieurs stratégies pour le construire et la structure possède plusieurs paramètres (capacité, profondeur...) ajustables par l'utilisateur en fonction de ses besoins. Néanmoins, tous les quadtrees partagent une définition
    commune : ce sont des structures de type arbre (récursives) dans laquelle chaque noeud à quatre enfants. La suite de cet article s'appuiera sur l'ensemble des défintions suivantes.
  </p>

  <p>

  </p>

  <dl>
    <dt>
      Noeud
    </dt>
    <dd>
      le noeud est le composant fondamental du quadtree. Le quadtree est une association de noeuds, et il commence toujours par un noeud initial, un noeud racine. Les points insérés dans un quadtree finissent toujours attachés à un et un seul noeud.
      Un noeud peut avoir jusqu'à 4 enfants. Le quadtree possède deux types de noeuds : les branches et les feuilles.
    </dd>
    <dt>
      Branche
    </dt>
    <dd>
      un noeud qui ne peut porter (avoir pour enfant direct) que des noeuds, branche ou feuille, mais jamais de points.
    </dd>
    <dt>
      Feuille
    </dt>
    <dd>
      un noeud qui ne peut porter que des points, mais jamais d'autres noeuds. Lorsque la capacité de la feuille est excédée elle se transforme en branche.
    </dd>
    <dt>
      Enfant
    </dt>
    <dd>
      un enfant est un élément du quadtree qui est porté par son noeud parent. Un enfant peut-être un noeud ou un point. Seul un noeud peut être parent. Par exemple, sur la <a href="#figure3"> figure 3</a>, la feuille <i>b</i> est l'enfant de la
      branche <i>a</i>. On dit que <i>a</i> porte <i>b</i>. De même, le point <i>c</i> est l'enfant de la feuille <i>b</i>, mais <i>c</i> n'est pas l'enfant de <i>a</i>, car <i>a</i> ne porte pas directement <i>b</i>.
    </dd>
    <dt>
      Capacité
    </dt>
    <dd>
      le nombre maximal d'enfants qu'une feuille peut porter. Par défaut la capacité est de quatre. Ainsi on conserve une certaine homogénéité dans notre définition : une branche a la même capacité qu'une feuille. Si la capacité d'une branche est par
      définition de 4 (<i>quad</i>tree) la capacité d'une feuille pourrait être supérieure ou inférieure (chaque feuille ne pourrait porter qu'un point par exemple).
    </dd>
    <dt>
      Profondeur
    </dt>
    <dd>
      le niveau auquel se trouve un noeud. La racine a une profondeur de référence arbitraire p définie par l'utilisateur. Les enfants auront une profondeur p + 1. Ici on a défini la profondeur de la racine à 0.
    </dd>
  </dl>




  <div class="row justify-content-center" id="figure03">
    <figure class="figure">
      <img src="media/quadtree.svg" class="figure-img img-fluid rounded" alt="" title="" width="800" />
      <figcaption class="figure-caption text-center">Figure 3 : Exemple d'un quadtree. Les feuilles portent les points. Notez qu'une branche ne peut porter<br /> que des branches ou des feuilles mais jamais directement des points.
        Chaque noeud peut porter jusqu'à quatre enfants maximum. </figcaption>
    </figure>
  </div>

  <p>
    La <a href="#figure3"> figure 3</a> montre un exemple de quatree où les points sont répartis sur des feuilles. Ces points sont ceux qui existent dans notre espace bidimensionnel et que nous avons organisés suivant cette étrange structure, au lieu
    de les garder sous forme de liste. Voyons maintenant comment construire un quatree comme celui-ci, et comment nous passons de notre espace bidimensionnel à cet <i>arbre</i>. Nous verrons également pourquoi nous distinguons les noeuds en branches
    et en feuilles.
  </p>

  <p>

  </p>


  <h2>Construction</h2>

  <p>
    Nous allons voir pas à pas, à la main, comment nous pouvons construire une structure de données quadtree à partir de nos points. Nous allons insister ici sur les principes de construction, plutôt que sur les détails de l'implémentation.
    L'objectif est d'abord d'obtenir un pseudo-code, les détails de l'algorithme sont discutés dans la partie <a href="implementation">implémentation</a>.
  </p>


  <h3>Initialisation de l'arbre</h3>
  <p>
    Nous allons commencer par définir la racine de notre quadtree, le premier noeud. La racine n'a pas de noeud parent par définition et c'est une feuille. A présent il faut faire la connexion entre notre arbre et
    l'espace géometrique : <strong>chaque noeud aura la responsabilité d'une région de l'espace. La région de la racine sera
      l'intégralité de notre espace</strong>. Elle sera
    responsable de tout ce
    qu'il se trouvera à l'intérieur. C'est ce que l'on peut voir sur la <a href="#figure04">figure 4a</a>, où la racine a la charge de tout le rectangle noir. Notre arbre est à présent initialisé.
  </p>

  <h3>Insérer des points</h3>

  <p>
    Nous allons insérer nos points un à un dans l'arbre. Pour chaque point allons interroger la racine de l'arbre :
  <ul style="list-style-type: '&mdash; '">
    <li>
      Est-ce que ce point se trouve dans ta région ?
    </li>
    <li>
      Bien sûr, par définition, tous les points se trouvent dans ma région !
    </li>
  </ul>
  En effet, la racine recouvre tout l'espace disponible. Le point est donc
  attaché à la racine. Nous allons continuer ainsi jusqu'à ce que le noeud racine porte quatre points, comme nous pouvons le voir sur les images <i>b)</i> à <i>e)</i> de la <a href="#figure04">figure 4</a>.
  </p>

  <div class="row justify-content-center" id="figure04">
    <figure class="figure">
      <img src="media/construction.svg" class="figure-img img-fluid rounded" alt="" title="" width="1000" />
      <figcaption class="figure-caption text-center">Figure 4 : Etapes de construction d'un quadtree par insertions successives de points. A l'étape f) la feuille originale porte 5 enfants.<br /> Ayant dépassé sa capacité de 4, elle se transforme en
        branche et pousse les points sur leurs feuilles respectives. <br />Le prochain point sera porté par l'une des feuilles de profondeur 1 et le processus se répètera.</figcaption>
    </figure>
  </div>

  <h3>Division</h3>

  <p>
    Le noeud racine porte à présent 4 enfants et nous insérons un nouveau point de notre collection. La feuille se retrouve à présent en surcapacité, elle a un point de trop : elle se transforme en branche. D'après notre définition, une branche ne
    peut avoir pour enfant que d'autres noeuds. Elle divise donc la région dont elle a la responsabilité en quatre sous-régions égales. Ces sous-régions sont chacune mises sous la responsabilité de nouveaux enfants, des feuilles. Chaque feuille prend
    la charge des points qui se trouvent dans sa région. Chaque point, originellement porté par la branche, se trouve alors poussé sur sa feuille et la structure est de nouveau à l'équilibre. Sur la <a href="figure04">figure 4f</a> on peut voir que 3
    feuilles ont poussé sur l'arbre. Elles contiennent les 5 points insérés. Chacune d'entre elle porte les points qui se trouvent dans la région dont elle est responsable. Enfin, la racine est à présent une branche et elle n'a pour enfant que des
    feuilles.
  </p>

  <p>
    Afin de couvrir l'intégralité du processus de division, il nous reste à discuter de deux cas possibles à la prochaine insertion. Supposons que nous voudrions insérer un point dans le quadrant nord-est de notre arbre. Demandons à la racine :
    <ul style="list-style-type: '&mdash; '">
      <li>
        Est-ce que ce point se trouve dans ta région ?
      </li>
      <li>
        Bien sûr, par définition, tous les points se trouvent dans ma région ! Cela dit, celui-ci se trouve peut-être dans la région de l'un de mes enfants, c'est donc à lui que revient la responsabilité de s'en occuper. Moi je suis une branche, je ne m'occupe plus des points, ce n'est plus mon problème.
      </li>
    </ul>
  </p>


  <h2 id="implementation">Implémentation</h2>

  <h2>Interroger le quadtree</h2>

  <div id="demo01">

    <h4>Insertion</h4>

    <div class="radioContainer">
      <input type="radio" id="normal" name="insertionModeGroup" value="point" checked="checked">
      <label for="point"><acronym title="Insère un unique point à chaque clic">Point</acronym></label>

      <input type="radio" id="gaussian" name="insertionModeGroup" value="gaussian">
      <label for="gaussian"><acronym title="Insère un nuage gaussien de points à chaque clic">Nuage de points</acronym></label>

      <label for="nbPointsGaussian">Nombre de points à insérer</label>
      <input type="range" id="nbPointsGaussian" name="nbPointsGaussian" value="100" min="10" max="250" disabled="">
      <output id="nbPointsGaussianValue"></output>
    </div>

    <h4>Inspection</h4>
    <div class="slideContainer">
      <label for="sliderProbeSize">Taille zone d'inspection</label>
      <input type="range" min="10" max="200" value="100" id="sliderProbeSize" name="sliderProbeSize">
    </div>

    <h4>Infos</h4>
    <div class="infos">
      <div>
        <label for="nbBranch">Nombre total de branches : </label>
        <span id="nbBranch" name="nbBranch"></span>
      </div>

      <div>
        <label for="nbLeaf">Nombre total de feuilles : </label>
        <span id="nbLeaf" name="nbLeaf"></span>
      </div>

      <div>
        <label for="nbPointsTotal">Nombre total de points : </label>
        <span id="nbPointsTotal" name="nbPointsTotal">0</span> points
      </div>

      <div id="groupNbPoitnsEvaluated">
        <label for="nbPoitnsEvaluated"><b>Points candidats (% Total)</b> : </label>
        <span id="nbPoitnsEvaluated" name="nbPoitnsEvaluated"></span>
      </div>

      <div id="groupNbPoitnsSelected">
        <label for="nbPoitnsSelected"><b>Points inclus dans la zone d'inspection (% Total) : </b></label>
        <span id="nbPoitnsSelected" name="nbPoitnsSelected"></span>
      </div>

    </div>

    <div class="resetButtonContainer">
      <!-- <input type="button" value="reset"> -->
      <button type="button" class="btn btn-primary btn-sm" id="resetButton">Réinitialiser</button>
      <input id="switch-demo01" type="checkbox" data-toggle="toggle" checked data-on="En cours" data-off="En Pause" data-onstyle="success" data-offstyle="warning" data-size="sm" class="switch-demo">
    </div>

    <div id="canvas-demo01-insert-querry" class="myCanvas">

    </div>


  </div>



  <h2>Notion de profondeur</h2>

  <h4>Insertion</h4>

  <div id="demo02">
    <div id="radioContainer-demo02">

      <input type="radio" id="normal-demo02" name="insertionModeGroup-demo02" value="point" checked="checked">
      <label for="point"><acronym title="Insère un unique point à chaque clic">Point</acronym></label>

      <input type="radio" id="gaussian-demo02" name="insertionModeGroup-demo02" value="gaussian">
      <label for="gaussian"><acronym title="Insère un nuage gaussien de points à chaque clic">Nuage de points</acronym></label>

      <label for="nbPointsGaussian-demo02">Nombre de points à insérer</label>
      <input type="range" id="nbPointsGaussian-demo02" name="nbPointsGaussian-demo02" value="100" min="10" max="250" disabled="">
      <output id="nbPointsGaussianValue-demo02"></output>
    </div>

    <h4>Infos</h4>
    <div class="highlightContainer">
      <div name="depth_current"></div>
      <label for="depth_current" <acronym title="Profondeur du noeud sous la souris">Profondeur </label>
      <div name="depth_max"></div>
      <label for="depth_max" <acronym title="Profondeur maximale observée dans le quadtree">Profondeur maximale </label>
    </div>
    <div class="resetButtonContainer_demo02">
      <!-- <input type="button" value="reset"> -->
      <button type="button" class="btn btn-primary btn-sm" id="resetButton-demo02" disabled>Réinitialiser</button>
      <input id="switch-demo02" type="checkbox" data-toggle="toggle" data-on="En cours" data-off="En Pause" data-onstyle="success" data-offstyle="warning" data-size="sm" class="switch-demo">
    </div>

    <div id="canvas-demo02-depth" class="myCanvas">

    </div>

  </div>


  <h2>Attacher des données aux feuilles</h2>

  <h2>Utilisation d'un quadTree pour la détection de collisions</h2>

  <div id="canvas-demo03-collisions">

  </div>

  <h2>Sources : aller plus loin</h2>

</body>


<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

<script src="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/js/bootstrap4-toggle.min.js"></script>



<!-- TODO: faire import plus propre -->
<script src="js/quadTree.js"></script>
<script src="js/pedagogic_extension.js"></script>
<script src="js/api_render.js"></script>

<script src="js/demo01/ui_app01.js"></script>
<script src="js/demo01/app01.js"></script>

<script src="js/demo02/app02.js"></script>
<script src="js/demo02/ui_app02.js"></script>

<!-- <script src="js/demo03/ui_app03.js"></script>
<script src="js/demo03/app03.js"></script> -->

<script src="js/main.js"></script>


</html>
