<!DOCTYPE html>
<html lang="fr">

<head>
  <script src="js/lib/p5.js"></script>

  <meta charset="utf-8">

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">

  <link href="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/css/bootstrap4-toggle.min.css" rel="stylesheet">

  <!-- code snippet -->
  <link href="css/prism.css" rel="stylesheet" />
  <link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body>

  <h1>Quadtree</h1>

  <h2>Introduction</h2>

  <h3>Ce que nous allons aborder et ce dont nous ne parlerons pas</h3>

  <p>
    Les <a href="https://fr.wikipedia.org/wiki/Quadtree">quadtree</a> sont des structures de données qui peuvent être très utiles pour résoudre certains types de problèmes. Précisons d'emblée que cet article ne cherche pas à couvrir de manière
    exhaustive tous les usages et les contextes d'application des quadtrees. Nous nous nous restreindrons à son usage principal, celui du partitionnement d'un espace à deux dimensions.
    Au lieu de partir de considérations théoriques et générales nous allons plutôt aborder les quadtrees d'un point de vue pratique en tachant de répondre à ces questions : à quoi un quadtree peut-il servir ? Qu'est ce qu'un quadtree ? Comment le
    construire ? Comment l'interroger ? Comment s'en servir ?
    Nous allons donc commencer par proposer une définition d'un quadtree. Puis, à l'aide de notre définition, nous allons le construire et l'implémenter (en JavaScript ici mais facilement
    reproductible dans n'importe quel langage de programmation). Nous allons ensuite voir comment nous en servir pour manipuler ou interroger efficacement nos données.
    Finalement, nous allons l'utiliser dans un cas pratique où le quadtree fait largement ses preuves : la détection de collisions.

  </p>



  <h3>Dans quel cas les quadtrees sont-ils utiles?</h3>

  <p>
    Avant même de définir ce qu'est un quadtree, il paraît intéressant de voir à quoi peut-il peut servir et à quels types de questions il permet de répondre.
  </p>

  <p>
    Pour nous servir des quadtrees nous avons besoin d'un espace à deux dimensions (un écran, un sous-espace d'un espace plus grand, une scène où se déplacent des objets, une image etc...)
    et que cet espace contienne des points. Ces points peuvent représenter n'importe quoi, la seule chose qui importe c'est que les <strong>coordonnées de ces points représentent
      quelque-chose</strong>. Par exemple ces points pourraient représenter des particules, les pixels d'une image, les villes d'un pays etc... Les coordonnées ont du sens : deux particules veulent savoir si elles sont en contact ou non, le sens
    d'une image est
    contenu dans les positions relatives de ses pixels, les villes ne sont pas n'importe où !
    Par exemple, un sytème de coordonées peut être défini de sorte à ce qu'un axe représente la distance vers l'avant par rapport à
    l'origine choisie,
    et l'autre celle vers la gauche. La particule pourrait être représentée dans cet espace par un couple de deux valeurs mesurant la position du centre géometrique de la particule. Mais la distance mesurée entre deux points dans un système de
    coordonnées ne se restreint pas
    à
    la mesure d'une distance <i>strictement spatiale</i> : on pourrait tout aussi bien définir un espace avec un axe <i>proportion de voyelles</i> et y représenter des chaînes de caractère. Cet espace permettrait de définir une mesure de proximité
    entre des mots ou
    des phrases par exemple. On pourrait également représenter des points dans un espace où une dimension mesure la position et l'autre le temps etc.
  </p>

  <p>
    Mais prenons l'exemple classique d'un espace à deux dimensions peuplé d'objets, représenté chacun par un point. Pour des raisons pratiques nous appelerons <strong>point</strong> la représentation de l'objet dans notre espace par ses coordonnées.

  <div class="row justify-content-center">
    <figure class="figure">
      <img src="media/figure01.png" class="figure-img img-fluid rounded" alt="un espace bidimensionnel peuplé d'objets représentés par des points" title="un espace bidimensionnel peuplé d'objets représentés par des points" width="452" height="328" />
      <figcaption class="figure-caption text-center">Figure 1 : un espace bidimensionnel peuplé d'objets</figcaption>
    </figure>
  </div>

  Supposons que nous voulions interroger les propriétés de voisinage de ces objets. Par exemple, nous aimerions savoir combien de voisins possède chaque objet dans une zone définie autour de celui-ci? Ces voisins possèdent-ils des propriétés
  analogues ou différentes? Quel
  est le voisin le plus proche de chaque point ? Ou non finalement, qui sont les trois voisins les plus proches ? Ou, tout simplement, combien y'a-t-il d'objets présents dans une zone définie autour d'un point quelconque? La liste n'est pas
  exhaustive, mais toutes ces questions ont ceci en commun :
  elles trouvent leurs réponses dans les mesures des distances entre les points. Elles ont un caractère <i>géometrique</i>.
  </p>

  <div class="row justify-content-center" id="figure02">
    <figure class="figure">
      <img src="media/figure02.png" class="figure-img img-fluid rounded" alt="un espace bidimensionnel peuplé d'objets représentés par des points. Un cercle rouge défini un sous-espace"
        title="Combien de points se trouvent dans le sous-espace défini par le cercle rouge?" width="452" height="328" />
      <figcaption class="figure-caption text-center">Figure 2 : combien de points se trouvent dans <br />le sous-espace défini par le cercle rouge? </figcaption>
    </figure>
  </div>
  <p>
    Reprenons l'une des questions précédentes sur le voisinage : quels sont les objets présents dans une zone bien délimitée de mon espace? Comme nous pouvons le voir sur la <a href="#figure02">figure 2</a>, nous retrouvons notre ensemble d'objets
    dans
    un espace
    bidimensionnel, où chaque objet est repéré par ses coordonnées et représenté par un point blanc. Nous voulons savoir quels sont les objets présents à l'interieur du cercle rouge. Nous voulons, par exemple, sélectionner ces points et leur
    appliquer un traitement particulier. Comment allons-nous nous y prendre? La solution <i>naïve</i> consisterait à parcourir tous les points et à tester s'ils se trouvent à l'intérieur du domaine délimité par le cercle rouge. Cette
    solution demanderait un temps d'execution propotionnel au nombre de points à traiter, on dit qu'elle est <code>O(n)</code>, où <code>n</code> représente le nombre de
    points à parcourir. La <a href="https://fr.wikipedia.org/wiki/Analyse_de_la_complexit%C3%A9_des_algorithmes">complexité</a> d'un algorithme, ou d'une fonction, est une mesure de la quantité de ressources (temps ou mémoire) nécessaire à son
    éxecution :<code>O(n)</code> signifie que les ressources demandées sont proportionnelles à n. Si nous avons un million de points et que notre cercle rouge ne contient que deux points alors nous devrons faire un million d'opérations pour n'en
    sélectionner que deux !
  </p>
  <p>
    Et ce n'est pas tout. Là encore c'est une complexité tolérable. Supposons que nous cherchions à savoir quel est le point le plus proche de chaque point. Pour y arriver nous devrions, pour chaque point, regarder les n - 1 points restants, mesurer
    la distance entre les deux et garder le point pour lequel la distance est la plus courte. Et nous devrions répeter cette opération n fois, pour chaque point. Cela veut dire qu'il faudrait n * (n -1) opérations pour obtenir notre résultat. Il
    serait possible de réduire le coût en ne considérant les paires qu'une fois. Comme chaque paire compte double dans le décompte précédent il est encore possible de diviser par 2 le nombre d'opérations, pour le ramener à n(n-1)/2. Néanmoins, on
    voit toujours apparaitre un facteur n*n. La complexité de notre calcul est donc ici en <code>0(n2)</code>. Si nous avions un million de points il faudrait faire un billion (1 000 000 000 000) d'opérations pour obtenir notre résultat ! Ce n'est
    pas sérieux. La complexité
    <code>0(n2)</code> est une complexité qu'il faut éviter à chaque fois que cela est possible, sa mise à l'échelle avec la taille de l'échantillon est trop vertigineuse, et elle indique souvent qu'il y'a <i>un autre chemin</i>.
  </p>

  <p>
    Pou réduire cette complexité l'une des premières choses à faire est de repenser notre structure de données, celle dans laquelle sont rangés nos points. De nombreuses structures de données existent
    et permettent d'organiser les données de manière à faciliter leur traitement. Chaque structure de données possède des avantages et des inconvénients vis à vis du traitement que l'on
    souhaite réaliser. Réduire la complexité et augmenter les performances d'un programme en charge de la réalisation d'un traitement de données passe d'abord par le choix d'une structure de données adaptée.
  </p>

  <p>
    Pour le moment, nos objets sont stockés sous la forme d'un tableau, ou d'une liste, comme il est courant de le faire. Nous devons parcourir le tableau de points et tester pour chacun d'entre eux s'il est à l'interieur de la zone circulaire rouge.
    Mais c'est embêtant, car nous devons tester tous les points, même ceux à l'autre bout de l'espace, loin, si loin de notre zone. Il doit y avoir une meilleure solution. Pouvons-nous mieux faire? Oui, nous pouvons mieux faire ! Et pour mieux faire
    nous avons besoin d'une
    structure de données adaptée à ce genre de problème : le quadtree.
  </p>


  <p>
    Le quadtree est une structure de données où l'on va ranger les points dans des petites boîtes. Ces boîtes seront définies en appliquant une décomposition de l'espace en quatre sous-espaces égaux de manière <a
      href="https://fr.wikipedia.org/wiki/R%C3%A9cursivit%C3%A9">récursive</a>. L'espace sera ainsi divisé <i>sur lui même</i> jusqu'à ce qu'aucune boite ne contienne plus de quatre points. C'est son aspect récursif qui
    lui donne la forme d'un arbre (<i>tree</i>). Le <i>quad</i> vient lui du fait qu'on découpe l'espace toujours en quatre. Même si cette définition parait pour le moment très insatisfaisante, nous allons voir que le but du quadtree est d'organiser
    autrement les points (sans toucher à leur coordonnées bien entendu) pour optimiser drastiquement le coût de nos investigations. Pour reprendre la
    question que nous nous posons, à savoir combien de points sont compris dans le cercle rouge, le problème de la solution naïve vient du fait qu'elle nous force à interroger tout l'espace (et donc tous les points !). Le quadtree va nous permettre
    d'affiner
    notre requête et d'interroger une partie de l'espace. Mais inutile de bavarder plus longtemps, et rentrons dans le vif du sujet.
  </p>


  <dl>
    <dt>
      Ce qu'il faut retenir
    </dt>
    <dd>
      <p class="togo">
        Les quadtrees sont des structures de données qui permettent de traiter efficacement des données existantes dans un espace bidimensionnel. L'utilisation d'un quadtree pour réaliser ces
        traitements offre un gain de performance considérable par rapport à l'approche <i>naïve</i>. Ce bénéfice provient du fait que le quadtree partitionne l'espace de manière récursive pour ré-organiser les données.
      </p>
    </dd>
  </dl>


  <h2>Définitions</h2>

  <p>
    Mettons nous d'accord sur le vocabulaire et quelques définitions afin de ne laisser place à aucune ambiguité. En effet, il n'y a pas de définition standard du quadtree, plusieurs implémentations existent et ont chacune leur intérêt et leur
    défaut. Il existe plusieurs stratégies pour le construire et la structure possède plusieurs paramètres (capacité, profondeur...) ajustables par l'utilisateur en fonction de ses besoins. Néanmoins, tous les quadtrees partagent une définition
    commune : ce sont des structures de type arbre (récursives) dans laquelle chaque noeud à quatre enfants. La suite de cet article s'appuiera sur l'ensemble des défintions suivantes.
  </p>

  <p>

  </p>

  <dl>
    <dt>
      Noeud
    </dt>
    <dd>
      le noeud est le composant fondamental du quadtree. Le quadtree est une association de noeuds, et il commence toujours par un noeud initial, un noeud racine. Les points insérés dans un quadtree finissent toujours attachés à un et un seul noeud.
      Un noeud peut avoir jusqu'à 4 enfants. Le quadtree possède deux types de noeuds : les branches et les feuilles.
    </dd>
    <dt>
      Branche
    </dt>
    <dd>
      un noeud qui ne peut porter (avoir pour enfant direct) que des noeuds, branche ou feuille, mais jamais de points.
    </dd>
    <dt>
      Feuille
    </dt>
    <dd>
      un noeud qui ne peut porter que des points, mais jamais d'autres noeuds. Lorsque la capacité de la feuille est excédée elle se transforme en branche.
    </dd>
    <dt>
      Enfant
    </dt>
    <dd>
      un enfant est un élément du quadtree qui est porté par son noeud parent. Un enfant peut-être un noeud ou un point. Seul un noeud peut être parent. Par exemple, sur la <a href="#figure3"> figure 3</a>, la feuille <i>b</i> est l'enfant de la
      branche <i>a</i>. On dit que <i>a</i> porte <i>b</i>. De même, le point <i>c</i> est l'enfant de la feuille <i>b</i>, mais <i>c</i> n'est pas l'enfant de <i>a</i>, car <i>a</i> ne porte pas directement <i>b</i>.
    </dd>
    <dt>
      Capacité
    </dt>
    <dd>
      le nombre maximal d'enfants qu'une feuille peut porter. Par défaut la capacité est de quatre. Ainsi on conserve une certaine homogénéité dans notre définition : une branche a la même capacité qu'une feuille. Si la capacité d'une branche est par
      définition de 4 (<i>quad</i>tree) la capacité d'une feuille pourrait être supérieure ou inférieure (chaque feuille ne pourrait porter qu'un point par exemple).
    </dd>
    <dt>
      Profondeur
    </dt>
    <dd>
      le niveau auquel se trouve un noeud. La racine a une profondeur de référence arbitraire p définie par l'utilisateur. Les enfants auront une profondeur p + 1. Ici on a défini la profondeur de la racine à 0.
    </dd>
  </dl>


  <div class="row justify-content-center" id="figure03">
    <figure class="figure">
      <img src="media/quadtree.svg" class="figure-img img-fluid rounded" alt="" title="" width="700" />
      <figcaption class="figure-caption text-center">Figure 3 : Exemple d'un quadtree. Les feuilles portent les points. Notez qu'une branche ne peut porter<br /> que des branches ou des feuilles mais jamais directement des points.
        Chaque noeud peut porter jusqu'à quatre enfants maximum. </figcaption>
    </figure>
  </div>

  <p>
    La <a href="#figure3"> figure 3</a> montre un exemple de quatree où les points sont répartis sur des feuilles. Ces points sont ceux qui existent dans notre espace bidimensionnel et que nous avons organisés suivant cette étrange structure, au lieu
    de les garder sous forme de liste. Voyons maintenant comment construire un quatree comme celui-ci, et comment nous passons de notre espace bidimensionnel à cet <i>arbre</i>. Nous verrons également pourquoi nous distinguons les noeuds en branches
    et en feuilles.
  </p>

  <p>

  </p>


  <h2>Construction</h2>

  <p>
    Nous allons voir pas à pas, à la main, comment nous pouvons construire une structure de données quadtree à partir de nos points. Nous allons insister ici sur les principes de construction, plutôt que sur les détails de l'implémentation.
    L'objectif est d'abord d'obtenir un pseudo-code, les détails de l'algorithme sont discutés dans la partie <a href="implementation">implémentation</a>.
  </p>


  <h3>Le point de départ de l'arbre : la racine</h3>
  <p>
    Nous allons commencer par définir la racine de notre quadtree, le premier noeud. La racine n'a pas de noeud parent par définition et c'est une feuille. A présent il faut faire la connexion entre notre arbre et
    l'espace géometrique : <strong>chaque noeud aura la responsabilité d'une région de l'espace. La racine a
      l'intégralité de l'espace sous sa responsabilité</strong>. Elle sera
    responsable de tout ce
    qu'il se trouve à l'intérieur. C'est ce que l'on peut voir sur la <a href="#figure04">figure 4a</a>, où la racine a la charge de tout le rectangle noir.
  </p>

  <h3>Insérer des points dans le quadtree</h3>

  <p>
    Nous allons insérer nos points un à un dans l'arbre. Pour chaque point allons interroger la racine de l'arbre :
  <ul style="list-style-type: '&mdash; '">
    <li>
      Est-ce que ce point se trouve dans ta région ?
    </li>
    <li>
      Bien sûr, par définition, tous les points se trouvent dans ma région !
    </li>
  </ul>
  En effet, la racine recouvre tout l'espace disponible. Le point est donc
  attaché à la racine. Nous allons continuer ainsi jusqu'à ce que le noeud racine porte quatre points, comme nous pouvons le voir sur les images <i>b)</i> à <i>e)</i> de la <a href="#figure04">figure 4</a>.
  </p>

  <div class="row justify-content-center" id="figure04">
    <figure class="figure">
      <img src="media/construction.svg" class="figure-img img-fluid rounded" alt="" title="" width="1000" />
      <figcaption class="figure-caption text-center">Figure 4 : Etapes de construction d'un quadtree par insertions successives de points. A l'étape f) la feuille originale porte 5 enfants.<br /> Ayant dépassé sa capacité de 4, elle se transforme en
        branche et pousse les points sur leurs feuilles respectives. <br />Le prochain point sera porté par l'une des feuilles de profondeur 1 et le processus se répètera.</figcaption>
    </figure>
  </div>

  <h3>Mécanisme de division</h3>

  <p>
    Le noeud racine porte à présent 4 enfants et nous insérons un nouveau point de notre collection. La feuille se retrouve à présent en surcapacité, elle a un point de trop : elle se transforme en branche. D'après notre définition, une branche ne
    peut avoir pour enfant que d'autres noeuds. Elle divise donc la région dont elle a la responsabilité en trois sous-régions égales (la dernière sous-région ne contenant aucun point n'est pas définie). Ces sous-régions sont chacune mises sous la responsabilité de nouveaux enfants, des feuilles. Chaque feuille prend
    la charge des points qui se trouvent dans sa région. Chaque point, originellement porté par la branche, se trouve alors poussé sur sa feuille et la structure est de nouveau à l'équilibre. Sur la <a href="figure04">figure 4f</a> on peut voir que 3
    feuilles ont poussé sur l'arbre. Elles contiennent les 5 points insérés. Chacune d'entre elle porte les points qui se trouvent dans la région dont elle est responsable. Enfin, la racine est à présent une branche et elle n'a pour enfant que des
    feuilles.
  </p>

  <p>
    Afin de couvrir l'intégralité du processus de division, il nous reste à discuter de deux cas possibles à la prochaine insertion. Supposons que nous voudrions insérer un point dans le quadrant sud-ouest(2) de notre arbre. Demandons à la racine :
  <ul style="list-style-type: '&mdash; '">
    <li>
      Est-ce que ce point se trouve dans ta région ?
    </li>
    <li>
      Bien sûr, par définition, tous les points se trouvent dans ma région ! Cela dit, celui-ci se trouve aussi dans la région de l'un de mes enfants, c'est donc à lui que revient la responsabilité de s'en occuper. Moi je suis une branche, je ne
      m'occupe plus des points, ce n'est plus mon problème. Demandez donc à ma feuille 2.
    </li>
  </ul>
  Nous allons demander à la feuille 2:
  <ul style="list-style-type: '&mdash; '">
    <li>
      Est-ce que ce point se trouve dans ta région ?
    </li>
    <li>
      Oui, cette région m'appartient désormais, donnez moi votre point, je m'en charge.
    </li>
  </ul>

  Et nous pouvons ajouter un point à la feuille 2, comme montré sur la <a href="#figure05">figure 5g</a>.
  </p>
  <div class="row justify-content-center" id="figure05">
    <figure class="figure">
      <img src="media/construction_suite.svg" class="figure-img img-fluid rounded" alt="" title="" width="800" />
      <figcaption class="figure-caption text-center">Figure 5 : Deux points (en rouge) sont insérés sur l'arbre : la branche délègue la responsabilité à son enfant s'il existe déjà g), <br />ou met à disposition une nouvelle feuille s'il n'existe pas
        encore h)</figcaption>
    </figure>
  </div>
  <p>
    A présent, regardons un deuxième cas de figure, supposons que nous voudrions insérer un point dans la quadrant sud-est(3) de notre arbre. Comme d'habitude, demandons à la racine:
  <ul style="list-style-type: '&mdash; '">
    <li>
      Est-ce que ce point se trouve dans ta région ?
    </li>
    <li>
      Bien sûr, par définition, tous les points se trouvent dans ma région ! Cela dit, celui-ci se trouve dans une sous-région qui n'est sous la responsabilité d'aucun de mes enfants. Cette région est encore sous ma responsabilité mais comme je l'ai
      dit, je ne m'occupe plus personnellement des points, je suis une branche ! Voici, je vais faire pousser une feuille et celle-ci s'en chargera.
    </li>
  </ul>
  Sur la <a href="#figure05">figure 5h</a> une feuille 3 a poussé. Nous pouvons aller lui demander, comme précédemment, si elle veut de notre point, et comme celui-ci se trouve dans la région dont elle a la responsabilité elle le portera.
  </p>

  <p>
    En guise d'exercice, vous pouvez essayer de continuer de construire cet arbre avec des points choisis arbitrairement, en appliquant ces règles. Vous verrez les feuilles se transformer en branches, les branches créer des feuilles, et vos points se
    répartir d'une feuille à l'autre au gré de la construction.
  </p>

  <p>
    <a href="#demo01">Une démo interactive</a> de création et d'inspection du quadtree est disponbile dans l'article. Vous pouvez y expérimentez la construction d'un quadtree point par point, par un simple clic sur le canvas. Le nombre de branches et
    de feuilles de l'arbre sont affichés pour vous permettre de savoir si vous avez bien compris les mécanismes de division.
  </p>


  <h3>Pseudo-code</h3>

  <p>
    Maintenant que nous avons bien défini le comportement de notre arbre et de ses composants, nous pouvons écrire un pseudo-code de l'algorithme de construction de notre arbre. La construction n'est rien d'autre qu'une succession d'insertion
    de point au niveau de
    la racine. Voici à quoi le pseudo-code de la fonction d'insertion pourrait ressembler:
  </p>

  <div class="row justify-content-center" id="pseudocode">
    <pre>
      <span class="variable">racine</span>.<span class="function">inserer</span>(point){

      <span class="if-else">if</span> <span class="statement">le point n'est pas dans mon domaine</span>
        quitter;

      <span class="if-else">if</span> <span class="statement">le point est dans le domaine d'un de mes enfants</span>
        <span class="variable">enfant</span>.<span class="function">inserer</span>(point);
      <span class="if-else">else</span>

        <span class="if-else">if</span> <span class="statement">je suis une branche</span>
          creer un nouvel enfant feuille
          <span class="variable">enfant</span>.<span class="function">inserer</span>(point)
        <span class="if-else">else</span>
          <span class="function">porter</span>(point)

        <span class="if-else">if</span> <span class="statement">j'ai plus de 4 enfants</span>
          se transformer en <span class="variable">branche</span>
          creer autant d'enfants feuille que nécessaire : <span class="variable">mes_feuilles</span>
          recuperer tous mes points : <span class="variable">mes_points</span>
          <span class="variable">mes_feuilles</span>.<span class="function">inserer</span>(<span class="variable">mes_points</span>)
      }
    </pre>
  </div>



  <h2 id="implementation">Implémentation</h2>

  <p>
    Cette partie portera sur l'implémentation (en javascript) d'un quadtree. Nous allons implémenter le composant <i>noeud</i> et la fonctionalité d'insertion. Tous les détails de l'implémentation ne sont pas mentionnés, notamment le code concernant
    les fonctions auxiliaires. Il est cependant accessible dans le <a href="#">code-source</a>.
  </p>


  <h3>Implémentation du noeud : <code class="language-javascript">class Node</code> </h3>

  <p>
    Un noeud est la structure fondamentale de l'arbre. Elle possède une région, un espace géometrique, dont elle a la responsabilité. Cette région est rectangulaire et est entièrement définie par les variables <code
      class="language-javascript">x,y,w,h</code> où <code class="language-javascript">(x,y)</code> représentent <strong>le centre</strong> du rectangle et <code class="language-javascript">(w,h)</code> sa <strong>demi-largeur et
      demi-longueur</strong>.

  </p>
  <p>
    Un noeud a en pratique toujours 4 enfants, donc <code class="language-javascript">children</code> est un tableau de 4 éléments, un pour chaque enfant. Les enfants sont initialisés sous la forme d'un tableau vide. Chaque indice du tableau
    <code class="language-javascript">children</code> correspond à une sous-région de l'espace détenu par le noeud, comme représenté sur <a href="figure04">la figure 4</a>. On peut voir que l'espace est virtuellement pré-découpé en 4 sous-regions
    par des traits pointillés blancs. L'indice, allant de 0 à 3 sert d'identité à chaque sous-région. Ainsi <code class="language-javascript">children[0]</code> retourne soit l'ensemble des points contenus dans la sous-région <code
      class="language-javascript">0</code> du noeud si le noeud est une feuille, soit une feuille si le noeud est une branche.
  </p>

  <p>
    Un attribut <code class="language-javascript">capacity</code> définit la capacité de chaque feuille, égale par convention au nombre d'enfants max, soit 4. Un noeud nouvellement crée est par défaut une feuille, et sa profondeur est initialisée à
    partir de celle de son parent, où à 0 dans le cas de la racine.
  </p>


  <div class="row justify-content-center" id="snpippet-node">
    <pre>
    <code class="language-javascript">
      class Node {

        constructor(x, y, w, h, depth) {

          //Region : (x,y) position du centre, (w,h) demi largeur/hauteur
          this.x = x;
          this.y = y;
          this.w = w;
          this.h = h;

          //                0   1   2   3
          this.children = [ [], [], [], [] ];

          this.isBranch = false;

          //Capacité
          this.capacity = this.children.length;

          //taille
          this.length = 1;

          //profondeur
          if (!depth)
            this.depth = 0;
          else
            this.depth = depth;
        }
        //Methodes a implementer
        insert(point){}
        query(area){}
      }
    </code>
  </pre>

  </div>

  Pour initialiser la racine il suffira de l'instancier dans notre programme avec <code class="language-javascript">let racine = new Node(x,y,w,h)</code>, où x,y,w,h sont les données géometriques de l'espace où se trouvent vos points, typiquement les
  propriétés de votre écran.

  <h2 id="implementation">Implémentation de l'insertion : <code class="language-javascript">insert(point)</code></h2>

  <p>
    Maintenant que nous avons initialisé notre arbre il faut pouvoir y insérer nos points. C'est le but de la méthode <code class="language-javascript">insert(point)</code>. Tout d'abord nous vérifions si le point est contenu dans la région contrôlée
    par le noeud. Si ce n'est pas le cas alors on ne l'insert pas, tout simplement. Un point généré en dehors de votre écran n'intéresse pas le quadtree.
  </p>
  <p>
    Si le noeud contient le point, la méthode <code class="language-javascript">index(point)</code> se charge de récupérer l'index de la sous-région dans laquelle il se trouve. Cet index, allant de 0 à 3 est celui représenté sur <a href="figure04">la
      figure 4</a>. Il permet d'accèder à l'enfant en charge du sous-espace. Nous pouvons ensuite interroger l'enfant <code class="language-javascript">children[index]</code>. L'instruction <code class="language-javascript">children[index] instanceof
      Node</code> est une syntaxe de la norme <a href="https://www.w3schools.com/js/js_es6.asp">ECMAScript 6</a>. Sous le capot aucun cast, JavaScript se contente de tester si <code class="language-javascript">children</code> possède, dans sa <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">chaîne de prototype</a>, une référence vers le prototype du constructeur <code class="language-javascript">Node</code>.

  <ul>
    <li>
      si l'enfant un noeud alors le noeud parent lui délegue le travail et la méthode <code class="language-javascript">insert(point)</code> est appelée récursivement sur l'enfant. Le travail est terminé pour le noeud parent.
    </li>
    <li>
      si l'enfant n'est pas un noeud, mais encore un tableau alors deux cas se présentent :
      <ul>
        <li>
          soit le noeud en cours est une branche qui n'a pas encore fait poussé de feuille dans cette sous-région. Dans ce cas on fait pointer l'enfant sur une nouvelle feuille : <code class="language-javascript">children[index] =
            getNewNode(index)</code>. Puis on lui demande de s'occuper du point. La méthode <code class="language-javascript">getNewNode(index)</code> prend en paramètre l'index de la sous-région sur laquelle il doit pointer et renvoie une feuille
          toute fraiche ayant la charge de cette sous-région. Mais, et si <code class="language-javascript">children[index]</code> contenait des points, alors nous pourrions les perdre dans cette opération, non? Non, car le noeud est une branche ! Et
          par définition, une branche ne porte jamais de points.
        </li>
        <li>
          soit c'est une feuille et dans ce cas il garde tout simplement le point.
        </li>
      </ul>
    </li>
  </ul>


  Il reste une dernière étape avant de terminer cette fonction. Il faut implémenter la transformation en branche d'une feuille lorsque celle-ci est en surcapacité. C'est le rôle de la dernière évaluation.

  </p>
  <div class="row justify-content-center" id="snpippet-node">
    <pre class="language-javascript line-numbers">
    <code class="language-javascript">
      insert(point) {

        if (!this.contains(point))
          return;

        let index = this.index(point);

        if (this.children[index] instanceof Node) {
          this.children[index].insert(point);
          return;
        } else {

          //Si c'est une branche alors il faut créer une nouvelle feuille et y insérer le point
          if (this.isBranch) {
            this.children[index] = this.getNewNode(index);
            this.children[index].insert(point);
            return;
          }

          //C'est une feuille, elle porte le point
          this.children[index].push(point);

          //Si la feuille a dépassé sa capacité elle se transforme en branche
          if (this.hasReachedMaxCapacity())
            this.branch();
        }
      }
    </code>
  </pre>
  </div>

  <p>
    Le code de la méthode <code class="language-javascript">branch()</code> est montré ci-dessous. Rappelons nous : lorsqu'une feuille porte plus de 4 points, elle est en sur-capacité et se change en branche. Elle doit alors instancier de nouvelles
    feuilles
    et pousser ses points dessus. A la fin, la branche ne doit avoir que des feuilles pour enfant.
  </p>

  <p>
    Nous parcourons alors tous les enfants de la feuille. Ces enfants, par définition, <strong>sont garantis d'être des tableaux de points</strong>. C'est pour cela que dans la boucle <code
      class="language-javascript">children.forEach((points,index))</code> la référence vers chaque enfant est nommée <code class="language-javascript">points</code>, et non child. Nous ne voulons pas instancier plus de feuilles que nécessaire, c'est
    pourquoi nous instancions une feuille que lorsqu'un enfant porte des points. Une fois l'enfant transformé en feuille, nous insérons les <code class="language-javascript">points</code> dedans. Finalement, nous n'oublions pas d'indiquer que notre
    noeud est à présent une branche : <code class="language-javascript">this.isBranch = true</code>.
  </p>

  <div class="row justify-content-center" id="snpippet-node">
    <pre class="language-javascript line-numbers">
    <code class="language-javascript">
      branch() {
        //Seule une feuille peut devenir une branche, ses enfants sont nécessairement des tableaux de points
        this.children.forEach((points, index) => {
          //Si un enfant contient des points, créer une feuille a la place...
          if (points.length !== 0) {
            this.children[index] = this.getNewNode(index);
            //...et y insérer les points
            for (let p of points)
              this.children[index].insert(p);
          }
        });

        this.isBranch = true;
      }
    </code>
  </pre>
  </div>


  <h2>Démo interactive</h2>

  <p>
    Ci-dessous vous trouverez une démo interactive de cette implémentation. Vous pouvez insérer des points par un simple click sur le canvas. Vous pouvez insérer point par point pour bien suivre l'évolution du nombre de branches et de feuilles, soit
    par nuages de points. Une zone d'inspection, qui suit le mouvement du curseur, est également à disposition pour inspecter le quadtree. Vous pouvez régler sa taille. Elle détecte les points contenus à l'intérieur du cercle. Le nombre de
    points candidats montre combien de points il a fallu interroger pour obtenir ce résulat. Vous pouvez observer qu'il est possible de selectionner les points à l'intérieur du cercle sont évaluer tous les points présents (sauf s'ils y sont tous bien
    sûr). Les lignes blanches marquent les frontières des neuds. Un noeud en surbrillance indique une feuille intérogée par la zone d'inspection. Nous verrons dans la prochaine partie comment inspecter et nous servir du quadtree. N'hésitez pas alors
    à revenir expérimenter avec cette démo.
  </p>


  <div class="row justify-content-center" id="demo01">


    <h4>Insertion</h4>
    <div class="radioContainer">
      <input type="radio" id="normal" name="insertionModeGroup" value="point" checked="checked">
      <label for="point"><acronym title="Insère un unique point à chaque clic">Point</acronym></label>

      <input type="radio" id="gaussian" name="insertionModeGroup" value="gaussian">
      <label for="gaussian"><acronym title="Insère un nuage gaussien de points à chaque clic">Nuage de points</acronym></label>

      <label for="nbPointsGaussian">Nombre de points à insérer</label>
      <input type="range" id="nbPointsGaussian" name="nbPointsGaussian" value="100" min="10" max="250" disabled="">
      <output id="nbPointsGaussianValue"></output>
    </div>

    <h4>Inspection</h4>
    <div class="slideContainer">
      <label for="sliderProbeSize">Taille zone d'inspection</label>
      <input type="range" min="10" max="200" value="100" id="sliderProbeSize" name="sliderProbeSize">
    </div>

    <h4>Infos</h4>
    <div class="infos">
      <div>
        <label for="nbBranch">Nombre de branches : </label>
        <span id="nbBranch" name="nbBranch"></span>
      </div>

      <div>
        <label for="nbLeaf">Nombre de feuilles : </label>
        <span id="nbLeaf" name="nbLeaf"></span>
      </div>

      <div>
        <label for="nbPointsTotal">Nombre de points : </label>
        <span id="nbPointsTotal" name="nbPointsTotal">0</span> points
      </div>

      <div id="groupNbPoitnsEvaluated">
        <label for="nbPoitnsEvaluated"><b>Points candidats (% Total)</b> : </label>
        <span id="nbPoitnsEvaluated" name="nbPoitnsEvaluated"></span>
      </div>

      <div id="groupNbPoitnsSelected">
        <label for="nbPoitnsSelected"><b>Points inclus dans la zone d'inspection (% Total) : </b></label>
        <span id="nbPoitnsSelected" name="nbPoitnsSelected"></span>
      </div>

    </div>

    <div class="resetButtonContainer">
      <!-- <input type="button" value="reset"> -->
      <button type="button" class="btn btn-primary btn-sm" id="resetButton">Réinitialiser</button>
      <input id="switch-demo01" type="checkbox" data-toggle="toggle" checked data-on="En cours" data-off="En Pause" data-onstyle="success" data-offstyle="warning" data-size="sm" class="switch-demo">
    </div>
    <div>Naviguer vers la démo: <a href="#demo01">1</a> - <a href="#demo02">2</a> - <a href="#demo03">3</a></div>
    <div id="canvas-demo01-insert-querry" class="myCanvas">

    </div>
  </div>

  <br />
  <p>
    Nous avons à présent construit notre quadtree. Notre structure de données est enfin prête. La partie intéressante peut commencer, nous allons à présent nous servir de notre quadtree pour obtenir des réponses aux questions que nous nous posions !
  </p>

  <h2>Se servir (enfin) du quadtree</h2>


  <p>
    La question que nous nous posions à la base était la suivante : quels sont les objets sur la <a href="#figure02">figure 2</a>, présents à l'interieur du cercle rouge ? Et nous voulions y répondre sans devoir interroger l'intégralité des points et
    écopper de la complexité <code>0(n)</code>. Pour cela nous avons ré-organisé nos données dans une structure quadtree. Comment récupérer les points que nous cherchons ?
  </p>

  <p>
    Nous devons définir notre zone d'inspection, notre cercle rouge, comme dans <a href="#demo01">la démo</a>. Dans ce cas ci la zone d'inspection est vraiment très simple: elle est définie par les coordonnées de son centre et par un rayon. Nous
    allons initialiser notre requête au quadtree en demandant à la racine si notre cercle recouvre, même partiellement, l'espace mis sous sa reponsabilité. Si c'est le cas, et si la racine a des noeuds enfants, alors le cercle doit nécessairement
    recouvrir au moins une des sous-régions à la charge de l'un de ses enfants. Récursivement nous allons donc interroger les enfants recouverts jusqu'à arriver sur les feuilles. Les feuilles sont les noeuds les plus profonds de l'arbre, il n'y a
    rien en dessous, mis à
    part nos points. Les enfants des feuilles sont les points que nous cherchons. Nous n'avons plus qu'à remonter tous les points contenus dans les feuilles recouvertes par notre cercle. Le pseudo-code est de la forme :
  </p>

  <div class="row justify-content-center" id="pseudocode">
    <pre>
      <span class="variable">racine</span>.<span class="function">query</span>(cercle_rouge){

      <span class="if-else">if !</span><span class="statement">cercle_rouge</span>.<span class="function">recouvre</span>(<span class="variable">racine.region</span>)
        quitter;

      Pour chaque <span class="variable">enfant</span>
        <span class="if-else">if</span> <span class="variable">enfant</span> est un noeud
          <span class="variable">enfant</span>.<span class="function">query</span>(cercle_rouge)
        <span class="if-else">else</span>
          Pour chaque <span class="variable">point</span> de <span class="variable">enfant</span>
            <span class="if-else">if</span> <span class="statement">cercle_rouge</span>.<span class="function">contient</span>(<span class="variable">point</span>)
              garder <span class="variable">point</span>
      }
    </pre>
  </div>

  <p>
    Nous profitons ici de l'architecture en arbre. Le fait d'avoir partionné l'espace de manière récursive nous permet de changer la manière dont nous posons notre question : nous ne demandons plus "parmi tous les points quels sont ceux qui se
    trouvent dans le cercle rouge ?". La complexité <code>0(n)</code> est loin maintenant. L'espace étant divisé et mis sous la reponsabilité d'une multitude de noeuds, nous n'avons plus qu'à descendre l'arbre étage par étage. Tant qu'un noeud nous
    répond "oui, vous me recouvrez" nous continuons à poser encore et toujours la même question. Jusqu'à arriver au dernier noeud, à la feuille qui nous dit "oui, vous me recouvrez, tenez, voici les points que j'ai sous ma responsabilité". Et là,
    seulement à ce moment là, on peut tester si le point est contenu dans le cercle rouge.


  <div class="row justify-content-center" id="figure06">
    <figure class="figure">
      <img src="media/requete.svg" class="figure-img img-fluid rounded" alt="" title="" width="800" />
      <figcaption class="figure-caption text-center">Figure 6 :</figcaption>
    </figure>
  </div>


  <p>
    En somme, grâce au travail préalable de division de l'espace et de construction de l'arbre nous avons déplacé ce sur quoi porte notre question : nous ne demandons plus aux points "êtes vous dans le cercle?", nous demandons aux noeuds "êtes vous
    dans le cercle?" Et si un noeud nous répond non, nous n'irons pas poser la question à ses noeuds enfants. Nous pouvons alors tout simplement abandonner les recherches dans la région sous sa reponsabilité, il n'y aucune chance qu'un de ses points
    se trouve dans notre cercle. Un pan entier de l'espace est soustrait à nos efforts de recherche.
  </p>

  <p>
    Analyser la complexité d'une requête dans un quadtree n'est pas évidente car elle dépend de la requête elle même et de la structure de l'arbre. Cependant nous pouvons estimer les complexité aux cas limites : si tous les points sont présents dans
    notre cercle rouge alors nous retombons sur la pire complexité, en <code>0(n)</code>. Si cette situation se présente majoritairement cela ne signifie pas que le quadtree est à blâmer, mais plutôt qu'il y'a un problème en terme de design au niveau
    de votre programme. Si 99% des points sont systématiquement candidats à votre requête alors l'utilisation d'un quadtree n'est pas nécessairement pertinent. A l'inverse, si la requête est très ciblée, et qu'une seule feuille est recouverte par le
    cercle, elle va traverser l'arbre directement de la racine à la feuille et la complexité sera de <code>0(p)</code>, où p est la profondeur de la feuille. On peut donc au moins garantir que la complexité de notre requête est comprise entre
    <code>0(p)</code> et <code>0(n)</code>. C'est déjà une grande nouvelle, car la complexité <code>0(n)</code> qui était garantie à 100% par notre solution naïve est désormais devenue celle du cas le plus extrême.
  </p>


  Voyons à présent les détails de l'implémentation de la requête.
  </p>
  <h2 id="implementation">Implémentation de l'interrogation du quadtree : <code class="language-javascript">query()</code></h2>

  <pre class="language-javascript line-numbers">
    <code class="language-javascript">
      query(circleProbe, points) {

        if (!points) {
          points = [];
        }

        let boundingBox = {
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h
        };

        if (!circleProbe.intersects(boundingBox))
          return;

        this.children.forEach(child => {

          if (child instanceof Node)
            child.query(circleProbe, points);
          else
            child.forEach(p => {
              if (circleProbe.contains(p))
                points.push(p);
            });

        });

        return points;
      }
    </code>
  </pre>




  <h2>Notion de profondeur</h2>

  <h4>Insertion</h4>

  <div id="demo02">
    <div id="radioContainer-demo02">

      <input type="radio" id="normal-demo02" name="insertionModeGroup-demo02" value="point" checked="checked">
      <label for="point"><acronym title="Insère un unique point à chaque clic">Point</acronym></label>

      <input type="radio" id="gaussian-demo02" name="insertionModeGroup-demo02" value="gaussian">
      <label for="gaussian"><acronym title="Insère un nuage gaussien de points à chaque clic">Nuage de points</acronym></label>

      <label for="nbPointsGaussian-demo02">Nombre de points à insérer</label>
      <input type="range" id="nbPointsGaussian-demo02" name="nbPointsGaussian-demo02" value="100" min="10" max="250" disabled="">
      <output id="nbPointsGaussianValue-demo02"></output>
    </div>

    <h4>Infos</h4>
    <div class="highlightContainer">

      <label for="depth_current" <acronym title="Profondeur du noeud sous la souris">Profondeur sous le curseur: </label>
      <span id="depth_current" name="depth_current"></span>

      <label for="depth_max" <acronym title="Profondeur maximale observée dans le quadtree">Profondeur maximale de l'arbre: </label>
      <span id="depth_max" name="depth_max"></span>

      <div>
        <label for="nbPointsTotal-demo02">Points insérés : </label>
        <span id="nbPointsTotal-demo02" name="nbPointsTotal-demo02">0</span>
      </div>
    </div>
    <div class="resetButtonContainer_demo02">
      <!-- <input type="button" value="reset"> -->
      <button type="button" class="btn btn-primary btn-sm" id="resetButton-demo02" disabled>Réinitialiser</button>
      <input id="switch-demo02" type="checkbox" data-toggle="toggle" data-on="En cours" data-off="En Pause" data-onstyle="success" data-offstyle="warning" data-size="sm" class="switch-demo">
    </div>


    <div>Naviguer vers la démo: <a href="#demo01">1</a> - <a href="#demo02">2</a> - <a href="#demo03">3</a></div>
    <div id="canvas-demo02-depth" class="myCanvas">

    </div>

  </div>


  <h2>Attacher des données aux feuilles</h2>

  <h2>Utilisation d'un Quadtree pour la détection de collisions</h2>



  <div id="demo03">




    <div>
      <div id="radioContainer-demo03">

        <input type="radio" id="quadtree" name="algorithme" value="quadtree" checked="checked">
        <label for="quadtree"><acronym title="Utiliser le quadtree">Quadtree</acronym></label>

        <input type="radio" id="naive" name="algorithme" value="naive">
        <label for="naive"><acronym title="Utiliser l'algorithme naïf qui parcourt toutes les paires">Approche naïve</acronym></label>



        <label for="nbParticules">Nombre de particules</label>
        <input type="range" id="nbParticulesRange" name="nbParticules" value="200" min="2" max="1000">
        <output id="output-nbParticules"></output>
      </div>
    </div>

    <h4>Infos</h4>
    <div>
      <label for="timeToBuildQuadtree" <acronym title="Temps d'éxecution nécessaire à la construction du quadtree uniquement">Temps construction du Quadtree (ms) : </label>
      <span id="timeToBuildQuadtree" name="timeToBuildQuadtree"></span>
    </div>
    <div>
      <label for="timeToComputeInteractions" <acronym
        title="Temps d'execution nécessaire au calcul de toutes les interactions. Dans le cas de l'approche naive le calcul mesure le temps nécessaire pour parcourir toutes les paires de particules. Dans le cas du quadtree, le calcul comprend le temps de construction du quadtree et des querry.">Temps
        total du calcul de toutes les interactions (ms) :</label>
      <span id="timeToComputeInteractions" name="timeToComputeInteractions"></span>
    </div>

    <div>
      <input type="checkbox" name="showQuadTreeCheckbox" id="showQuadTreeCheckbox">
      <label for="showQuadTreeCheckbox">Afficher quadtree</label>
      <input type="checkbox" name="showDetectionZoneCheckbox" id="showDetectionZoneCheckbox">
      <label for="showDetectionZoneCheckbox">Afficher zones de détection</label>
    </div>

    <div>Naviguer vers la démo: <a href="#demo01">1</a> - <a href="#demo02">2</a> - <a href="#demo03">3</a></div>

    <div class="resetButtonContainer">
      <!-- <input type="button" value="reset"> -->
      <button type="button" class="btn btn-primary btn-sm" id="resetButton-demo03">Réinitialiser</button>
      <input id="switch-demo03" type="checkbox" data-toggle="toggle" checked data-on="En cours" data-off="En Pause" data-onstyle="success" data-offstyle="warning" data-size="sm" class="switch-demo">
    </div>

    <div id="canvas-demo03-collisions" class="myCanvas">
    </div>
  </div>
  <h2>Sources : aller plus loin</h2>


  <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

  <script src="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/js/bootstrap4-toggle.min.js"></script>

  <script src="js/lib/prism.js"></script>

</body>




<!-- TODO: faire import plus propre -->
<script src="js/quadTree.js"></script>
<script src="js/pedagogic_extension.js"></script>
<script src="js/api_render.js"></script>

<script src="js/demo01/ui_app01.js"></script>
<script src="js/demo01/app01.js"></script>

<script src="js/demo02/app02.js"></script>
<script src="js/demo02/ui_app02.js"></script>

<script src="js/demo03/ui_app03.js"></script>
<script src="js/demo03/app03.js"></script>

<script src="js/main.js"></script>


</html>
