<!doctype html>
<html lang="fr">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <script src="https://code.jquery.com/jquery-3.5.0.min.js" integrity="sha256-xNzN2a4ltkB44Mc/Jz3pT4iU1cmeR0FkXs4pru/JxaQ=" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
  <script>
    $(function() {
      $("#navbar").load("/components/navbar.html");
    });
  </script>
</head>

<body>

  <div class="container-fluid">



    <h1>Programmation asynchrone et callbacks en Javascript :
      dissiper les confusions</h1>

    <div id="intro">
      <p>
        Partager une expérience passée d’incompréhension n’est pas évidente. Car une fois qu’on a compris ce qu’on ne comprenait pas, on ne comprend plus ce qu’on n'avait pas compris. Néanmoins je vais tenter de remonter le fil de ce qui était un
        brouillard.
      </p>

      <p>
        Au cours de mon apprentissage des fonctions dites de callback et de la gestion des appels de fonctions asynchrones je me suis retrouvé emporté dans un flot d’ambiguïtés concernant les relations existantes entre ces deux concepts. J’imaginais
        par exemple qu’une fonction de callback héritait d’une qualité, celle d’être appelée de manière asynchrone. Ces deux concepts sont tellement liés dans la plupart des articles de blog ou de vidéos sur le traitement asynchrone, qu’une confusion
        croissante a fini par s’installer en moi lors de mon apprentissage.
      </p>


      <p>
        Si cet article peut aider ceux, qui comme moi, ont été emportés dans l’incompréhension et la confusion la plus totale sur ce sujet alors j’en serai ravi. Car pour ma part, cet article est pour moi le serment de ne plus jamais retourner sur ce
        chemin.
      </p>


    </div>


    <h2>Les fonctions de rappel ou <em>callbacks</em></h2>

    <h3>Le mot ‘callback’ ou ‘rappel’</h3>

    <p>
      Tout le monde est d’accord là dessus, les mots ont du sens. Nous pensons à partir des mots. Supprimer un mot et vous ne pourrez plus penser le concept ou la situation porté par ce mot. Le nom d’une chose est important pour penser. Nommez mal
      une chose et vous y penserez mal, et votre cerveau devra toujours faire un effort, nager un tout petit peu à contre courant, pour lever l’ambiguïté que ce mot porte avec lui. Ces faits se vérifient tous les jours en programmation où bien nommer
      des choses est la première étape pour qu’un programme soit facile à comprendre et à maintenir. Car il est facile de penser à partir de choses bien nommées.
    </p>

    <p>
      Pour moi c’est ce mot, callback, qui m’a donné du fil à retordre en Javascript. Déjà, dans toute opération de traduction d’une langue à une autre il s’opère une perte de sens incompressible. Callback en anglais possède plusieurs sens en
      fonction des contextes. En informatique, le sens qui nous intéresse est le suivant : « a function pointer passed to another function », ou en français « un pointeur de fonction passé à une autre fonction ». Une fonction de rappel, ou callback,
      c’est une fonction passée en argument à une autre fonction. La définition ne nous dit pas ce que la fonction prenant en argument cette fonction en fait, comment elle l’appelle etc. Le terme « rappel » n’a ici aucun sens qui se rapproche du sens
      commun et pour moi la confusion a pris racine ici.
    </p>


    <p>Callback en anglais se traduit par rappel, rappeler. Et rappeler en français veut dire « action de faire revenir ». Le terme fonction de rappel porte donc avec lui, implicitement, l’idée selon laquelle la fonction sera rappelée ou reviendra,
      plus tard dans le temps. Ce terme emporte donc, à tord, la notion d’action dans le futur, et recoupe la notion d’asynchrone, ce« qui ne suit pas le mouvement imposé ». </p>

    <p>Un traitement asynchrone est nécessaire lorsqu’une fonction prend un temps jugé trop long à retourner et lorsqu’elle risque de bloquer le flot du programme (c’est à dire l’exécution de la fonction suivante) le temps de sa propre exécution. La
      tache peut alors prendre en argument une fonction de retour et être déléguée à un autre thread, qui nous préviendra lorsque son exécution sera terminée en éxecutant cette callback. Typiquement en Javascript si l’on souhaite faire une requête à
      une base données ou à un serveur, ce genre de requête pouvant prendre un certain temps, on le fera de manière asynchrone. Dans ce cas, nous perdons le contrôle sur le flot du programme mais nous serons avertis lors du retour de la fonction, à
      un moment indéterminé dans le futur.</p>

    <p>Et la désignation rappel, qui éveille en nous le sens commun du mot, nous incite à donner à la fonction, inconsciemment, sans effort, une qualité asynchrone. Alors que non, pas du tout ! Pour moi la première difficulté réside là : le terme de
      callback, de rappel a été donné à toute fonction passée en paramètre d’une autre, en référence à son cas d’utilisation le plus courant.</p>

    <p>Regardons cet exemple de callback :</p>

    <div id="snpippet-node">
      <pre>
    <code class="language-javascript">
      function bar(){
	// vous pouvez mettre ici une boucle interminable
	console.log(‘bar’) ;

function foo(bar){
	console.log(‘foo’) ;
	bar() ;
}

foo(bar) ;
console.log(‘ok’) ;
    </code>
  </pre>
    </div>

    <p>La fonction bar, étant donnée qu’elle est passée à foo en argument, est par définition une fonction de rappel, un callback. Pourtant ce code donne évidemment le résultat suivant :</p>

    <div id="snpippet-node">
      <pre>
  <code class="language-javascript">
    ‘foo’ 
    ‘bar’
    ‘ok’
  </code>
</pre>
    </div>


    <p>
      Rien de surprenant, l’ordre des appels est respecté. Tout est bien synchrone, le programme s’exécute de manière impérative, comme nous en avons l’habitude dans des langages de programmation conventionnel. Finalement bar est appelée comme foo
      l’est. Elle est appelée, comme n’importe quelle fonction, elle n’est pas rappelée. Le sens commun de rappel ne s’applique pas ici, callback y signifie seulement ‘est passé en argument à une autre fonction’.
    </p>

    <h3>Lorsque le terme callback correspond au sens commun</h3>

    <p>Le problème de ce terme c’est que dans son usage courant en Javascript il signifie bien à la fois est ‘passé en argument à une autre fonction’ et ‘est rappelé plus tard dans le temps’. Par exemple, c’est ce qui arrive à chaque fois que nous
      déclarons des écouteurs d’évènement :</p>



    <div id="snpippet-node">
      <pre>
        <code class="language-javascript">
element.addEventListener(‘onClick’, bar) ;
        </code>
      </pre>
    </div>


    <p>
      Ici la fonction bar est un callback, car elle est passée en argument à la fonction addEventListener et elle sera effectivement rappelée « plus tard », lorsque l’évènement ‘onClick’ sur l’élement aura lieu et sera traité. Ici, la notion de
      rappel est respectée à la fois dans le sens commun et dans le sens informatique. Le fait que la fonction bar soit rappelée plus tard n’a rien à voir avec le fait qu’elle soit passée en argument, qu’elle soit une callback, c’est seulement parce
      que la fonction addEventListener prend en argument une fonction pour l’executer, elle, de manière asynchrone.
    </p>

    <p>
      En résumé de ce premier point, une fonction de rappel ou callback est une fonction passée en argument à une autre fonction. La convention de nommage callback n’a rien à voir avec le fait qu’une fonction soit traitée de manière synchrone ou non,
      comme le suggère le sens commun du mot.
    </p>

    <p>
      Cette dénomination ‘callback’ est malheureuse car dans le cas de Javascript elle est bel et bien un exemple d’abus de langage. En effet, en programmation événementielle, il est courant de passer en argument une fonction à une autre, pour
      qu’elle soit rappelée « plus tard », au bon moment. Et par abus de langage toute fonction passée en argument finit par être nommée callback, même dans le cas où aucun traitement asynchrone n’a lieu.
    </p>


    <h3>Naïveté, errance puis enfin le fond</h3>

    <p>
      Je suis peut-être idiot ou le seul à avoir pensé cela, mais cette confusion sur le lien entre callback et appel asynchrone m’a amené à penser que lorsque je passais une fonction en argument à autre fonction alors celle-ci, étant une callback,
      serait ‘rappelée’ plus tard. En somme, j’ai pensé que si passais une fonction en argument à une autre fonction, la callback serait traitée de manière asynchrone. Pour essayer de comprendre tout cela, je me suis retrouvé à écrire des bouts de
      code insensés à base de setTimeout(), comme le propose beaucoup de tutos en ligne sur ces questions. Maintenant que tout est éclairci, je ne suis même plus capable de me rappeler ce que j’ai pu écrire pour mettre à l’épreuve ma compréhension.
      Je n’en ai pas gardé la trace, et peut-être est-ce mieux ainsi car cela aurait pu devenir embarrassant. Si ce que je viens de dire vous paraît insensé ce n’est pas grave, c’est juste pour vous montrer à quel niveau de confusion j’en étais
      rendu.
    </p>


    <p>
      J’ai compris ensuite, en descendant au niveau du fonctionnement général du moteur Javascript qu’il n’était pas possible de développer en Javascript ses propres fonctions asynchrones. Que ça ne marchait pas comme ça.

      Pour éclaircir la situation je vais refaire le chemin que j’ai du faire alors : visiter les coulisses de JavaScript, du moins un modèle simplifié mais qui en préserve les ingrédients essentiels, en me servant de la fonction setTimeout comme
      guide.
    </p>


    <h2>Callstack, Web API, Callback queue et Event-loop : au coeur de Javascript</h2>


    <p>Pour la suite je fais le choix de garder les mots anglais pour désigner les processus où les éléments techniques. Ces mots seront ceux rencontrés en permanence dans les documentations ou les ressources en ligne, et plutôt que d’en proposer des
      traductions hasardeuses ou non standardisées je préfère employer ceux qui sont d’usage. </p>

    <h3>Javascript est mono-threadé, « there is not such a thing as asynchronous calls in Javascript »</h3>

    <p>L’interpréteur Javascript dans le navigateur est mono-threadé, c’est à dire qu’il ne possède qu’une stack mémoire. La stack est une zone mémoire où les données sont ajoutées ou retirées suivant l’architecture d’une pile : <a
        href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation ">dernier entré, premier sorti</a> </p>


    <p>A chaque appel de fonction rencontré par le flot du programme un contexte mémoire (stackframe) est créée sur la stack (ou callstack) . Le contexte contient toutes les informations nécessaires à l’exécution de la fonction  (arguments, variables
      locales, références vers des fonctions appelées à l’intérieur, références vers des objets présents dans l’environnement d’exécution de la fonction, référence vers les objets dans le contexte global…) Je ne souhaite pas rentrer dans les détails
      sur ces aspects car ils ne servent pas mon propos, mais vous pouvez en apprendre plus <a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/">ici</a> ou <a
        href="https://medium.com/@happymishra66/execution-context-in-javascript-319dd72e8e2c"></a>là</p>.

    <p>
      Une fois que la fonction a fait son travail et a retourné son contexte est détruit et retiré de la stack. Si l’on reprend l’exemple de tout à l’heure 
    </p>


    <div id="snpippet-node">
      <pre>
<code class="language-javascript">
  function bar(){
  	console.log(‘bar’) ;

  function foo(bar){
  	console.log(‘foo’) ;
  	bar() ;
  }

  foo(bar) ;
</code>
</pre>
    </div>

    <p>Voici schématiquement ce qu’il se passe dans la stack </p>

    <div class="row justify-content-center" id="stacktrace">
      <figure class="figure">
        <img src="stacktrace.svg" class="figure-img img-fluid rounded" alt="" title="" width="800" />
        <figcaption class="figure-caption text-center"></figcaption>
      </figure>
    </div>


    <p>
      Le navigateur au moment du chargement du script Javascript et de l’initialisation de la stack génère par défaut un contexte spécial, le global execution context, qui se trouve poussé dessus. Ce contexte existe sur toute la durée de vie du
      thread. Le flot rencontre l’appel de foo, un nouveau contexte est poussé sur la stack pour foo. Au sein de la fonction foo il y’a un appel a console.log, un nouveau contexte est crée pour cet appel. Il est exécuté et retiré de la stack. Ensuite
      arrive l’appel de bar, un nouveau contexte est crée, bar est exécutée, retourne, son contexte est détruit. Enfin foo retourne, son contexte est détruit et la stack devient vide.
    </p>

    <p>
      Ce qu’il faut retenir de cette abstraction de l’interpréteur Javascript c’est qu’il est monothreadé (il ne possède qu’une stack) et que tout s’y exécute de manière synchrone. Une seule chose peut s’y passer à la fois.
    </p>

    <p>Ce même thread est également <a href="https://www.youtube.com/watch?v=cCOL7MC4Pl0 ">utilisé par le navigateur pour rafraichir la vue et repeindre son canvas</a>. Le rendering a lieu en général à intervales définis (pour ne pas rafraichir pour
      rien) lorsque <em>la stack est vide</em>. Cela explique pourquoi lorsqu’un traitement est trop long dans la stack le rendu est bloqué et le navigateur ne semble plus répondre aux inputs. D’où l’intéret d’utiliser des traitements asynchrones
      afin de laisser au navigateur la possibilité de se repeindre et de traiter les interactions utilisateurs.</p>

    <h3>Traitements asynchrones et Web API</h3>

    <p>
      Mais si Javascript est monothreadé comment peut-on y faire du traitement asynchrone ? Javascript est monothreadé mais son environnement d’execution lui est multi-threadé, que ce soit le navigateur ou l’écosystème de Node.js.
    </p>

    <p>
      Pour pouvoir réaliser et gérer des traitements asynchrones le thread de javascript communique via la Web API (ou une api en C++ dans le cas de Node) avec son environnement d’execution et lui délègue des taches (faire des requetes à un serveur,
      a une base données, ecriture/lecture de fichier etc...) La web Api désigne l’ensemble des ressources, données et méthodes mises à disposition par le navigateur au thread de Javascript : le DOM, setTimeout, xmlhttprequest… La fonction setTimeout
      ne fait pas partie de Javascript, c’est une api entre le thread JavaScript et l’écosystème du navigateur. Un traitement asynchrone en Javascript se fait donc toujours en passant par l’api exposée du navigateur. Mais attention, nativement,
      Javascript ne délègue jamais du code javascript à un autre thread : javascript est mono-threadé !
    </p>

    <p>
      Lorsqu’on appelle setTimeout par exemple
    </p>

    <div id="snpippet-node">
      <pre>
<code class="language-javascript">
setTimeout( function foo() => { console.log(‘foo’);}, 1000) ;
</code>
</pre>
    </div>

    <p>
      on lui passe une référence vers une fonction, une callback. On délègue ainsi au navigateur la tache d’imposer un délai à l’execution de la fonction foo. La fonction setTimeout est immédiatement executée et retourne, son contexte est retiré de
      la pile et l’interpréteur peut continuer à exécuter du code sur la stack. SetTimeout a lancé une tache prise en charge par le navigateur : celle d’ imposer un délai de 1s à l’execution de foo. Une fois ce délai passé le navigateur place la
      fonction foo dans la callback queue. Lorsque la stack de Javascript est vide, l’event loop prend la première tache dans la queue et la pousse sur la stack Javascript. Cette tache n’est rien d’autre que la callback foo.
    </p>


    <div class="row justify-content-center" id="system">
      <figure class="figure">
        <img src="system.svg" class="figure-img img-fluid rounded" alt="" title="" width="800" />
        <figcaption class="figure-caption text-center"></figcaption>
      </figure>
    </div>

    <p>
      On remarque au passage que le délai au bout duquel s’executera la fonction foo ne sera pas nécessairement égal à celui demandé à l’appel de setTimeout (1s). Lorsque la queue possède déjà des événements en attente d’être traités, la fonction foo
      attend son tour comme les autres. Le délai passé à setTimout correspond donc au délai minimum avant que foo ne soit executée. Mais une fois passée à la webapi nous perdons le contrôle et son délai d’execution dépend de l’état de la queue. La
      seule garantie ici est que foo sera appelée au moins dans 1 seconde.
      En effet, dans la queue on peut trouver d’autres évènements en attente. Par exemple lorsque l’on écrit
    </p>

    <div id="snpippet-node">
      <pre>
<code class="language-javascript">
element.addEventListener(‘onClick’, bar) ;
</code>
</pre>
    </div>


    <p>
      on appelle l’api EventListener du navigateur et on lui dit «  lorsque l’élement du DOM sous ton contrôle recevra l’élement click, alors envoie moi sur la stack Javascript la fonction bar pour que je l’execute » . Lorsque l’élement est cliqué,
      le navigateur place la methode bar dans la callback queue et lorsqu’elle arrive au début de la file d’attente, et que la stack est vide, l’event loop la pousse et bar est executée dans le thread Javascript.
    </p>

    <p>
      C’est une vision très schématique de l’écosystème du navigateur mais qui en préserve les principes. En réalité <a href="https://www.youtube.com/watch?v=cCOL7MC4Pl0">il existe plusieurs queues</a>, chacune ayant sa dynamique propre vis à vis de
      l’event loop. La gestion des évènements est optimisée, par exemple, en leur assignant des priorités (certains évènements sont plus prioritaires que d’autres). Mais ça ne change pas grand-chose à ce qui nous intéresse ici
    </p>

    <p>
      On peut voir que dans le contexte d’execution asynchrone, à l’appel de la web api (ou d’une api C++ avec Node), le terme de callback y a effectivement tout son sens. Ces fonctions sont « appelées plus tard », on les fait bien revenir au terme d’un traitement asynchrone.
    </p>

    <p>
      Nous l’avons vu, les exécutions asynchrones en javascript ne se font pas à proprement parler « en » javascript mais par l’intermédiaire d’un thread supplémentaire mis a disposition par le navigateur (ou par Node). Javascript est monothreadé et son thread, en plus d’avoir sa propre autonomie est alimenté par l’event loop de son environnement. L’event-loop et la queue sont les briques de base d’une architecture du paradigme de la programmation événementielle.
    </p>

    <p>
      Les callbacks qui retombent sur la stack doivent être traitées et gérées par le développeur pour faire tourner correctement son programme. Cependant dès que nous passons notre callback à la webapi nous perdons le contrôle sur le flot de notre programme et nous ne sommes plus sûrs de rien. Comment gérer alors le retour de nos callbacks sur la stack ? Pour reprendre mon exemple précédent, comment je m’y prends si je souhaite appeler une autre fonction uniquement après que foo ait été exécutée  correctement?
    </p>

    <h2>Retour sur la stack : gestion des évènements asynchrones</h2>


    <h3>Callback hell</h3>

    <p>
      Nous l’avons compris maintenant, nous pouvons utiliser la fonction setTimeout pour simuler un traitement long asynchrone, étant donné que nous faisons appel aux ressources du navigateur grâce à son api. Comment m’y prendre si je souhaite réagir suite à l’execution de ma fonction asynchrone ? Par exemple
    </p>

    <div id="snpippet-node">
      <pre>
<code class="language-javascript">
  setTimeout(function foo() {
    //fait des trucs de manière asynchrone et fournit un resultat
    let result = 'foo';
    if (result = 'foo') {
      console.log('foo succès');
    } else {
      console.log('foo échec')
    }
  }, 3000);
</code>
</pre>
    </div>

    <p>
      Je voudrais ici appeler une fonction bar aussitôt ‘foo succès’ affiché dans la console au moins 3 secondes après l’execution de ce code. Je ne peux pas écrire du code à la suite de setTimeout car l’execution de setTimeout est immédiate. La fonction foo est passée à la webapi et, après un délai, attend son tour dans la callback queue.  Elle va retomber dans la stack à un moment que je ne peux pas déterminer. Mon unique solution est donc d’appeler directement ma nouvelle fonction depuis foo.
    </p>

    <p>
      Voici un exemple d’appels  permettant d’enchainer les traitements asynchrones. Chaque traitement asynchrone renvoie la callback sur la stack à un moment indéfini. Je suis donc obligé de passer à chaque traitement asynchrone une référence vers le prochain traitement asynchrone ou, plus directement encore, de définir dans chaque traitement le prochain traitement. Dans chaque callback on définit une callback, puis encore une callback etc... En pratique voici ce que ça donne
    </p>

    <div id="snpippet-node">
      <pre>
<code class="language-javascript">
  setTimeout(function foo() {
    //fait des trucs de manière asynchrone et fournit un resultat
    let result1 = 'foo';
    console.log('foo succès');
    if (result1 === 'foo') {
      setTimeout(function bar(){
        //fait des trucs de manière asynchrone et fournit un resultat si foo a réussi
        let result2 = 'bar';
        console.log('bar succès');
        if (result2 === 'bar') {
          //fait des trucs de manière asynchrone et fournit un resultat si foo, puis bar a réussi
          setTimeout(function foo-bar() {
            console.log('foo-bar succès');
          }, 1000);
        } else {
          console.log('bar échec');
        }
      }, 2000)
    } else {
      console.log('foo échec');
    }
  }, 3000);
</code>
</pre>
    </div>


    <p>Rien qu’à l’écriture, déjà, c’est pénible.  Imaginez revenir à ce code dans 3 semaines pour le débugger ou le faire évoluer. C’est l’enfer, le callback hell. Les callback sont définies récursivement les unes à l’intérieur des autres. Ce bout de code, pourtant gardé volontairement simple ici, ne dévoile pas ses intentions, ne dit pas comment il fonctionne ou ce qu’il fait. Ces symptômes sont une alerte. Et plus l’enchaînement des traitements augmente et plus cette suite d’appels sera profonde et illisible.  </p>

    <p>Le problème c’est que jusqu’à l’arrivée du système de promesses il n’y avait aucun autre moyen d’écouter le retour sur la stack d’un traitement asynchrone. Il fallait que le retour contienne lui même une référence vers la fonction à appeler en cas de réussite ou d’echec du traitement asynchrone.</p>

    <h3> Les promesses</h3>

    <p>Les promesses sont apparues avec la norme EcmaScript 6 en 2015. Elles permettent de se débarrasser des structures récursives du callback hell et faire de la gestion de traitement asynchrones de manière plus lisible et plus propre.</p>

    <p>Cet article ne porte pas sur les promesses et n’a pas pour ambition de servir d’introduction à leur utilisation. Pour cela, vous pouvez vous reporter à la documentation ici [ref:] ou à de tres bons articles <a href="https://itnext.io/javascript-promises-vs-rxjs-observables-de5309583ca2">ici</a> où <a href="https://medium.com/codebuddies/getting-to-know-asynchronous-javascript-callbacks-promises-and-async-await-17e0673281ee">là</a>. L’ambition est plutot de faire sentir, de montrer en quoi l’usage des promesses se démarque, dans ses principes, de l’usage des callbacks. Les promesses sont une feature bienvenue en Javascript. Elles peuvent d’ailleurs être utilisées dans le cas de traitement synchrone ou asynchrone. Seulement, leur utilisation prend tout son sens dans le second cas.

    </p>

    <p>
      Avec les callbacks lorsqu’une fonction lance un traitement asynchrone, nous devons donner à cette fonction une nouvelle fonction pour lui dire quoi faire une fois le traitement terminé. Et éventuellement, à cette fonction une autre fonction et ainsi de suite. Chaque fonction a dans ce cas la responsabilité d’appeler la prochaine fonction, de déclencher le prochain traitement à faire.
    </p>


    <p>
      Avec les promesses c’est différent : une fonction qui lance une tache asynchrone n’a plus besoin de savoir quoi faire une fois son exécution terminée. Ce n’est plus sa responsabilité. Sa seule responsabilité est de s’executer. Dans un contexte asynchrone, sa seule responsabilité est de lancer le traitement asynchrone. Cette fonction s’exécute d’abord, lance son traitement, puis retourne immédiatement une promesse (un objet Javascript). Le programme Javascript continue ainsi son flot. La responsabilité de l’action à faire à la fin du traitement asynchrone revient dorénavant à cette promesse.
    </p>


    <p>Ré-écrivons notre fonction foo avec l’usage d’une promesse</p>


    <div id="snpippet-node">
      <pre>
<code class="language-javascript">
  function foo() {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        //fait des trucs de manière asynchrone et fournit un resultat
        let result1 = 'foo';
        if (result1 === 'foo')
          resolve('foo succès');
        else
          reject('foo échec')
      }, 3000);
    });
  }

  foo() ;
</code>
</pre>
    </div>


    <p>Nous retrouvons notre méthode foo qui retourne à présent une promesse. La promesse prend en argument une fonction qui est immédiatement executée. Ici setTimeout s’exécute : elle passe la callback à l’environnement du navigateur. L’event-loop finira par la pousser de la callback queue sur la stack. Remarquez que foo ne contient plus aucune référence ou une définition d’une callback a appeler à la fin de son exécution.  Elle n’en a plus la charge. Foo retourne ici une promesse, elle promet de retourner quelque chose, même si elle ne sait pas encore quoi et quand. La responsabilité du retour et de savoir quoi en faire revient donc à la promesse. </p>


    <p>Pour que la promesse puisse faire son travail, elle prend en argument de son constructeur deux fonctions, deux callbacks : resolve et reject. Une seule des deux callback sera appelée à la fin du traitement : resolve si le traitement réussit, reject si le traitement échoue. On dit dans le premier cas que la promesse a été tenue, dans le second que la promesse a été rejetée. Et oui, nous sommes toujours obligés de passer des callback car nous devons bien définir d’une manière ou d’une autre si notre traitement a réussi ou échoué. Mais au lieu de dire à foo quoi faire en cas d’échec ou de réussite, nous disons à la promesse quoi dire en cas d’échec ou de réussite. </p>


    <p>Lorsque le traitement asynchrone est terminé, la callback passée en argument à setTimeout revient sur la stack, est executée et notifie la promesse. Nous pouvons alors interroger la promesse pour savoir comment notre traitement s’est passé. Pour cela, la promesse nous met à disposition deux méthodes : then() et catch()</p>

    <div id="snpippet-node">
      <pre>
<code class="language-javascript">
  foo().then((resultatSucces)=>{
    console.log(resultatSucces);
  })
  .catch((resulatErreur)=>{
    console.log(resulatErreur);
  })
</code>
</pre>
    </div>


    <p>La méthode then est mappée à la fonction resolve passée au constructeur de la promesse. Si la promesse appelle resolve() alors on tombera dans then(). On dit que la promesse est tenue (fulfilled). Si la promesse appelle reject() alors on tombera dans le catch(), la promesse est rejetée (rejected). </p>

    <p>Changer la valeur de result1 et vous verrez que vous tombez soit dans le then, soit dans le catch. </p>

    <p>Vous voyez maintenant qu’à la place d’un simple log je pourrais décider d’appeler une autre fonction dans le then en cas de succès, ou une autre dans le catch en cas d’erreur. On remarque déjà que, contrairement à sa première implémentation à l’aide de callback, foo n’est plus responsable des actions à effectuer en cas de succès ou d’échec. Ces actions, ces appels de fonction se font dorénavant en dehors d’elle, à la suite. On ne fabrique plus des appels dans des appels dans des appels comme dans le callback hell, mais des appels à la suite les uns des autres. Grace aux promesses nous passons d’une structure d’appels imbriquée à une structure d’appels chaînée.</p>


    <p>Si nous voulons reproduire l’exemple précédent et chaîner nos traitements les uns aux autres voici ce que nous aurons :</p>


    <div id="snpippet-node">
      <pre>
<code class="language-javascript">
  foo()
  //Appel de bar
  .then((result) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        console.log(result)
        //fait des trucs de manière asynchrone et fournit un resultat
        let result2 = 'bar2';
        if (result2 === 'bar')
          resolve('bar succès');
        else
          reject('bar echec');
      }, 1000);
    });
  })
  //Appel de foo-bar
  .then((result) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        console.log(result)
        resolve('foo-bar succès');
      }, 1000);
    });
  })
  .then((result) => {
    console.log(result);
  })
  .catch((error) => {
    console.log(error);
  });
</code>
</pre>
    </div>


<p>Ce n’est pas encore la panacée, mais déjà c’est plus lisible. Les mots clefs then et catch me renseignent au premier coup d’oeil sur les intentions de ce code et sur sa logique. Cette séquence d’appels n’est plus imbriquée. Chaque appel successif est devenu un bloc autonome. Si je veux modifier un des traitements, je n’ai plus besoin de descendre dans l’enfer des callback et trouver le bon étage pour y apporter mes modifications. Je n’ai qu’à aller dans le block then correspondant. Si je veux ajouter un traitement à la chaine, je n’ai qu’à ajouter un bloc sous un autre. La pyramide de callback est devenue une bien plus agréable chaîne de promesses.</p>



<h3>Syntaxic sugar : async et await</h3>


<p>Nous avons vu, comment en principe, nous pouvons sortir de l’enfer des callback à l’aide des promesses et écrire du code plus lisible. Néanmoins, on l’a vu, la syntaxe est encore un peu lourde. L’enchainement des then et des valeurs de retours passant d’un then à l’autre peut devenir rapidement difficile à suivre.</p>


<p>En 2017 la norme EcmaScript8 arrive avec deux nouveaux  mots clés : async et await. Contrairement au passage de l’utilisation des callback à celle des promesses dans la gestion de l’asynchrone, cette nouvelle norme n’introduit aucune nouvelle feature, sinon du sucre syntaxique. Cependant lorsqu’une syntaxe nouvelle arrive et permet d’écrire du code de manière plus transparente et lisible, et sauve ainsi beaucoup de temps au développeur, on peut parler de feature. C’est plus agréable à écrire et manipuler, mais sous le capot, le moteur reste celui des promesses.</p>

<p>Reprenons notre chaine d’appels. Nous allons l’encapsuler dans une fonction que l’on signalera faisant un traitemement asynchrone avec le mot clé async.</p>

<div id="snpippet-node">
  <pre>
<code class="language-javascript">
  async function maChaineDeTraitementsAsynchrones() {

  	const result = await foo();
  }
</code>
</pre>
</div>


<p> Cela nous permet d’utiliser le mot await à l’intérieur de la fonction déclarée avec async. Le mot clé await se place devant l’évaluation d’une fonction qui retourne une promesse. On peut donc la placer devant l’appel de notre methode foo. Si nous voulons utiliser le résultat renvoyé par foo, par exemple le logger il suffit d’écrire </p>

<div id="snpippet-node">
  <pre>
<code class="language-javascript">
  async function maChaineDeTraitementsAsynchrones() {

	const resultatSucces = await foo();
	console.log(resultatSucces) ;
}
</code>
</pre>
</div>


<p>Ce code est équivalent à notre code précédent</p>

<div id="snpippet-node">
  <pre>
<code class="language-javascript">
  foo().then((resultatSucces)=>{
    console.log(resultatSucces);
  })
</code>
</pre>
</div>

<p>Avec le mot clé await, l’instruction suivante de la fonction  maChaineDeTraitementsAsynchrones (ici le console.log) n’est executée que si la promesse a été acquittée. Une promesse est acquitée lorsqu’elle n’est plus en attente, et donc qu’elle est tenue ou rejetée. Nous pouvons alors écrire notre chaine d’appels comme si nous étions en train d’écrire du code de manière synchrone,  ce qui est beaucoup plus lisible que l’enchaînement des then et des rebonds entre valeurs de retours et appels suivants. Comme foo fait un travail asynchrone on ne sait pas quand resultatSucces sera obtenu, mais nous n’avons plus à nous en soucier, car async/await et les promesses s’en chargent pour nous. Une instruction marquée d’un await « semble  bloquer » l’execution des l’instruction qui la suit. En réalité l’instruction suivante se comporte comme si elle se trouvait dans son then.</p>

<p>Attention cependant, on ne passe à l’instruction suivante que si la promesse a été tenue. Pour lever les erreurs il faut entourer notre chaîne d’instructions par un classique try/catch. Si vous ne le faites et qu’une de vos promesses appelle la méthode reject l’interpréteur Javascript vous renverra une erreur.</p>

<div id="snpippet-node">
  <pre>
<code class="language-javascript">
  async function maChaineDeTraitementsAsynchrones() {

   try{
  	const resultatSucces = await foo();
  	console.log(resultatSucces) ;

   } catch(erreur){
  	console.log(erreur) ;
   }
  }
</code>
</pre>
</div>

<p>Attention ici aussi à la confusion : le mot clef async ne signifie pas que votre fonction est devenue une fonction asynchrone, qu’elle lance des taches en parallèle etc.. Javascript est monothreadé ! Le mot clé dit seulement au développeur « attention, ici il y’a du traitement asynchrone et un usage invisibles de promesses ». Aync et await masquent seulement aux yeux du développeur l’architecture des promesses, mais elle est bien présente. Les then sont invisibles mais ils sont bien là. La fonction maChaineDeTraitementsAsynchrones n’est pas devenue une fonction asynchrone elle-même : chacune de ses instructions marqués du mot clé await retourne (une promesse), comme dans tout bon flot synchrone.</p>

<p>Afin d’être complet voici notre code fil rouge écrit à l’aide de la syntaxe async/await. </p>

div id="snpippet-node">
  <pre>
<code class="language-javascript">
  async function maChaineDeTraitementsAsynchrones() {


  try {

    const result = await foo();

    const result2 = await

    function(result) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          console.log(result);
          let result2 = 'bar';
          if (result2 === 'bar')
            resolve('bar succès');
          else
            reject('bar echec');
        }, 1000);
      });
    }(result);

    const result3 = await

    function(result) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          console.log(result);
          resolve('foo-bar succès');
        }, 1000);
      });
    }(result2);

    console.log(result3);


  } catch (error) {
    console.log(error);
  }

}
maChaineDeTraitementsAsynchrones();
</code>
</pre>
</div>

<p>On peut remarquer que la lisibilité est grandement améliorée : les mots async/await nous préviennent qu’il s’agit là d’un appel qui réalise du travail asynchrone. Cependant, les instructions à l’intérieur de cette méthode asynchrone se lisent comme une suite d’instructions synchrones, sans difficultés.</p>


<h2>Conclusion</h2>

<p>Nous avons vu que callback et traitements asynchrones sont deux concepts qui ne sont pas nécessairement liés. Le terme callback est utilisé pour désigner toute fonction passée en argument à une autre fonction, indépendamment de son traitement synchrone ou asynchrone. Par abus de langage, étant donné qu’en Javascript on passe régulièrement des fonctions à des fonctions dans le cas de traitement asynchrone (via la webapi), les callbacks sont souvent associées, « dans leur dénomination même » au traitement asynchrone lui-même, et à l’idée d’un appel qui revient. Lorsque l’on voit callback, il ne faut pas penser asynchrone. Il faut penser à une fonction passée en argument à une autre fonction, sans aucun a priori sur la manière dont elle sera appelée. La fonction à laquelle on passe notre callback fait peut-être du traitement asynchrone, mais pas nécessairement. </p>

<p>Nous avons finalement parcouru les différentes manières de faire de la gestion asynchrone à l’aide des callbacks, puis des promesses. Grâce aux promesses nous avons pu passer d’une structure d’appels imbriquée à une structure plus commode sous forme de chaîne. Enfin, les mots clés async et await, arrivés avec la norme ES8, masquent fortement la gestion asynchrone et permettent d’écrire et présenter le code à la manière d’un traitement synchrone. Ce confort supplémentaire augmente fortement la lisibilité du code.
</p>

<h2>Aller plus loin</h2>
<p>Les contextes et le moteur javascript :
What the heck is the event loop anyway ? Philip Roberts
https://www.youtube.com/watch?v=8aGhZQkoFbQ

http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/ https://medium.com/@happymishra66/execution-context-in-javascript-319dd72e8e2c

Les différentes queues
https://www.youtube.com/watch?v=cCOL7MC4Pl0
Traitement asynchrone :
https://itnext.io/javascript-promises-vs-rxjs-observables-de5309583ca2]  https://medium.com/codebuddies/getting-to-know-asynchronous-javascript-callbacks-promises-and-async-await-17e0673281ee

Une analogie sympa et illustrée du fonctionnement des promesses avec celui d’une commande au drive
https://frank.taillandier.me/2017/03/23/comprendre-les-promesses-en-javascript/</p>


</body>

<!-- <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script> -->
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>




</html>
